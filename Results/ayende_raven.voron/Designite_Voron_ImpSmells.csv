Implementation smell,Namespace,Class,File,Method,Description
Long Method,Voron.Impl.Backup,IncrementalBackup,C:\repos\ayende_raven.voron\Voron\Impl\Backup\IncrementalBackup.cs,ToFile,The method has 109 lines of code.
Long Method,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The method has 183 lines of code.
Long Method,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The method has 184 lines of code.
Long Method,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The method has 108 lines of code.
Long Method,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The method has 118 lines of code.
Complex Method,Voron.Debugging,DebugStuff,C:\repos\ayende_raven.voron\Voron\Debugging\DebugStuff.cs,HasDuplicateBranchReferences,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl,WriteBatch,C:\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,TryGetValue,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl,Transaction,C:\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,Commit,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl.Journal,JournalReader,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ValidateHeader,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,RecoverDatabase,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl.FileHeaders,HeaderAccessor,C:\repos\ayende_raven.voron\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,Cyclomatic complexity of the method is 8
Complex Method,Voron.Trees,Page,C:\repos\ayende_raven.voron\Voron\Trees\Page.cs,Search,Cyclomatic complexity of the method is 10
Complex Method,Voron.Trees,Tree,C:\repos\ayende_raven.voron\Voron\Trees\Tree.cs,DirectAdd,Cyclomatic complexity of the method is 9
Complex Method,Voron.Trees,TreeRebalancer,C:\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,Execute,Cyclomatic complexity of the method is 9
Long Parameter List,Voron.Impl,MemoryMapNativeMethods,C:\repos\ayende_raven.voron\Voron\Impl\MemoryMapNativeMethods.cs,CreateFileMapping,The method has 6 parameters. Parameters: hFile' lpFileMappingAttributes' flProtect' dwMaximumSizeHigh' dwMaximumSizeLow' lpName
Long Parameter List,Voron.Impl,MemoryMapNativeMethods,C:\repos\ayende_raven.voron\Voron\Impl\MemoryMapNativeMethods.cs,MapViewOfFileEx,The method has 6 parameters. Parameters: hFileMappingObject' dwDesiredAccess' dwFileOffsetHigh' dwFileOffsetLow' dwNumberOfBytesToMap' lpBaseAddress
Long Parameter List,Voron.Impl,WriteBatch,C:\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,TryGetValue,The method has 5 parameters. Parameters: treeName' key' value' version' operationType
Long Parameter List,Voron.Impl,BatchOperation,C:\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,BatchOperation,The method has 5 parameters. Parameters: key' value' version' treeName' type
Long Parameter List,Voron.Impl,BatchOperation,C:\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,BatchOperation,The method has 5 parameters. Parameters: key' value' version' treeName' type
Long Parameter List,Voron.Impl,BatchOperation,C:\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,BatchOperation,The method has 5 parameters. Parameters: key' value' version' treeName' type
Long Parameter List,Voron.Impl.Journal,Win32FileJournalWriter,C:\repos\ayende_raven.voron\Voron\Impl\Journal\Win32JournalWriter.cs,WriteFileGather,The method has 5 parameters. Parameters: hFile' aSegmentArray' nNumberOfBytesToWrite' lpReserved' lpOverlapped
Long Parameter List,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,Decode64,The method has 5 parameters. Parameters: input' inputLength' output' outputLength' knownOutputLength
Long Parameter List,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The method has 5 parameters. Parameters: hash_table' src' dst' src_len' dst_maxlen
Long Parameter List,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The method has 5 parameters. Parameters: hash_table' src' dst' src_len' dst_maxlen
Long Parameter List,Voron.Util,NativeFileMethods,C:\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,WriteFile,The method has 5 parameters. Parameters: hFile' lpBuffer' nNumberOfBytesToWrite' lpNumberOfBytesWritten' lpOverlapped
Long Parameter List,Voron.Util,NativeFileMethods,C:\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,ReadFile,The method has 5 parameters. Parameters: hFile' pBuffer' numBytesToRead' pNumberOfBytesRead' lpOverlapped
Long Parameter List,Voron.Util,NativeFileMethods,C:\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,Voron.Impl.FreeSpace,FreeSpaceHandling,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\FreeSpaceHandling.cs,TryFindContinuousRange,The method has 6 parameters. Parameters: tx' it' num' current' currentSectionId' page
Long Parameter List,Voron.Impl.FreeSpace,FreeSpaceHandling,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\FreeSpaceHandling.cs,TryFindSmallValueMergingTwoSections,The method has 6 parameters. Parameters: tx' it' num' current' currentSectionId' result
Long Parameter List,Voron.Trees,Page,C:\repos\ayende_raven.voron\Voron\Trees\Page.cs,CreateNode,The method has 5 parameters. Parameters: index' key' flags' len' previousNodeVersion
Long Parameter List,Voron.Trees,PageSplitter,C:\repos\ayende_raven.voron\Voron\Trees\PageSplitter.cs,PageSplitter,The method has 10 parameters. Parameters: tx' tree' cmp' newKey' len' pageNumber' nodeType' nodeVersion' cursor' treeState
Long Parameter List,Voron.Trees,PageSplitter,C:\repos\ayende_raven.voron\Voron\Trees\PageSplitter.cs,AdjustSplitPosition,The method has 6 parameters. Parameters: key' len' page' currentIndex' splitIndex' newPosition
Long Parameter List,Voron.Trees,Tree,C:\repos\ayende_raven.voron\Voron\Trees\Tree.cs,DirectAdd,The method has 5 parameters. Parameters: tx' key' len' nodeType' version
Long Parameter List,Voron.Trees,Tree,C:\repos\ayende_raven.voron\Voron\Trees\Tree.cs,AddToRecentlyFoundPages,The method has 5 parameters. Parameters: tx' c' p' leftmostPage' rightmostPage
Long Parameter List,Voron.Trees,Tree,C:\repos\ayende_raven.voron\Voron\Trees\Tree.cs,TryOverwriteDataOrMultiValuePageRefNode,The method has 6 parameters. Parameters: updatedNode' key' len' requestedNodeType' version' pos
Long Parameter List,Voron.Trees,Tree,C:\repos\ayende_raven.voron\Voron\Trees\Tree.cs,TryOverwriteOverflowPages,The method has 7 parameters. Parameters: tx' treeState' updatedNode' key' len' version' pos
Long Identifier,Voron.Impl.Extensions,MiscExtensions,C:\repos\ayende_raven.voron\Voron\Impl\Extensions\MiscExtensions.cs,GetTransactionToPageTranslation,The length of the parameter tempTransactionPageTranslaction is 31.
Long Identifier,Voron.Impl.Journal,JournalReader,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransaction,The length of the parameter tempTransactionPageTranslaction is 31.
Long Identifier,Voron.Impl.Journal,JournalApplicator,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,GetPagesFromJournals,The length of the parameter previousJournalMaxTransactionId is 31.
Long Identifier,Voron.Impl.Journal,JournalApplicator,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,GetPagesFromJournals,The length of the parameter currentJournalMaxTransactionId is 30.
Long Identifier,Voron.Impl.Journal,JournalApplicator,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,GetAndValidateOldestTransactionId,The length of the parameter currentJournalMaxTransactionId is 30.
Long Identifier,Voron.Impl.Journal,JournalApplicator,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,GetAndValidateOldestTransactionId,The length of the parameter previousJournalMaxTransactionId is 31.
Long Identifier,Voron.Impl.Journal,JournalApplicator,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,,The length of the parameter DelayedDataFileSynchronizationBytesLimit is 40.
Long Identifier,Voron.Impl.Journal,JournalApplicator,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,,The length of the parameter DelayedDataFileSynchronizationTimeLimit is 39.
Long Identifier,Voron.Impl.Paging,Win32PageFileBackedMemoryMappedPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PageFileBackedMemoryMappedPager.cs,AllocateMorePagesAndRemapContinuously,The length of the parameter allocationInfoAfterReallocation is 31.
Long Identifier,Voron.Util,EndOfDiskSpaceEvent,C:\repos\ayende_raven.voron\Voron\Util\EndOfDiskSpaceEvent.cs,,The length of the parameter _availableSpaceWhenEventOccurred is 32.
Long Identifier,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,,The length of the parameter NOTCOMPRESSIBLE_DETECTIONLEVEL is 30.
Long Identifier,Voron,StorageEnvironment,C:\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,FlushWritesToDataFileAsync,The length of the parameter sizeOfUnflushedTransactionsInJournalFile is 40.
Long Identifier,Voron,StorageEnvironment,C:\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,,The length of the parameter _sizeOfUnflushedTransactionsInJournalFile is 41.
Long Statement,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,DumpHumanReadable,The length of the statement  "						writer.WriteLine("Page #{0}' NumberOfEntries = {1}' Flags = {2} (Leaf)' Used: {3} : {4}"' currentPage.PageNumber'currentPage.NumberOfEntries'currentPage.Flags' currentPage.SizeUsed' currentPage.CalcSizeUsed()); " is 210.
Long Statement,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,DumpHumanReadable,The length of the statement  "							writer.WriteLine("Node #{0}' Flags = {1}' {4} = {2}' Key = {3}' Entry Size: {5}"' nodeIndex' node->Flags' node->DataSize' MaxString(key.ToString()' 25)' node->Flags == NodeFlags.Data ? "Size" : "Page"' " is 201.
Long Statement,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,DumpHumanReadable,The length of the statement  "						writer.WriteLine("Page #{0}' NumberOfEntries = {1}' Flags = {2} (Branch)' Used: {3} : {4}"' currentPage.PageNumber' currentPage.NumberOfEntries' currentPage.Flags' currentPage.SizeUsed' currentPage.SizeUsed); " is 208.
Long Statement,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,DumpHumanReadable,The length of the statement  "							writer.WriteLine("Node #{2}' {0}  / to page #{1}' Entry Size: {3}"' GetBranchNodeString(nodeIndex' key' currentPage' node)' node->PageNumber' nodeIndex' " is 152.
Long Statement,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,Dump,The length of the statement  "                            references.AppendFormat("	p_{0}_refs:{3} -> p_{1} [label=\"{2}\"];"' p.PageNumber' child.PageNumber' GetBranchNodeString(i' key' p' node)' i).AppendLine(); " is 155.
Long Statement,Voron.Impl.Backup,IncrementalBackup,C:\repos\ayende_raven.voron\Voron\Impl\Backup\IncrementalBackup.cs,ToFile,The length of the statement  "                            var journalFile = env.Journal.Files.FirstOrDefault(x => x.Number == journalNum); // first check journal files currently being in use " is 132.
Long Statement,Voron.Impl.Backup,IncrementalBackup,C:\repos\ayende_raven.voron\Voron\Impl\Backup\IncrementalBackup.cs,Restore,The length of the statement  "                            var recoveryPager = new Win32MemoryMapPager(Path.Combine(tempDir' StorageEnvironmentOptions.JournalRecoveryName(journalNumber))); " is 129.
Long Statement,Voron.Impl,PageFromScratchBuffer,C:\repos\ayende_raven.voron\Voron\Impl\ScratchBufferPool.cs,Equals,The length of the statement  "            return PositionInScratchBuffer == other.PositionInScratchBuffer && Size == other.Size && NumberOfPages == other.NumberOfPages; " is 126.
Long Statement,Voron.Impl,WriteBatch,C:\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,TryGetValue,The length of the statement  "					//since in multi-tree there are many operations for single tree key' then fetching operation type and value is meaningless " is 122.
Long Statement,Voron.Impl,WriteBatch,C:\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,Add,The length of the statement  "			//TODO : check up if adding empty values make sense in Voron --> in order to be consistent with existing behavior of Esent' this should be allowed " is 146.
Long Statement,Voron.Impl,Transaction,C:\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,GetReadOnlyPage,The length of the statement  "            Debug.Assert(p != null && p.PageNumber == pageNumber' string.Format("Requested ReadOnly page #{0}. Got #{1} from {2}"' pageNumber' p.PageNumber' p.Source)); " is 156.
Long Statement,Voron.Impl,Transaction,C:\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,AllocatePage,The length of the statement  "							"Currently configured storage quota is allowing to allocate the following maximum page number {1}' while the requested page number is {2}. " + " is 142.
Long Statement,Voron.Impl.Journal,ShippedTransactionsReader,C:\repos\ayende_raven.voron\Voron\Impl\Journal\ShippedTransactionsReader.cs,ReadFromShippedTransaction,The length of the statement  "			var compressedPages = (transaction.Header.CompressedSize / AbstractPager.PageSize) + (transaction.Header.CompressedSize % AbstractPager.PageSize == 0 ? 0 : 1); " is 159.
Long Statement,Voron.Impl.Journal,ShippedTransactionsReader,C:\repos\ayende_raven.voron\Voron\Impl\Journal\ShippedTransactionsReader.cs,ReadFromShippedTransaction,The length of the statement  "					LZ4.Decode64(compressedDataBufferPtr' transaction.Header.CompressedSize' _pager.AcquirePagePointer(currentPage)' transaction.Header.UncompressedSize' true); " is 156.
Long Statement,Voron.Impl.Journal,PagePosition,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalFile.cs,Equals,The length of the statement  "                return ScratchPos == other.ScratchPos && JournalPos == other.JournalPos && TransactionId == other.TransactionId && JournalNumber == other.JournalNumber; " is 152.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionForShipping,The length of the statement  "			var compressedPageCount = (current->CompressedSize / AbstractPager.PageSize) + (current->CompressedSize % AbstractPager.PageSize == 0 ? 0 : 1); " is 143.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionForShipping,The length of the statement  "				NativeMethods.memcpy(compressedDataPtr' _pager.AcquirePagePointer(_readingPage)' compressedPageCount * AbstractPager.PageSize); " is 127.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionForShipping,The length of the statement  "				CompressedData = new MemoryStream(compressedPagesRaw)' //no need to compress the pages --> after being written to Journal they are already compressed " is 149.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransaction,The length of the statement  "			var compressedPages = (current->CompressedSize / AbstractPager.PageSize) + (current->CompressedSize % AbstractPager.PageSize == 0 ? 0 : 1); " is 139.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransaction,The length of the statement  "				LZ4.Decode64(_pager.AcquirePagePointer(_readingPage)' current->CompressedSize' dataPage' current->UncompressedSize' true); " is 122.
Long Statement,Voron.Impl.Journal,JournalReader,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,TryReadAndValidateHeader,The length of the statement  "				// if the header marker is zero' we are probably in the area at the end of the log file' and have no additional log records " is 123.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,RecoverDatabase,The length of the statement  "				using (var recoveryPager = _env.Options.CreateScratchPager(StorageEnvironmentOptions.JournalRecoveryName(journalNumber))) " is 121.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,RecoverDatabase,The length of the statement  "						var jrnlWriter = _env.Options.CreateJournalWriter(journalNumber' pager.NumberOfAllocatedPages * AbstractPager.PageSize); " is 120.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,CompressPages,The length of the statement  "			var compressedPages = (sizeAfterCompression / AbstractPager.PageSize) + (sizeAfterCompression % AbstractPager.PageSize == 0 ? 0 : 1); " is 133.
Long Statement,Voron.Impl.Journal,JournalShipper,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ReadJournalForShippings,The length of the statement  "					if (_shippingSemaphore.TryEnterReadLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false) " is 124.
Long Statement,Voron.Impl.Journal,JournalShipper,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ReadJournalForShippings,The length of the statement  "						var journalReader = new JournalReader(_waj._env.Options.OpenJournalPager(journalNumber)' null' lastTransactionId' null); " is 120.
Long Statement,Voron.Impl.Journal,JournalApplicator,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The length of the statement  "					if (_flushingSemaphore.TryEnterWriteLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false) " is 125.
Long Statement,Voron.Impl.Journal,JournalApplicator,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,UpdateFileHeaderAfterDataFileSync,The length of the statement  "					var compressedPages = (readTxHeader->CompressedSize / AbstractPager.PageSize) + (readTxHeader->CompressedSize % AbstractPager.PageSize == 0 ? 0 : 1); " is 149.
Long Statement,Voron.Impl.Paging,Win32PageFileBackedMemoryMappedPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PageFileBackedMemoryMappedPager.cs,AllocateMorePages,The length of the statement  "		                "Unable to allocate more pages - unsucsessfully tried to allocate continuous block of virtual memory with size = {0:##'###;;0} bytes"' " is 134.
Long Statement,Voron.Impl.Paging,Win32PageFileBackedMemoryMappedPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PageFileBackedMemoryMappedPager.cs,AllocateMorePagesAndRemapContinuously,The length of the statement  "					var newAlloctedBaseAddress = MemoryMapNativeMethods.MapViewOfFileEx(allocationInfo.MappedFile.SafeMemoryMappedFileHandle.DangerousGetHandle()' " is 142.
Long Statement,Voron.Impl.Paging,Win32PageFileBackedMemoryMappedPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PageFileBackedMemoryMappedPager.cs,AllocateMorePagesAndRemapContinuously,The length of the statement  "		            "Something bad has happened' after {0} tries' could not find any spot in virtual memory to remap continuous virtual memory for {1:##'###;;0} bytes"' " is 148.
Long Statement,Voron.Impl.Paging,Win32PageFileBackedMemoryMappedPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PageFileBackedMemoryMappedPager.cs,CreateInitialPagerState,The length of the statement  "				Accessor = null' //not available since MapViewOfFileEx is used (instead of MapViewOfFile - which is used in managed wrapper) " is 124.
Long Statement,Voron.Impl.Paging,Win32MemoryMapPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32MemoryMapPager.cs,AllocateMorePages,The length of the statement  "						"Unable to allocate more pages - unsucsessfully tried to allocate continuous block of virtual memory with size = {0:##'###;;0} bytes"' " is 134.
Long Statement,Voron.Impl.Paging,Win32MemoryMapPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32MemoryMapPager.cs,TryAllocateMoreContinuousPages,The length of the statement  "			var allocationInfo = RemapViewOfFileAtAddress(allocationSize' (ulong)_totalAllocationSize' PagerState.MapBase + _totalAllocationSize); " is 134.
Long Statement,Voron.Impl.Paging,Win32MemoryMapPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32MemoryMapPager.cs,CreatePagerState,The length of the statement  "				Accessor = null' //not available since MapViewOfFileEx is used (instead of MapViewOfFile - which is used in managed wrapper) " is 124.
Long Statement,Voron.Impl.Paging,Win32PureMemoryPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,AllocatePages,The length of the statement  "                var extResult = NativeMethods.VirtualAlloc(_baseAddress + _reservedSize' new UIntPtr(_reservedSize)' NativeMethods.AllocationType.RESERVE' NativeMethods.MemoryProtection.NOACCESS); " is 180.
Long Statement,Voron.Impl.Paging,Win32PureMemoryPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,AllocatePages,The length of the statement  "			var result = NativeMethods.VirtualAlloc(lpAddress' new UIntPtr(dwSize)' NativeMethods.AllocationType.COMMIT' NativeMethods.MemoryProtection.READWRITE); " is 151.
Long Statement,Voron.Impl.Paging,Win32PureMemoryPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Dispose,The length of the statement  "                NativeMethods.VirtualFree(_baseAddress +(i * _reservedSize)' new UIntPtr(_reservedSize)' NativeMethods.FreeType.MEM_RELEASE); " is 125.
Long Statement,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The length of the statement  "				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0) " is 121.
Long Statement,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The length of the statement  "						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals) " is 217.
Long Statement,Voron,DirectoryStorageEnvironmentOptions,C:\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,CreateJournalWriter,The length of the statement  "				var result = _journals.GetOrAdd(name' _ => new Lazy<IJournalWriter>(() => new Win32FileJournalWriter(path' journalSize))); " is 122.
Long Statement,Voron,StorageEnvironment,C:\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,LoadExistingDatabase,The length of the statement  "                var message = _journal.Files.Count == 0 ? "Unrecoverable database" : "Database recovered partially. Some data was lost."; " is 121.
Long Statement,Voron,StorageEnvironment,C:\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,Stats,The length of the statement  "			var numberOfAllocatedPages = Math.Max(_dataPager.NumberOfAllocatedPages' State.NextPageNumber - 1); // async apply to data file task " is 132.
Long Statement,Voron,StorageEnvironment,C:\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,FlushWritesToDataFileAsync,The length of the statement  "					        // we didn't have a write in the idle timeout (default: 5 seconds)' this is probably a good time to try and do a proper flush " is 125.
Long Statement,Voron.Impl.FileHeaders,HeaderAccessor,C:\repos\ayende_raven.voron\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,The length of the statement  "				throw new InvalidDataException("This is a db file for version " + f1->Version + "' which is not compatible with the current version " + Constants.CurrentVersion); " is 162.
Long Statement,Voron.Trees,Page,C:\repos\ayende_raven.voron\Voron\Trees\Page.cs,CopyNodeDataToEndOfPage,The length of the statement  "	        var nodeVersion = other->Version; // every time new node is allocated the version is increased' but in this case we do not want to increase it " is 142.
Long Statement,Voron.Trees,Tree,C:\repos\ayende_raven.voron\Voron\Trees\Tree.cs,CheckConcurrency,The length of the statement  "				throw new ConcurrencyException(string.Format("Cannot {0} '{1}'. Version mismatch. Expected: {2}. Actual: {3}."' actionType.ToString().ToLowerInvariant()' key' expectedVersion.Value' nodeVersion)); " is 196.
Long Statement,Voron.Trees,Tree,C:\repos\ayende_raven.voron\Voron\Trees\Tree.cs,TryOverwriteOverflowPages,The length of the statement  "				tx.Id <= tx.Environment.OldestTransaction) // ensure MVCC - do not overwrite if there is some older active transaction that might read those overflows " is 150.
Long Statement,Voron.Trees,TreeRebalancer,C:\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,MoveLeafNode,The length of the statement  "            byte* val = @from.Base + @from.KeysOffsets[@from.LastSearchPosition] + Constants.NodeHeaderSize + originalFromKeyStart.Size; " is 124.
Long Statement,Voron.Trees,TreeRebalancer,C:\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,MoveLeafNode,The length of the statement  "			var nodeVersion = fromNode->Version; // every time new node is allocated the version is increased' but in this case we do not want to increase it " is 145.
Virtual Method Call from Constructor,Voron.Impl,ScratchBufferPool,C:\repos\ayende_raven.voron\Voron\Impl\ScratchBufferPool.cs,ScratchBufferPool,The constructor "ScratchBufferPool" calls a virtual method "CreateScratchPager".
Virtual Method Call from Constructor,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,WriteAheadJournal,The constructor "WriteAheadJournal" calls a virtual method "CreateScratchPager".
Empty Catch Block,Voron.Debugging,DebugJournal,C:\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,Flush,The method has an empty catch block.
Empty Catch Block,Voron.Debugging,DebugJournal,C:\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Voron.Impl,TransactionMergingWriter,C:\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Voron,StorageEnvironment,C:\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,FlushWritesToDataFileAsync,The method has an empty catch block.
Magic Number,Voron.Debugging,ActivityEntry,C:\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: if (columnArray.Count != 4)                      throw new ArgumentException("invalid csv data - check that you do not have commas in data");
Magic Number,Voron.Debugging,ActivityEntry,C:\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: try                  {                      if (columnArray[0] == DebugActionType.CreateTree.ToString())                      {                          var activityEntry = new ActivityEntry(                              GenericUtil.ParseEnum<DebugActionType>(columnArray[0])'                              Slice.Empty'                              columnArray[1]'                              null);                          return activityEntry;                      }                        if (columnArray[0] == DebugActionType.Delete.ToString())                      {                          var activityEntry = new ActivityEntry(                              GenericUtil.ParseEnum<DebugActionType>(columnArray[0])'                              columnArray[2]'                              columnArray[1]'                              null);                            return activityEntry;                      }                        var random = new Random();                        var type = GenericUtil.ParseEnum<DebugActionType>(columnArray[0]);                      object value;                      switch (type)                      {                          case DebugActionType.MultiAdd:                          case DebugActionType.MultiDelete:                                 value = new Slice(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                          default:                              if (recordOnlyValueLength)                              {                                  var length = long.Parse(columnArray[3]);                                  var bytes = new byte[length];                                  random.NextBytes(bytes);                                    value = new MemoryStream(bytes);                              }                              else                                  value = new MemoryStream(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                      }                        var entry = new ActivityEntry(type'                          columnArray[2]'                          columnArray[1]'                          value);                        return entry;                  }                  catch (Exception e)                  {                      throw new ArgumentException("Unable to parse the argument"' e);                  }
Magic Number,Voron.Debugging,ActivityEntry,C:\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: try                  {                      if (columnArray[0] == DebugActionType.CreateTree.ToString())                      {                          var activityEntry = new ActivityEntry(                              GenericUtil.ParseEnum<DebugActionType>(columnArray[0])'                              Slice.Empty'                              columnArray[1]'                              null);                          return activityEntry;                      }                        if (columnArray[0] == DebugActionType.Delete.ToString())                      {                          var activityEntry = new ActivityEntry(                              GenericUtil.ParseEnum<DebugActionType>(columnArray[0])'                              columnArray[2]'                              columnArray[1]'                              null);                            return activityEntry;                      }                        var random = new Random();                        var type = GenericUtil.ParseEnum<DebugActionType>(columnArray[0]);                      object value;                      switch (type)                      {                          case DebugActionType.MultiAdd:                          case DebugActionType.MultiDelete:                                 value = new Slice(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                          default:                              if (recordOnlyValueLength)                              {                                  var length = long.Parse(columnArray[3]);                                  var bytes = new byte[length];                                  random.NextBytes(bytes);                                    value = new MemoryStream(bytes);                              }                              else                                  value = new MemoryStream(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                      }                        var entry = new ActivityEntry(type'                          columnArray[2]'                          columnArray[1]'                          value);                        return entry;                  }                  catch (Exception e)                  {                      throw new ArgumentException("Unable to parse the argument"' e);                  }
Magic Number,Voron.Debugging,ActivityEntry,C:\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: try                  {                      if (columnArray[0] == DebugActionType.CreateTree.ToString())                      {                          var activityEntry = new ActivityEntry(                              GenericUtil.ParseEnum<DebugActionType>(columnArray[0])'                              Slice.Empty'                              columnArray[1]'                              null);                          return activityEntry;                      }                        if (columnArray[0] == DebugActionType.Delete.ToString())                      {                          var activityEntry = new ActivityEntry(                              GenericUtil.ParseEnum<DebugActionType>(columnArray[0])'                              columnArray[2]'                              columnArray[1]'                              null);                            return activityEntry;                      }                        var random = new Random();                        var type = GenericUtil.ParseEnum<DebugActionType>(columnArray[0]);                      object value;                      switch (type)                      {                          case DebugActionType.MultiAdd:                          case DebugActionType.MultiDelete:                                 value = new Slice(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                          default:                              if (recordOnlyValueLength)                              {                                  var length = long.Parse(columnArray[3]);                                  var bytes = new byte[length];                                  random.NextBytes(bytes);                                    value = new MemoryStream(bytes);                              }                              else                                  value = new MemoryStream(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                      }                        var entry = new ActivityEntry(type'                          columnArray[2]'                          columnArray[1]'                          value);                        return entry;                  }                  catch (Exception e)                  {                      throw new ArgumentException("Unable to parse the argument"' e);                  }
Magic Number,Voron.Debugging,ActivityEntry,C:\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: try                  {                      if (columnArray[0] == DebugActionType.CreateTree.ToString())                      {                          var activityEntry = new ActivityEntry(                              GenericUtil.ParseEnum<DebugActionType>(columnArray[0])'                              Slice.Empty'                              columnArray[1]'                              null);                          return activityEntry;                      }                        if (columnArray[0] == DebugActionType.Delete.ToString())                      {                          var activityEntry = new ActivityEntry(                              GenericUtil.ParseEnum<DebugActionType>(columnArray[0])'                              columnArray[2]'                              columnArray[1]'                              null);                            return activityEntry;                      }                        var random = new Random();                        var type = GenericUtil.ParseEnum<DebugActionType>(columnArray[0]);                      object value;                      switch (type)                      {                          case DebugActionType.MultiAdd:                          case DebugActionType.MultiDelete:                                 value = new Slice(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                          default:                              if (recordOnlyValueLength)                              {                                  var length = long.Parse(columnArray[3]);                                  var bytes = new byte[length];                                  random.NextBytes(bytes);                                    value = new MemoryStream(bytes);                              }                              else                                  value = new MemoryStream(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                      }                        var entry = new ActivityEntry(type'                          columnArray[2]'                          columnArray[1]'                          value);                        return entry;                  }                  catch (Exception e)                  {                      throw new ArgumentException("Unable to parse the argument"' e);                  }
Magic Number,Voron.Debugging,ActivityEntry,C:\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: try                  {                      if (columnArray[0] == DebugActionType.CreateTree.ToString())                      {                          var activityEntry = new ActivityEntry(                              GenericUtil.ParseEnum<DebugActionType>(columnArray[0])'                              Slice.Empty'                              columnArray[1]'                              null);                          return activityEntry;                      }                        if (columnArray[0] == DebugActionType.Delete.ToString())                      {                          var activityEntry = new ActivityEntry(                              GenericUtil.ParseEnum<DebugActionType>(columnArray[0])'                              columnArray[2]'                              columnArray[1]'                              null);                            return activityEntry;                      }                        var random = new Random();                        var type = GenericUtil.ParseEnum<DebugActionType>(columnArray[0]);                      object value;                      switch (type)                      {                          case DebugActionType.MultiAdd:                          case DebugActionType.MultiDelete:                                 value = new Slice(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                          default:                              if (recordOnlyValueLength)                              {                                  var length = long.Parse(columnArray[3]);                                  var bytes = new byte[length];                                  random.NextBytes(bytes);                                    value = new MemoryStream(bytes);                              }                              else                                  value = new MemoryStream(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                      }                        var entry = new ActivityEntry(type'                          columnArray[2]'                          columnArray[1]'                          value);                        return entry;                  }                  catch (Exception e)                  {                      throw new ArgumentException("Unable to parse the argument"' e);                  }
Magic Number,Voron.Debugging,DebugStuff,C:\repos\ayende_raven.voron\Voron\Debugging\DebugStuff.cs,RenderAndShow,The following statement contains a magic number: if ((dateTime - _lastGenerated).TotalSeconds < 2.5)  			{  				return;  			}
Magic Number,Voron.Debugging,DebugStuff,C:\repos\ayende_raven.voron\Voron\Debugging\DebugStuff.cs,RenderAndShow,The following statement contains a magic number: Thread.Sleep(500);
Magic Number,Voron.Debugging,DebugStuff,C:\repos\ayende_raven.voron\Voron\Debugging\DebugStuff.cs,FindGraphviz,The following statement contains a magic number: for (var i = 0; i < 100; i++)              {                  var p = path + i.ToString("00");                    if (Directory.Exists(p))                      return p;              }
Magic Number,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,DumpHumanReadable,The following statement contains a magic number: using (var writer = File.CreateText(path))  		    {                  var stack = new Stack<Page>();                  stack.Push(start);  				writer.WriteLine("Root page #{0}"'start.PageNumber);  			    while (stack.Count > 0)  			    {  					var currentPage = stack.Pop();  				    if (currentPage.IsLeaf)  				    {						  						writer.WriteLine();  						writer.WriteLine("Page #{0}' NumberOfEntries = {1}' Flags = {2} (Leaf)' Used: {3} : {4}"' currentPage.PageNumber'currentPage.NumberOfEntries'currentPage.Flags' currentPage.SizeUsed' currentPage.CalcSizeUsed());  						if(currentPage.NumberOfEntries <= 0)  							writer.WriteLine("Empty page (tree corrupted?)");  					      						var key = new Slice(SliceOptions.Key);  					    for (int nodeIndex = 0; nodeIndex < currentPage.NumberOfEntries;nodeIndex++)  					    {  						    var node = currentPage.GetNode(nodeIndex);  							key.Set(node);  							writer.WriteLine("Node #{0}' Flags = {1}' {4} = {2}' Key = {3}' Entry Size: {5}"' nodeIndex' node->Flags' node->DataSize' MaxString(key.ToString()' 25)' node->Flags == NodeFlags.Data ? "Size" : "Page"'                                  SizeOf.NodeEntry(node));  					    }  						writer.WriteLine();  				    }  				    else if(currentPage.IsBranch)   				    {  						writer.WriteLine();  						writer.WriteLine("Page #{0}' NumberOfEntries = {1}' Flags = {2} (Branch)' Used: {3} : {4}"' currentPage.PageNumber' currentPage.NumberOfEntries' currentPage.Flags' currentPage.SizeUsed' currentPage.SizeUsed);    						var key = new Slice(SliceOptions.Key);  						for (int nodeIndex = 0; nodeIndex < currentPage.NumberOfEntries; nodeIndex++)  						{  							var node = currentPage.GetNode(nodeIndex);  							writer.WriteLine("Node #{2}' {0}  / to page #{1}' Entry Size: {3}"' GetBranchNodeString(nodeIndex' key' currentPage' node)' node->PageNumber' nodeIndex'                                  SizeOf.NodeEntry(node));  						}    						for (int nodeIndex = 0; nodeIndex < currentPage.NumberOfEntries; nodeIndex++)  						{  							var node = currentPage.GetNode(nodeIndex);  							if (node->PageNumber < 0 || node->PageNumber > tx.State.NextPageNumber)  							{  								writer.Write("Found invalid reference to page #{0}"' currentPage.PageNumber);  								stack.Clear();  								break;  							}    							var child = tx.GetReadOnlyPage(node->PageNumber);  							stack.Push(child);  						}  						  						writer.WriteLine();  					}  			    }  		    }
Magic Number,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,Dump,The following statement contains a magic number: using (var writer = File.CreateText(path))              {                  writer.WriteLine(@"  digraph structs {      node [shape=Mrecord]      rankdir=LR;  	bgcolor=transparent;  ");                    var stack = new Stack<Page>();                  stack.Push(start);                  var references = new StringBuilder();                  while (stack.Count > 0)                  {                      var p = stack.Pop();                        writer.WriteLine(@"  	subgraph cluster_p_{0} {{   		label=""Page #{0}"";  		color={3};  	p_{0} [label=""Page: {0}|{1}|Entries: {2:#'#} | {4:p} : {5:p} utilization""];    "' p.PageNumber' p.Flags' p.NumberOfEntries' p.IsLeaf ? "black" : "blue"'  	Math.Round(((AbstractPager.PageSize - p.SizeLeft) / (double)AbstractPager.PageSize)' 2)'      Math.Round(((AbstractPager.PageSize - p.CalcSizeLeft()) / (double)AbstractPager.PageSize)' 2));                      var key = new Slice(SliceOptions.Key);                      if (p.IsLeaf && showNodesEvery > 0)                      {                          writer.WriteLine("		p_{0}_nodes [label=\" Entries:"' p.PageNumber);                          for (int i = 0; i < p.NumberOfEntries; i += showNodesEvery)                          {                              if (i != 0 && showNodesEvery >= 5)                              {                                  writer.WriteLine(" ... {0:#'#} keys redacted ..."' showNodesEvery - 1);                              }                              var node = p.GetNode(i);                              key.Set(node);                              writer.WriteLine("{0} - {2} {1:#'#}"' MaxString(key.ToString()' 25)'                                  node->DataSize' node->Flags == NodeFlags.Data ? "Size" : "Page");                          }                          if (p.NumberOfEntries < showNodesEvery)                          {                              writer.WriteLine(" ... {0:#'#} keys redacted ..."' p.NumberOfEntries - 1);                          }                          writer.WriteLine("\"];");                      }                      else if (p.IsBranch)                      {                          writer.Write("		p_{0}_refs [label=\""' p.PageNumber);                          for (int i = 0; i < p.NumberOfEntries; i++)                          {                              var node = p.GetNode(i);                                writer.Write("{3}<{2}> {0}  / to page {1}"' GetBranchNodeString(i' key' p' node)' node->PageNumber'                                  i' i == 0 ? "" : "|");                          }                          writer.WriteLine("\"];");                          var prev = -1L;                          for (int i = 0; i < p.NumberOfEntries; i++)                          {                              var node = p.GetNode(i);                              if (node->PageNumber < 0 || node->PageNumber > tx.State.NextPageNumber)                              {                                  writer.Write("		p_{0}_refs [label=\"CORRUPTED\"; Color=RED];"' p.PageNumber);                                  stack.Clear();                                  break;                              }                              var child = tx.GetReadOnlyPage(node->PageNumber);                              stack.Push(child);                                references.AppendFormat("	p_{0}_refs:{3} -> p_{1} [label=\"{2}\"];"' p.PageNumber' child.PageNumber' GetBranchNodeString(i' key' p' node)' i).AppendLine();                              if (prev > -1)                                  references.AppendFormat("	p_{0} -> p_{1} [style=\"invis\"];"' child.PageNumber' prev);                                prev = child.PageNumber;                          }                      }                      writer.WriteLine("	}");                  }                  writer.WriteLine(references.ToString());                    writer.WriteLine("}");              }
Magic Number,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,Dump,The following statement contains a magic number: using (var writer = File.CreateText(path))              {                  writer.WriteLine(@"  digraph structs {      node [shape=Mrecord]      rankdir=LR;  	bgcolor=transparent;  ");                    var stack = new Stack<Page>();                  stack.Push(start);                  var references = new StringBuilder();                  while (stack.Count > 0)                  {                      var p = stack.Pop();                        writer.WriteLine(@"  	subgraph cluster_p_{0} {{   		label=""Page #{0}"";  		color={3};  	p_{0} [label=""Page: {0}|{1}|Entries: {2:#'#} | {4:p} : {5:p} utilization""];    "' p.PageNumber' p.Flags' p.NumberOfEntries' p.IsLeaf ? "black" : "blue"'  	Math.Round(((AbstractPager.PageSize - p.SizeLeft) / (double)AbstractPager.PageSize)' 2)'      Math.Round(((AbstractPager.PageSize - p.CalcSizeLeft()) / (double)AbstractPager.PageSize)' 2));                      var key = new Slice(SliceOptions.Key);                      if (p.IsLeaf && showNodesEvery > 0)                      {                          writer.WriteLine("		p_{0}_nodes [label=\" Entries:"' p.PageNumber);                          for (int i = 0; i < p.NumberOfEntries; i += showNodesEvery)                          {                              if (i != 0 && showNodesEvery >= 5)                              {                                  writer.WriteLine(" ... {0:#'#} keys redacted ..."' showNodesEvery - 1);                              }                              var node = p.GetNode(i);                              key.Set(node);                              writer.WriteLine("{0} - {2} {1:#'#}"' MaxString(key.ToString()' 25)'                                  node->DataSize' node->Flags == NodeFlags.Data ? "Size" : "Page");                          }                          if (p.NumberOfEntries < showNodesEvery)                          {                              writer.WriteLine(" ... {0:#'#} keys redacted ..."' p.NumberOfEntries - 1);                          }                          writer.WriteLine("\"];");                      }                      else if (p.IsBranch)                      {                          writer.Write("		p_{0}_refs [label=\""' p.PageNumber);                          for (int i = 0; i < p.NumberOfEntries; i++)                          {                              var node = p.GetNode(i);                                writer.Write("{3}<{2}> {0}  / to page {1}"' GetBranchNodeString(i' key' p' node)' node->PageNumber'                                  i' i == 0 ? "" : "|");                          }                          writer.WriteLine("\"];");                          var prev = -1L;                          for (int i = 0; i < p.NumberOfEntries; i++)                          {                              var node = p.GetNode(i);                              if (node->PageNumber < 0 || node->PageNumber > tx.State.NextPageNumber)                              {                                  writer.Write("		p_{0}_refs [label=\"CORRUPTED\"; Color=RED];"' p.PageNumber);                                  stack.Clear();                                  break;                              }                              var child = tx.GetReadOnlyPage(node->PageNumber);                              stack.Push(child);                                references.AppendFormat("	p_{0}_refs:{3} -> p_{1} [label=\"{2}\"];"' p.PageNumber' child.PageNumber' GetBranchNodeString(i' key' p' node)' i).AppendLine();                              if (prev > -1)                                  references.AppendFormat("	p_{0} -> p_{1} [style=\"invis\"];"' child.PageNumber' prev);                                prev = child.PageNumber;                          }                      }                      writer.WriteLine("	}");                  }                  writer.WriteLine(references.ToString());                    writer.WriteLine("}");              }
Magic Number,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,Dump,The following statement contains a magic number: using (var writer = File.CreateText(path))              {                  writer.WriteLine(@"  digraph structs {      node [shape=Mrecord]      rankdir=LR;  	bgcolor=transparent;  ");                    var stack = new Stack<Page>();                  stack.Push(start);                  var references = new StringBuilder();                  while (stack.Count > 0)                  {                      var p = stack.Pop();                        writer.WriteLine(@"  	subgraph cluster_p_{0} {{   		label=""Page #{0}"";  		color={3};  	p_{0} [label=""Page: {0}|{1}|Entries: {2:#'#} | {4:p} : {5:p} utilization""];    "' p.PageNumber' p.Flags' p.NumberOfEntries' p.IsLeaf ? "black" : "blue"'  	Math.Round(((AbstractPager.PageSize - p.SizeLeft) / (double)AbstractPager.PageSize)' 2)'      Math.Round(((AbstractPager.PageSize - p.CalcSizeLeft()) / (double)AbstractPager.PageSize)' 2));                      var key = new Slice(SliceOptions.Key);                      if (p.IsLeaf && showNodesEvery > 0)                      {                          writer.WriteLine("		p_{0}_nodes [label=\" Entries:"' p.PageNumber);                          for (int i = 0; i < p.NumberOfEntries; i += showNodesEvery)                          {                              if (i != 0 && showNodesEvery >= 5)                              {                                  writer.WriteLine(" ... {0:#'#} keys redacted ..."' showNodesEvery - 1);                              }                              var node = p.GetNode(i);                              key.Set(node);                              writer.WriteLine("{0} - {2} {1:#'#}"' MaxString(key.ToString()' 25)'                                  node->DataSize' node->Flags == NodeFlags.Data ? "Size" : "Page");                          }                          if (p.NumberOfEntries < showNodesEvery)                          {                              writer.WriteLine(" ... {0:#'#} keys redacted ..."' p.NumberOfEntries - 1);                          }                          writer.WriteLine("\"];");                      }                      else if (p.IsBranch)                      {                          writer.Write("		p_{0}_refs [label=\""' p.PageNumber);                          for (int i = 0; i < p.NumberOfEntries; i++)                          {                              var node = p.GetNode(i);                                writer.Write("{3}<{2}> {0}  / to page {1}"' GetBranchNodeString(i' key' p' node)' node->PageNumber'                                  i' i == 0 ? "" : "|");                          }                          writer.WriteLine("\"];");                          var prev = -1L;                          for (int i = 0; i < p.NumberOfEntries; i++)                          {                              var node = p.GetNode(i);                              if (node->PageNumber < 0 || node->PageNumber > tx.State.NextPageNumber)                              {                                  writer.Write("		p_{0}_refs [label=\"CORRUPTED\"; Color=RED];"' p.PageNumber);                                  stack.Clear();                                  break;                              }                              var child = tx.GetReadOnlyPage(node->PageNumber);                              stack.Push(child);                                references.AppendFormat("	p_{0}_refs:{3} -> p_{1} [label=\"{2}\"];"' p.PageNumber' child.PageNumber' GetBranchNodeString(i' key' p' node)' i).AppendLine();                              if (prev > -1)                                  references.AppendFormat("	p_{0} -> p_{1} [style=\"invis\"];"' child.PageNumber' prev);                                prev = child.PageNumber;                          }                      }                      writer.WriteLine("	}");                  }                  writer.WriteLine(references.ToString());                    writer.WriteLine("}");              }
Magic Number,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,Dump,The following statement contains a magic number: using (var writer = File.CreateText(path))              {                  writer.WriteLine(@"  digraph structs {      node [shape=Mrecord]      rankdir=LR;  	bgcolor=transparent;  ");                    var stack = new Stack<Page>();                  stack.Push(start);                  var references = new StringBuilder();                  while (stack.Count > 0)                  {                      var p = stack.Pop();                        writer.WriteLine(@"  	subgraph cluster_p_{0} {{   		label=""Page #{0}"";  		color={3};  	p_{0} [label=""Page: {0}|{1}|Entries: {2:#'#} | {4:p} : {5:p} utilization""];    "' p.PageNumber' p.Flags' p.NumberOfEntries' p.IsLeaf ? "black" : "blue"'  	Math.Round(((AbstractPager.PageSize - p.SizeLeft) / (double)AbstractPager.PageSize)' 2)'      Math.Round(((AbstractPager.PageSize - p.CalcSizeLeft()) / (double)AbstractPager.PageSize)' 2));                      var key = new Slice(SliceOptions.Key);                      if (p.IsLeaf && showNodesEvery > 0)                      {                          writer.WriteLine("		p_{0}_nodes [label=\" Entries:"' p.PageNumber);                          for (int i = 0; i < p.NumberOfEntries; i += showNodesEvery)                          {                              if (i != 0 && showNodesEvery >= 5)                              {                                  writer.WriteLine(" ... {0:#'#} keys redacted ..."' showNodesEvery - 1);                              }                              var node = p.GetNode(i);                              key.Set(node);                              writer.WriteLine("{0} - {2} {1:#'#}"' MaxString(key.ToString()' 25)'                                  node->DataSize' node->Flags == NodeFlags.Data ? "Size" : "Page");                          }                          if (p.NumberOfEntries < showNodesEvery)                          {                              writer.WriteLine(" ... {0:#'#} keys redacted ..."' p.NumberOfEntries - 1);                          }                          writer.WriteLine("\"];");                      }                      else if (p.IsBranch)                      {                          writer.Write("		p_{0}_refs [label=\""' p.PageNumber);                          for (int i = 0; i < p.NumberOfEntries; i++)                          {                              var node = p.GetNode(i);                                writer.Write("{3}<{2}> {0}  / to page {1}"' GetBranchNodeString(i' key' p' node)' node->PageNumber'                                  i' i == 0 ? "" : "|");                          }                          writer.WriteLine("\"];");                          var prev = -1L;                          for (int i = 0; i < p.NumberOfEntries; i++)                          {                              var node = p.GetNode(i);                              if (node->PageNumber < 0 || node->PageNumber > tx.State.NextPageNumber)                              {                                  writer.Write("		p_{0}_refs [label=\"CORRUPTED\"; Color=RED];"' p.PageNumber);                                  stack.Clear();                                  break;                              }                              var child = tx.GetReadOnlyPage(node->PageNumber);                              stack.Push(child);                                references.AppendFormat("	p_{0}_refs:{3} -> p_{1} [label=\"{2}\"];"' p.PageNumber' child.PageNumber' GetBranchNodeString(i' key' p' node)' i).AppendLine();                              if (prev > -1)                                  references.AppendFormat("	p_{0} -> p_{1} [style=\"invis\"];"' child.PageNumber' prev);                                prev = child.PageNumber;                          }                      }                      writer.WriteLine("	}");                  }                  writer.WriteLine(references.ToString());                    writer.WriteLine("}");              }
Magic Number,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,MaxString,The following statement contains a magic number: return key.Substring(0' (size/2)) + "..." + key.Substring(key.Length - size/2' size/2);
Magic Number,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,MaxString,The following statement contains a magic number: return key.Substring(0' (size/2)) + "..." + key.Substring(key.Length - size/2' size/2);
Magic Number,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,MaxString,The following statement contains a magic number: return key.Substring(0' (size/2)) + "..." + key.Substring(key.Length - size/2' size/2);
Magic Number,Voron.Debugging,TreeDumper,C:\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,GetBranchNodeString,The following statement contains a magic number: return MaxString(keyStr' 25);
Magic Number,Voron.Impl.Backup,FullBackup,C:\repos\ayende_raven.voron\Voron\Impl\Backup\FullBackup.cs,ToFile,The following statement contains a magic number: var copier = new DataCopier(AbstractPager.PageSize * 16);
Magic Number,Voron.Impl.Backup,FullBackup,C:\repos\ayende_raven.voron\Voron\Impl\Backup\FullBackup.cs,ToFile,The following statement contains a magic number: try  			{  				using (var file = new FileStream(backupPath' FileMode.Create))  				using (var package = new ZipArchive(file' ZipArchiveMode.Create))  				{  					long allocatedPages;    					ImmutableAppendOnlyList<JournalFile> files; // thread safety copy  					long lastWrittenLogPage = -1;  					long lastWrittenLogFile = -1;  					using (var txw = env.NewTransaction(TransactionFlags.ReadWrite)) // so we can snapshot the headers safely  					{  						txr = env.NewTransaction(TransactionFlags.Read); // now have snapshot view  						allocatedPages = dataPager.NumberOfAllocatedPages;    						Debug.Assert(HeaderAccessor.HeaderFileNames.Length == 2);    						foreach (var headerFileName in HeaderAccessor.HeaderFileNames)  						{  							var header = stackalloc FileHeader[1];    							if (env.Options.ReadHeader(headerFileName' header))  							{  								var headerPart = package.CreateEntry(headerFileName' compression);  								Debug.Assert(headerPart != null);    								using (var headerStream = headerPart.Open())  								{  									copier.ToStream((byte*) header' sizeof (FileHeader)' headerStream);  								}  							}  						}    						// journal files snapshot  						files = env.Journal.Files;    						foreach (var journalFile in files)  						{  							journalFile.AddRef();  						}    						if (env.Journal.CurrentFile != null)  						{  							lastWrittenLogFile = env.Journal.CurrentFile.Number;  							lastWrittenLogPage = env.Journal.CurrentFile.WritePagePosition - 1;  						}    						// txw.Commit(); intentionally not committing  					}    					// data file backup  					var dataPart = package.CreateEntry(Constants.DatabaseFilename' compression);  					Debug.Assert(dataPart != null);    					if (allocatedPages > 0) //only true if dataPager is still empty at backup start  					{  						using (var dataStream = dataPart.Open())  						{  							// now can copy everything else  							var firstDataPage = dataPager.Read(0);    							copier.ToStream(firstDataPage.Base' AbstractPager.PageSize*allocatedPages' dataStream);  						}  					}    					try  					{  						foreach (var journalFile in files)  						{  							var journalPart = package.CreateEntry(StorageEnvironmentOptions.JournalName(journalFile.Number)' compression);    							Debug.Assert(journalPart != null);    							var pagesToCopy = journalFile.JournalWriter.NumberOfAllocatedPages;  							if (journalFile.Number == lastWrittenLogFile)  								pagesToCopy = lastWrittenLogPage + 1;    							using (var stream = journalPart.Open())  							{  								copier.ToStream(journalFile' 0' pagesToCopy' stream);  							}  						}  					}  					finally  					{  						foreach (var journalFile in files)  						{  							journalFile.Release();  						}  					}  				}  			}  			finally  			{  				if (txr != null)  					txr.Dispose();  			}
Magic Number,Voron.Impl.Backup,IncrementalBackup,C:\repos\ayende_raven.voron\Voron\Impl\Backup\IncrementalBackup.cs,ToFile,The following statement contains a magic number: var copier = new DataCopier(AbstractPager.PageSize * 16);
Magic Number,Voron.Impl,PagerState,C:\repos\ayende_raven.voron\Voron\Impl\PagerState.cs,AddRef,The following statement contains a magic number: while (AddedRefs.Count > 500)  			{  				StackTrace trace;  				AddedRefs.TryDequeue(out trace);  			}
Magic Number,Voron.Impl,PageFromScratchBuffer,C:\repos\ayende_raven.voron\Voron\Impl\ScratchBufferPool.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = PositionInScratchBuffer.GetHashCode();                  hashCode = (hashCode * 397) ^ Size.GetHashCode();                  hashCode = (hashCode * 397) ^ NumberOfPages;                  return hashCode;              }
Magic Number,Voron.Impl,PageFromScratchBuffer,C:\repos\ayende_raven.voron\Voron\Impl\ScratchBufferPool.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = PositionInScratchBuffer.GetHashCode();                  hashCode = (hashCode * 397) ^ Size.GetHashCode();                  hashCode = (hashCode * 397) ^ NumberOfPages;                  return hashCode;              }
Magic Number,Voron.Impl,TransactionMergingWriter,C:\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: long maxSize = 16 * 1024 * 1024;
Magic Number,Voron.Impl,TransactionMergingWriter,C:\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: long maxSize = 16 * 1024 * 1024;
Magic Number,Voron.Impl,TransactionMergingWriter,C:\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: long maxSize = 16 * 1024 * 1024;
Magic Number,Voron.Impl,TransactionMergingWriter,C:\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: if (mine.Size < 128 * 1024)                  maxSize = (1024 * 1024);
Magic Number,Voron.Impl,TransactionMergingWriter,C:\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: if (mine.Size < 128 * 1024)                  maxSize = (1024 * 1024);
Magic Number,Voron.Impl,TransactionMergingWriter,C:\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: if (mine.Size < 128 * 1024)                  maxSize = (1024 * 1024);
Magic Number,Voron.Impl,TransactionMergingWriter,C:\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: if (mine.Size < 128 * 1024)                  maxSize = (1024 * 1024);
Magic Number,Voron.Impl,TreeAndSliceComparer,C:\repos\ayende_raven.voron\Voron\Impl\TreeAndSliceComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Item1.GetHashCode() ^ 397 * obj.Item2.GetHashCode();
Magic Number,Voron.Impl,Transaction,C:\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,FreePage,The following statement contains a magic number: Debug.Assert(pageNumber >= 2);
Magic Number,Voron.Impl,Transaction,C:\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,AddRecentlyFoundPage,The following statement contains a magic number: if (_recentlyFoundPages.TryGetValue(tree' out pages) == false)  		        _recentlyFoundPages[tree] = pages = new RecentlyFoundPages(Flags == TransactionFlags.Read ? 8 : 2);
Magic Number,Voron.Impl,Transaction,C:\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,AddRecentlyFoundPage,The following statement contains a magic number: if (_recentlyFoundPages.TryGetValue(tree' out pages) == false)  		        _recentlyFoundPages[tree] = pages = new RecentlyFoundPages(Flags == TransactionFlags.Read ? 8 : 2);
Magic Number,Voron.Impl.Journal,PagePosition,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalFile.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int hashCode = ScratchPos.GetHashCode();                      hashCode = (hashCode * 397) ^ JournalPos.GetHashCode();                      hashCode = (hashCode * 397) ^ TransactionId.GetHashCode();                      hashCode = (hashCode * 397) ^ JournalNumber.GetHashCode();                      return hashCode;                  }
Magic Number,Voron.Impl.Journal,PagePosition,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalFile.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int hashCode = ScratchPos.GetHashCode();                      hashCode = (hashCode * 397) ^ JournalPos.GetHashCode();                      hashCode = (hashCode * 397) ^ TransactionId.GetHashCode();                      hashCode = (hashCode * 397) ^ JournalNumber.GetHashCode();                      return hashCode;                  }
Magic Number,Voron.Impl.Journal,PagePosition,C:\repos\ayende_raven.voron\Voron\Impl\Journal\JournalFile.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int hashCode = ScratchPos.GetHashCode();                      hashCode = (hashCode * 397) ^ JournalPos.GetHashCode();                      hashCode = (hashCode * 397) ^ TransactionId.GetHashCode();                      hashCode = (hashCode * 397) ^ JournalNumber.GetHashCode();                      return hashCode;                  }
Magic Number,Voron.Impl.Journal,Win32FileJournalWriter,C:\repos\ayende_raven.voron\Voron\Impl\Journal\Win32JournalWriter.cs,WriteGather,The following statement contains a magic number: _nativeOverlapped->OffsetHigh = (int) (position >> 32);
Magic Number,Voron.Impl.Journal,Win32FileJournalWriter,C:\repos\ayende_raven.voron\Voron\Impl\Journal\Win32JournalWriter.cs,WriteGather,The following statement contains a magic number: for (int i = 0; i < pages.Length; i++)  			{  				if(IntPtr.Size == 4)  					_segments[i].Alignment = (ulong) pages[i];  				else  					_segments[i].Buffer = pages[i];  			}
Magic Number,Voron.Impl.Journal,Win32FileJournalWriter,C:\repos\ayende_raven.voron\Voron\Impl\Journal\Win32JournalWriter.cs,WriteGather,The following statement contains a magic number: WriteFileGather(_handle' _segments' (uint) pages.Length*4096' IntPtr.Zero' _nativeOverlapped);
Magic Number,Voron.Impl.Journal,Win32FileJournalWriter,C:\repos\ayende_raven.voron\Voron\Impl\Journal\Win32JournalWriter.cs,Read,The following statement contains a magic number: var overlapped = new Overlapped((int) (position & 0xffffffff)' (int) (position >> 32)' IntPtr.Zero' null);
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,NextFile,The following statement contains a magic number: if ((now - _lastFile).TotalSeconds < 90)  			{  				_currentJournalFileSize = Math.Min(_env.Options.MaxLogFileSize' _currentJournalFileSize * 2);  			}
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,NextFile,The following statement contains a magic number: if ((now - _lastFile).TotalSeconds < 90)  			{  				_currentJournalFileSize = Math.Min(_env.Options.MaxLogFileSize' _currentJournalFileSize * 2);  			}
Magic Number,Voron.Impl.Journal,WriteAheadJournal,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,RecoverDatabase,The following statement contains a magic number: if (_files.Count > 0)  			{  				var lastFile = _files.Last();  				if (lastFile.AvailablePages >= 2)  					// it must have at least one page for the next transaction header and one page for data  					CurrentFile = lastFile;  			}
Magic Number,Voron.Impl.Journal,JournalShipper,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ReadJournalForShippings,The following statement contains a magic number: if (_shippingSemaphore.IsReadLockHeld == false)  				{  					if (_shippingSemaphore.TryEnterReadLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false)  						throw new TimeoutException("Could not acquire the read lock in 30 seconds");  					locked = true;  				}
Magic Number,Voron.Impl.Journal,JournalShipper,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ReadJournalForShippings,The following statement contains a magic number: if (_shippingSemaphore.IsReadLockHeld == false)  				{  					if (_shippingSemaphore.TryEnterReadLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false)  						throw new TimeoutException("Could not acquire the read lock in 30 seconds");  					locked = true;  				}
Magic Number,Voron.Impl.Journal,JournalApplicator,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The following statement contains a magic number: if (_flushingSemaphore.IsWriteLockHeld == false)  				{  					if (_flushingSemaphore.TryEnterWriteLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false)  						throw new TimeoutException("Could not acquire the write lock in 30 seconds");  					locked = true;  				}
Magic Number,Voron.Impl.Journal,JournalApplicator,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The following statement contains a magic number: if (_flushingSemaphore.IsWriteLockHeld == false)  				{  					if (_flushingSemaphore.TryEnterWriteLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false)  						throw new TimeoutException("Could not acquire the write lock in 30 seconds");  					locked = true;  				}
Magic Number,Voron.Impl.Journal,JournalApplicator,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,UpdateFileHeaderAfterDataFileSync,The following statement contains a magic number: var txHeaders = stackalloc TransactionHeader[2];
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,AbstractPager,The following statement contains a magic number: MaxNodeSize = 1024;
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,AbstractPager,The following statement contains a magic number: Debug.Assert((PageSize - Constants.PageHeaderSize) / Constants.MinKeysInPage >= 1024);
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,AbstractPager,The following statement contains a magic number: PageMinSpace = (int)(PageMaxSpace * 0.33);
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: if (timeSinceLastIncrease.TotalSeconds < 30)              {                  _increaseSize = Math.Min(_increaseSize * 2' current + current / 4);              }              else if (timeSinceLastIncrease.TotalMinutes > 2)              {                  _increaseSize = Math.Max(MinIncreaseSize' _increaseSize / 2);              }
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: if (timeSinceLastIncrease.TotalSeconds < 30)              {                  _increaseSize = Math.Min(_increaseSize * 2' current + current / 4);              }              else if (timeSinceLastIncrease.TotalMinutes > 2)              {                  _increaseSize = Math.Max(MinIncreaseSize' _increaseSize / 2);              }
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: if (timeSinceLastIncrease.TotalSeconds < 30)              {                  _increaseSize = Math.Min(_increaseSize * 2' current + current / 4);              }              else if (timeSinceLastIncrease.TotalMinutes > 2)              {                  _increaseSize = Math.Max(MinIncreaseSize' _increaseSize / 2);              }
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: if (timeSinceLastIncrease.TotalSeconds < 30)              {                  _increaseSize = Math.Min(_increaseSize * 2' current + current / 4);              }              else if (timeSinceLastIncrease.TotalMinutes > 2)              {                  _increaseSize = Math.Max(MinIncreaseSize' _increaseSize / 2);              }
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: if (timeSinceLastIncrease.TotalSeconds < 30)              {                  _increaseSize = Math.Min(_increaseSize * 2' current + current / 4);              }              else if (timeSinceLastIncrease.TotalMinutes > 2)              {                  _increaseSize = Math.Max(MinIncreaseSize' _increaseSize / 2);              }
Magic Number,Voron.Impl.Paging,AbstractPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: var actualIncrease = Math.Min(_increaseSize' current / 4);
Magic Number,Voron.Impl.Paging,FilePager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\FilePager.cs,WriteDirect,The following statement contains a magic number: var overlapped = new Overlapped()              {                  OffsetLow = (int)(position & 0xffffffff)'                  OffsetHigh = (int)(position >> 32)'              };
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,C:\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Mask,The following statement contains a magic number: return (int)(((crc >> 15) | (crc << 17)) + MaskDelta);
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Mask,The following statement contains a magic number: return (int)(((crc >> 15) | (crc << 17)) + MaskDelta);
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Unmask,The following statement contains a magic number: return ((rot >> 17) | (rot << 15));
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Unmask,The following statement contains a magic number: return ((rot >> 17) | (rot << 15));
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,Crc,C:\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: unchecked  			{  				fixed (uint* t0 = Table_0)  				{  					crcSeed ^= 0xFFFFFFFF;  					return (*(t0 + ((crcSeed & 0xff) ^ b)) ^ (crcSeed >> 8)) ^ 0xFFFFFFFF;  				}  			}
Magic Number,Voron.Util,ImmutableAppendOnlyList<T>,C:\repos\ayende_raven.voron\Voron\Util\ImmutableAppendOnlyList.cs,Append,The following statement contains a magic number: if (tail == _values.Length)  			{  				var newArray = GrowTo(Math.Max(8' (int)Utils.NearestPowerOfTwo(newCount)));  				newArray[_count] = item;  				return new ImmutableAppendOnlyList<T>(newArray' 0' newCount);  			}
Magic Number,Voron.Util,ImmutableAppendOnlyList<T>,C:\repos\ayende_raven.voron\Voron\Util\ImmutableAppendOnlyList.cs,AppendRange,The following statement contains a magic number: if (tail + nToAdd > _values.Length)  			{  				var newArray = GrowTo(_count + nToAdd * 2);  				copier(items' newArray' _count' nToAdd);  				return new ImmutableAppendOnlyList<T>(newArray' 0' newCount);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,MaximumOutputLength,The following statement contains a magic number: return inputLength + (inputLength / 255) + 16;
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,MaximumOutputLength,The following statement contains a magic number: return inputLength + (inputLength / 255) + 16;
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_base = src_p;  				var src_anchor = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;  				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int length;  				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (uint)(src_p - src_base);  					} while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)(src_ref)) != (*(uint*)(src_p))));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						var len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					_p = dst_p + (length);  					{  						do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);  					}  					dst_p = _p;    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch already verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					length = (int)(src_p - src_anchor);    					if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (length >= ML_MASK)  					{  						*dst_token += ML_MASK;  						length -= ML_MASK;  						for (; length > 509; length -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (length > 254)  						{  							length -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)length;  					}  					else  					{  						*dst_token += (byte)length;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (uint)(src_p - src_base);    					if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_anchor = src_p;  				var src_base = src_p;  				var src_end = src_p + src_len;  				var src_mflimit = src_end - MFLIMIT;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;    				var src_LASTLITERALS = src_end - LASTLITERALS;  				var src_LASTLITERALS_1 = src_LASTLITERALS - 1;    				var src_LASTLITERALS_3 = src_LASTLITERALS - 3;    				var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);  				var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);  				var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);    				int len' length;    				uint h' h_fwd;    				// Init  				if (src_len < MINLENGTH) goto _last_literals;    				// First Byte  				src_p++;  				h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);    				// Main Loop  				while (true)  				{  					var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					var src_p_fwd = src_p;  					byte* src_ref;  					byte* dst_token;    					// Find a match  					do  					{  						h = h_fwd;  						var step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = src_p_fwd;  						src_p_fwd = src_p + step;    						if (src_p_fwd > src_mflimit) goto _last_literals;    						h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);  					} while ((*(uint*)(src_ref)) != (*(uint*)(src_p)));    					// Catch up  					while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))  					{  						src_p--;  						src_ref--;  					}    					// Encode Literal length  					length = (int)(src_p - src_anchor);  					dst_token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    					if (length >= RUN_MASK)  					{  						len = length - RUN_MASK;  						*dst_token = (RUN_MASK << ML_BITS);  						if (len > 254)  						{  							do  							{  								*dst_p++ = 255;  								len -= 255;  							} while (len > 254);  							*dst_p++ = (byte)len;  							BlockCopy(src_anchor' dst_p' (length));  							dst_p += length;  							goto _next_match;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token = (byte)(length << ML_BITS);  					}    					// Copy Literals  					{  						_p = dst_p + (length);  						{  							do  							{  								*(ulong*)dst_p = *(ulong*)src_anchor;  								dst_p += 8;  								src_anchor += 8;  							} while (dst_p < _p);  						}  						dst_p = _p;  					}    				_next_match:    					// Encode Offset  					*(ushort*)dst_p = (ushort)(src_p - src_ref);  					dst_p += 2;    					// Start Counting  					src_p += MINMATCH;  					src_ref += MINMATCH; // MinMatch verified  					src_anchor = src_p;    					while (src_p < src_LASTLITERALS_STEPSIZE_1)  					{  						var diff = (*(long*)(src_ref)) ^ (*(long*)(src_p));  						if (diff == 0)  						{  							src_p += STEPSIZE_64;  							src_ref += STEPSIZE_64;  							continue;  						}  						src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];  						goto _endCount;  					}    					if ((src_p < src_LASTLITERALS_3) && ((*(uint*)(src_ref)) == (*(uint*)(src_p))))  					{  						src_p += 4;  						src_ref += 4;  					}  					if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)(src_ref)) == (*(ushort*)(src_p))))  					{  						src_p += 2;  						src_ref += 2;  					}  					if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p)) src_p++;    				_endCount:    					// Encode MatchLength  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    					if (len >= ML_MASK)  					{  						*dst_token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510)  						{  							*dst_p++ = 255;  							*dst_p++ = 255;  						}  						if (len > 254)  						{  							len -= 255;  							*dst_p++ = 255;  						}  						*dst_p++ = (byte)len;  					}  					else  					{  						*dst_token += (byte)len;  					}    					// Test end of chunk  					if (src_p > src_mflimit)  					{  						src_anchor = src_p;  						break;  					}    					// Fill table  					hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    					// Test next position    					h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);    					if ((*(uint*)(src_ref)) == (*(uint*)(src_p)))  					{  						dst_token = dst_p++;  						*dst_token = 0;  						goto _next_match;  					}    					// Prepare next loop  					src_anchor = src_p++;  					h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);  				}    			_last_literals:    				// Encode Last Literals  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else *dst_p++ = (byte)(lastRun << ML_BITS);  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				// End  				return (int)(dst_p - dst);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,C:\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,NativeFileMethods,C:\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,SetFileLength,The following statement contains a magic number: var hi = (int)(length >> 32);
Magic Number,Voron.Util,NativeFileMethods,C:\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,SetFileLength,The following statement contains a magic number: if (SetEndOfFile(fileHandle) == false)  			{  				lastError = Marshal.GetLastWin32Error();    				if (lastError == (int) NativeFileErrors.DiskFull)  				{  					var filePath = new StringBuilder(256);    					while (GetFinalPathNameByHandle(fileHandle' filePath' filePath.Capacity' 0) > filePath.Capacity &&   						filePath.Capacity < 32767) // max unicode path length  					{  					    filePath.EnsureCapacity(filePath.Capacity*2);  					}    					filePath = filePath.Replace(@"\\?\"' string.Empty); // remove extended-length path prefix    					var fullFilePath = filePath.ToString();  					var driveLetter = Path.GetPathRoot(fullFilePath);  					var driveInfo = new DriveInfo(driveLetter);    					throw new DiskFullException(driveInfo' fullFilePath' length);  				}    				throw new Win32Exception(lastError);  			}
Magic Number,Voron.Util,NativeFileMethods,C:\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,SetFileLength,The following statement contains a magic number: if (SetEndOfFile(fileHandle) == false)  			{  				lastError = Marshal.GetLastWin32Error();    				if (lastError == (int) NativeFileErrors.DiskFull)  				{  					var filePath = new StringBuilder(256);    					while (GetFinalPathNameByHandle(fileHandle' filePath' filePath.Capacity' 0) > filePath.Capacity &&   						filePath.Capacity < 32767) // max unicode path length  					{  					    filePath.EnsureCapacity(filePath.Capacity*2);  					}    					filePath = filePath.Replace(@"\\?\"' string.Empty); // remove extended-length path prefix    					var fullFilePath = filePath.ToString();  					var driveLetter = Path.GetPathRoot(fullFilePath);  					var driveInfo = new DriveInfo(driveLetter);    					throw new DiskFullException(driveInfo' fullFilePath' length);  				}    				throw new Win32Exception(lastError);  			}
Magic Number,Voron.Util,NativeFileMethods,C:\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,SetFileLength,The following statement contains a magic number: if (SetEndOfFile(fileHandle) == false)  			{  				lastError = Marshal.GetLastWin32Error();    				if (lastError == (int) NativeFileErrors.DiskFull)  				{  					var filePath = new StringBuilder(256);    					while (GetFinalPathNameByHandle(fileHandle' filePath' filePath.Capacity' 0) > filePath.Capacity &&   						filePath.Capacity < 32767) // max unicode path length  					{  					    filePath.EnsureCapacity(filePath.Capacity*2);  					}    					filePath = filePath.Replace(@"\\?\"' string.Empty); // remove extended-length path prefix    					var fullFilePath = filePath.ToString();  					var driveLetter = Path.GetPathRoot(fullFilePath);  					var driveInfo = new DriveInfo(driveLetter);    					throw new DiskFullException(driveInfo' fullFilePath' length);  				}    				throw new Win32Exception(lastError);  			}
Magic Number,Voron.Util,SkipList<TKey;TVal>,C:\repos\ayende_raven.voron\Voron\Util\SkipList.cs,RandomHeight,The following statement contains a magic number: const int branching = 4;
Magic Number,Voron.Util,Utils,C:\repos\ayende_raven.voron\Voron\Util\Utils.cs,NearestPowerOfTwo,The following statement contains a magic number: v |= v >> 2;
Magic Number,Voron.Util,Utils,C:\repos\ayende_raven.voron\Voron\Util\Utils.cs,NearestPowerOfTwo,The following statement contains a magic number: v |= v >> 4;
Magic Number,Voron.Util,Utils,C:\repos\ayende_raven.voron\Voron\Util\Utils.cs,NearestPowerOfTwo,The following statement contains a magic number: v |= v >> 8;
Magic Number,Voron.Util,Utils,C:\repos\ayende_raven.voron\Voron\Util\Utils.cs,NearestPowerOfTwo,The following statement contains a magic number: v |= v >> 16;
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxNumberOfPagesInJournalBeforeFlush = 1024;
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: IdleFlushTimeout = 5000;
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxLogFileSize = 64 * 1024 * 1024;
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxLogFileSize = 64 * 1024 * 1024;
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxLogFileSize = 64 * 1024 * 1024;
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: InitialLogFileSize = 64 * 1024;
Magic Number,Voron,StorageEnvironmentOptions,C:\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: InitialLogFileSize = 64 * 1024;
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: unchecked              {                  const int p = 16777619;                  int hash = (int)2166136261;                    for (int i = 0; i < _pointerSize; i++)                      hash = (hash ^ _pointer[i]) * p;                    hash += hash << 13;                  hash ^= hash >> 7;                  hash += hash << 3;                  hash ^= hash >> 17;                  hash += hash << 5;                  return hash;              }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: unchecked              {                  const int p = 16777619;                  int hash = (int)2166136261;                    for (int i = 0; i < _pointerSize; i++)                      hash = (hash ^ _pointer[i]) * p;                    hash += hash << 13;                  hash ^= hash >> 7;                  hash += hash << 3;                  hash ^= hash >> 17;                  hash += hash << 5;                  return hash;              }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: unchecked              {                  const int p = 16777619;                  int hash = (int)2166136261;                    for (int i = 0; i < _pointerSize; i++)                      hash = (hash ^ _pointer[i]) * p;                    hash += hash << 13;                  hash ^= hash >> 7;                  hash += hash << 3;                  hash ^= hash >> 17;                  hash += hash << 5;                  return hash;              }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: unchecked              {                  const int p = 16777619;                  int hash = (int)2166136261;                    for (int i = 0; i < _pointerSize; i++)                      hash = (hash ^ _pointer[i]) * p;                    hash += hash << 13;                  hash ^= hash >> 7;                  hash += hash << 3;                  hash ^= hash >> 17;                  hash += hash << 5;                  return hash;              }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: unchecked              {                  const int p = 16777619;                  int hash = (int)2166136261;                    for (int i = 0; i < _pointerSize; i++)                      hash = (hash ^ _pointer[i]) * p;                    hash += hash << 13;                  hash ^= hash >> 7;                  hash += hash << 3;                  hash ^= hash >> 17;                  hash += hash << 5;                  return hash;              }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: unchecked              {                  const int p = 16777619;                  int hash = (int)2166136261;                    for (int i = 0; i < _pointerSize; i++)                      hash = (hash ^ _pointer[i]) * p;                    hash += hash << 13;                  hash ^= hash >> 7;                  hash += hash << 3;                  hash ^= hash >> 17;                  hash += hash << 5;                  return hash;              }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: unchecked              {                  const int p = 16777619;                  int hash = (int)2166136261;                    for (int i = 0; i < _pointerSize; i++)                      hash = (hash ^ _pointer[i]) * p;                    hash += hash << 13;                  hash ^= hash >> 7;                  hash += hash << 3;                  hash ^= hash >> 17;                  hash += hash << 5;                  return hash;              }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: unchecked  	        {  	            const int p = 16777619;  	            int hash = (int) 2166136261;    	            for (int i = 0; i < _array.Length; i++)                      hash = (hash ^ _array[i]) * p;    	            hash += hash << 13;  	            hash ^= hash >> 7;  	            hash += hash << 3;  	            hash ^= hash >> 17;  	            hash += hash << 5;  	            return hash;  	        }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: unchecked  	        {  	            const int p = 16777619;  	            int hash = (int) 2166136261;    	            for (int i = 0; i < _array.Length; i++)                      hash = (hash ^ _array[i]) * p;    	            hash += hash << 13;  	            hash ^= hash >> 7;  	            hash += hash << 3;  	            hash ^= hash >> 17;  	            hash += hash << 5;  	            return hash;  	        }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: unchecked  	        {  	            const int p = 16777619;  	            int hash = (int) 2166136261;    	            for (int i = 0; i < _array.Length; i++)                      hash = (hash ^ _array[i]) * p;    	            hash += hash << 13;  	            hash ^= hash >> 7;  	            hash += hash << 3;  	            hash ^= hash >> 17;  	            hash += hash << 5;  	            return hash;  	        }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: unchecked  	        {  	            const int p = 16777619;  	            int hash = (int) 2166136261;    	            for (int i = 0; i < _array.Length; i++)                      hash = (hash ^ _array[i]) * p;    	            hash += hash << 13;  	            hash ^= hash >> 7;  	            hash += hash << 3;  	            hash ^= hash >> 17;  	            hash += hash << 5;  	            return hash;  	        }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: unchecked  	        {  	            const int p = 16777619;  	            int hash = (int) 2166136261;    	            for (int i = 0; i < _array.Length; i++)                      hash = (hash ^ _array[i]) * p;    	            hash += hash << 13;  	            hash ^= hash >> 7;  	            hash += hash << 3;  	            hash ^= hash >> 17;  	            hash += hash << 5;  	            return hash;  	        }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: unchecked  	        {  	            const int p = 16777619;  	            int hash = (int) 2166136261;    	            for (int i = 0; i < _array.Length; i++)                      hash = (hash ^ _array[i]) * p;    	            hash += hash << 13;  	            hash ^= hash >> 7;  	            hash += hash << 3;  	            hash ^= hash >> 17;  	            hash += hash << 5;  	            return hash;  	        }
Magic Number,Voron,Slice,C:\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: unchecked  	        {  	            const int p = 16777619;  	            int hash = (int) 2166136261;    	            for (int i = 0; i < _array.Length; i++)                      hash = (hash ^ _array[i]) * p;    	            hash += hash << 13;  	            hash ^= hash >> 7;  	            hash += hash << 3;  	            hash ^= hash >> 17;  	            hash += hash << 5;  	            return hash;  	        }
Magic Number,Voron,StorageEnvironment,C:\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,NewTransaction,The following statement contains a magic number: try              {                  if (flags == (TransactionFlags.ReadWrite))                  {                      var wait = timeout ?? (Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30));                      if (_txWriter.Wait(wait) == false)                      {                          throw new TimeoutException("Waited for " + wait +                                                     " for transaction write lock' but could not get it");                      }                      txLockTaken = true;    					if (_endOfDiskSpace != null)  					{  						if (_endOfDiskSpace.CanContinueWriting)  						{  							Debug.Assert(_flushingTask.Status == TaskStatus.Canceled || _flushingTask.Status == TaskStatus.RanToCompletion);  							_cancellationTokenSource = new CancellationTokenSource();  							_flushingTask = FlushWritesToDataFileAsync();  							_endOfDiskSpace = null;  						}                      }                  }                    long txId;                  Transaction tx;                    _txCommit.EnterReadLock();                  try                  {                      txId = flags == TransactionFlags.ReadWrite ? _transactionsCounter + 1 : _transactionsCounter;                      tx = new Transaction(this' txId' flags' _freeSpaceHandling);                  }                  finally                  {                      _txCommit.ExitReadLock();                  }                    _activeTransactions.Add(tx);                  var state = _dataPager.TransactionBegan();                  tx.AddPagerState(state);                    if (flags == TransactionFlags.ReadWrite)                  {                      tx.AfterCommit = TransactionAfterCommit;                  }                    return tx;              }              catch (Exception)              {                  if (txLockTaken)                      _txWriter.Release();                  throw;              }
Magic Number,Voron,StorageEnvironment,C:\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,NewTransaction,The following statement contains a magic number: try              {                  if (flags == (TransactionFlags.ReadWrite))                  {                      var wait = timeout ?? (Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30));                      if (_txWriter.Wait(wait) == false)                      {                          throw new TimeoutException("Waited for " + wait +                                                     " for transaction write lock' but could not get it");                      }                      txLockTaken = true;    					if (_endOfDiskSpace != null)  					{  						if (_endOfDiskSpace.CanContinueWriting)  						{  							Debug.Assert(_flushingTask.Status == TaskStatus.Canceled || _flushingTask.Status == TaskStatus.RanToCompletion);  							_cancellationTokenSource = new CancellationTokenSource();  							_flushingTask = FlushWritesToDataFileAsync();  							_endOfDiskSpace = null;  						}                      }                  }                    long txId;                  Transaction tx;                    _txCommit.EnterReadLock();                  try                  {                      txId = flags == TransactionFlags.ReadWrite ? _transactionsCounter + 1 : _transactionsCounter;                      tx = new Transaction(this' txId' flags' _freeSpaceHandling);                  }                  finally                  {                      _txCommit.ExitReadLock();                  }                    _activeTransactions.Add(tx);                  var state = _dataPager.TransactionBegan();                  tx.AddPagerState(state);                    if (flags == TransactionFlags.ReadWrite)                  {                      tx.AfterCommit = TransactionAfterCommit;                  }                    return tx;              }              catch (Exception)              {                  if (txLockTaken)                      _txWriter.Release();                  throw;              }
Magic Number,Voron,ValueReader,C:\repos\ayende_raven.voron\Voron\ValueReader.cs,CopyTo,The following statement contains a magic number: var buffer = new byte[4096];
Magic Number,Voron.Impl.FileHeaders,HeaderAccessor,C:\repos\ayende_raven.voron\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,The following statement contains a magic number: var headers = stackalloc FileHeader[2];
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,FirstSetBit,The following statement contains a magic number: for (int i = 0; i < _inner.Length; i++)              {                  if (_inner[i] == 0)                      continue;                  return i << 5 | HighestBitSet(_inner[i]);              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 2;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 4;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 8;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 16;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: return MultiplyDeBruijnBitPosition[(uint)(v * 0x07C4ACDDU) >> 27];
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,Get,The following statement contains a magic number: return (_inner[index >> 5] & (1 << (index & 31))) != 0;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,Get,The following statement contains a magic number: return (_inner[index >> 5] & (1 << (index & 31))) != 0;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,Set,The following statement contains a magic number: if (value)              {                  _inner[index >> 5] |= (1 << (index & 31));                  SetCount++;              }              else              {                  _inner[index >> 5] &= ~(1 << (index & 31));                  SetCount--;              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,Set,The following statement contains a magic number: if (value)              {                  _inner[index >> 5] |= (1 << (index & 31));                  SetCount++;              }              else              {                  _inner[index >> 5] &= ~(1 << (index & 31));                  SetCount--;              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,Set,The following statement contains a magic number: if (value)              {                  _inner[index >> 5] |= (1 << (index & 31));                  SetCount++;              }              else              {                  _inner[index >> 5] &= ~(1 << (index & 31));                  SetCount--;              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,Set,The following statement contains a magic number: if (value)              {                  _inner[index >> 5] |= (1 << (index & 31));                  SetCount++;              }              else              {                  _inner[index >> 5] &= ~(1 << (index & 31));                  SetCount--;              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,GetEndRangeCount,The following statement contains a magic number: for (int i = _inner.Length * 32 -1; i >= 0; i--)              {                  if (Get(i) == false)                      break;                  c++;              }
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HasStartRangeCount,The following statement contains a magic number: var len = _inner.Length*32;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,C:\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,ToStream,The following statement contains a magic number: var ms = new MemoryStream(260);
Magic Number,Voron.Trees,PageSplitter,C:\repos\ayende_raven.voron\Voron\Trees\PageSplitter.cs,SplitPageInHalf,The following statement contains a magic number: int splitIndex = _page.NumberOfEntries/2;
Magic Number,Voron.Trees,PageSplitter,C:\repos\ayende_raven.voron\Voron\Trees\PageSplitter.cs,AdjustSplitPosition,The following statement contains a magic number: if (page.NumberOfEntries >= 20 && nodeSize <= AbstractPager.PageMaxSpace/16)              {                  return splitIndex;              }
Magic Number,Voron.Trees,PageSplitter,C:\repos\ayende_raven.voron\Voron\Trees\PageSplitter.cs,AdjustSplitPosition,The following statement contains a magic number: if (page.NumberOfEntries >= 20 && nodeSize <= AbstractPager.PageMaxSpace/16)              {                  return splitIndex;              }
Magic Number,Voron.Trees,TreeRebalancer,C:\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,Execute,The following statement contains a magic number: if (page.NumberOfEntries == 0) // empty page' just delete it and fixup parent              {  				// need to delete the implicit left page' shift right                   if (parentPage.LastSearchPosition == 0 && parentPage.NumberOfEntries > 2)                  {  					var newImplicit = parentPage.GetNode(1)->PageNumber;                      parentPage.RemoveNode(0);                      parentPage.RemoveNode(0);                      parentPage.AddPageRefNode(0' Slice.Empty' newImplicit);                  }                  else // will be set to rights by the next rebalance call                  {                      parentPage.RemoveNode(parentPage.LastSearchPositionOrLastEntry);                  }  				  				_tx.FreePage(page.PageNumber);                  cursor.Pop();                    return parentPage;              }
Magic Number,Voron.Trees,TreeRebalancer,C:\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,Execute,The following statement contains a magic number: var minKeys = page.IsBranch ? 2 : 1;
Magic Number,Voron.Trees,TreeRebalancer,C:\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,Execute,The following statement contains a magic number: Debug.Assert(parentPage.NumberOfEntries >= 2);
Magic Number,Voron.Trees,TreeRebalancer,C:\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,Execute,The following statement contains a magic number: minKeys = sibling.IsBranch ? 2 : 1;
Magic Number,Voron.Trees,TreeRebalancer,C:\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,MoveBranchNode,The following statement contains a magic number: if (from.LastSearchPositionOrLastEntry == 0)              {                  // cannot just remove the left node' need to adjust those                  var rightPageNumber = from.GetNode(1)->PageNumber;                  from.RemoveNode(0); // remove the original implicit node                  from.RemoveNode(0); // remove the next node that we now turned into implicit                  from.EnsureHasSpaceFor(_tx' Slice.BeforeAllKeys' -1);                  from.AddPageRefNode(0' Slice.BeforeAllKeys' rightPageNumber);                  Debug.Assert(from.NumberOfEntries >= 2);              }              else              {                  from.RemoveNode(from.LastSearchPositionOrLastEntry);              }
Magic Number,Voron.Util.Conversion,BigEndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\BigEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: for (int i=0; i < bytes; i++)  			{  				buffer[endOffset-i] = unchecked((byte)(value&0xff));  				value = value >> 8;  			}
Magic Number,Voron.Util.Conversion,BigEndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\BigEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i=0; i < bytesToConvert; i++)  			{  				ret = unchecked((ret << 8) | buffer[startIndex+i]);  			}
Magic Number,Voron.Util.Conversion,LittleEndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\LittleEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: for (int i=0; i < bytes; i++)  			{  				buffer[i+index] = unchecked((byte)(value&0xff));  				value = value >> 8;  			}
Magic Number,Voron.Util.Conversion,LittleEndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\LittleEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i=0; i < bytesToConvert; i++)  			{  				ret = unchecked((ret << 8) | buffer[startIndex+bytesToConvert-1-i]);  			}
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToChar,The following statement contains a magic number: return unchecked((char) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToInt16,The following statement contains a magic number: return unchecked((short) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToInt32,The following statement contains a magic number: return unchecked((int) (CheckedFromBytes(value' startIndex' 4)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToInt64,The following statement contains a magic number: return CheckedFromBytes(value' startIndex' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToUInt16,The following statement contains a magic number: return unchecked((ushort) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return unchecked((uint) (CheckedFromBytes(value' startIndex' 4)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return unchecked((ulong) (CheckedFromBytes(value' startIndex' 8)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: int[] parts = new int[4];
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				parts[i] = ToInt32(value' startIndex+i*4);  			}
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				parts[i] = ToInt32(value' startIndex+i*4);  			}
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: byte[] bytes = new byte[16];
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' bytes' i*4);  			}
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' bytes' i*4);  			}
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' bytes' i*4);  			}
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' buffer' i*4+index);  			}
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' buffer' i*4+index);  			}
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' buffer' i*4+index);  			}
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(DoubleToInt64Bits(value)' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(SingleToInt32Bits(value)' 4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(unchecked((long)value)' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(DoubleToInt64Bits(value)' 8' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 4' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 8' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(SingleToInt32Bits(value)' 4' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 4' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,C:\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(unchecked((long)value)' 8' buffer' index);
Missing Default,Voron.Impl,SnapshotReader,C:\repos\ayende_raven.voron\Voron\Impl\SnapshotReader.cs,Read,The following switch statement is missing a default case: switch (operationType)  					{  						case WriteBatch.BatchOperationType.Add:  					    {  					        var reader = new ValueReader(stream);  					        return new ReadResult(reader' version.HasValue ? (ushort)(version.Value + 1) : tree.ReadVersion(Transaction' key));  					    }  						case WriteBatch.BatchOperationType.Delete:  							return null;  					}
Missing Default,Voron.Impl,SnapshotReader,C:\repos\ayende_raven.voron\Voron\Impl\SnapshotReader.cs,ReadVersion,The following switch statement is missing a default case: switch (operationType)  					{  						case WriteBatch.BatchOperationType.Add:  						case WriteBatch.BatchOperationType.Delete:  					        return (ushort)(version.Value + 1);  					}
Missing Default,Voron.Impl.Journal,UnmanagedVectorMemoryStream,C:\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,Seek,The following switch statement is missing a default case: switch (origin)  			{  					case SeekOrigin.Current:  						if (Position + offset > Length)  							throw new ArgumentOutOfRangeException("offset");  						Position += offset;  						break;  					case SeekOrigin.Begin:  						if(offset > Length || offset < 0)  							throw new ArgumentOutOfRangeException("offset");  						Position = offset;  						break;  					case SeekOrigin.End:  						if(offset > Length)  							throw new ArgumentOutOfRangeException("offset");  						Position = Length - offset;  						break;  			}
