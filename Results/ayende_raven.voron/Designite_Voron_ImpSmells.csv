Implementation smell,Namespace,Class,File,Method,Description
Long Method,Voron.Impl.Backup,IncrementalBackup,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Backup\IncrementalBackup.cs,ToFile,The method has 109 lines of code.
Long Method,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The method has 183 lines of code.
Long Method,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The method has 184 lines of code.
Long Method,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The method has 108 lines of code.
Long Method,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The method has 118 lines of code.
Complex Method,Voron.Debugging,DebugStuff,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugStuff.cs,HasDuplicateBranchReferences,Cyclomatic complexity of the method is 8
Complex Method,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,DumpHumanReadable,Cyclomatic complexity of the method is 9
Complex Method,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,Dump,Cyclomatic complexity of the method is 11
Complex Method,Voron.Impl.Backup,FullBackup,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Backup\FullBackup.cs,ToFile,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl.Backup,IncrementalBackup,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Backup\IncrementalBackup.cs,ToFile,Cyclomatic complexity of the method is 12
Complex Method,Voron.Impl,TransactionMergingWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,HandleOperations,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl,WriteBatch,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,TryGetValue,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl,WriteBatch,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,AddOperation,Cyclomatic complexity of the method is 9
Complex Method,Voron.Impl,Transaction,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,Commit,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl.Journal,JournalReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ValidateHeader,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl.Journal,WriteAheadJournal,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,RecoverDatabase,Cyclomatic complexity of the method is 12
Complex Method,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,Cyclomatic complexity of the method is 9
Complex Method,Voron.Impl.FileHeaders,HeaderAccessor,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl.FreeSpace,FreeSpaceHandling,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\FreeSpaceHandling.cs,TryFindContinuousRange,Cyclomatic complexity of the method is 8
Complex Method,Voron.Impl.FreeSpace,FreeSpaceHandling,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\FreeSpaceHandling.cs,TryFindSmallValueMergingTwoSections,Cyclomatic complexity of the method is 8
Complex Method,Voron.Trees,Page,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\Page.cs,Search,Cyclomatic complexity of the method is 10
Complex Method,Voron.Trees,PageSplitter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\PageSplitter.cs,AdjustSplitPosition,Cyclomatic complexity of the method is 10
Complex Method,Voron.Trees,Tree,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\Tree.cs,DirectAdd,Cyclomatic complexity of the method is 13
Complex Method,Voron.Trees,Tree,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\Tree.cs,SearchForPage,Cyclomatic complexity of the method is 8
Complex Method,Voron.Trees,TreeRebalancer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,Execute,Cyclomatic complexity of the method is 10
Complex Method,Voron.Trees,RecentlyFoundPages,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\RecentlyFoundPages.cs,Find,Cyclomatic complexity of the method is 10
Long Parameter List,Voron.Impl,MemoryMapNativeMethods,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\MemoryMapNativeMethods.cs,CreateFileMapping,The method has 6 parameters. Parameters: hFile' lpFileMappingAttributes' flProtect' dwMaximumSizeHigh' dwMaximumSizeLow' lpName
Long Parameter List,Voron.Impl,MemoryMapNativeMethods,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\MemoryMapNativeMethods.cs,MapViewOfFileEx,The method has 6 parameters. Parameters: hFileMappingObject' dwDesiredAccess' dwFileOffsetHigh' dwFileOffsetLow' dwNumberOfBytesToMap' lpBaseAddress
Long Parameter List,Voron.Impl,WriteBatch,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,TryGetValue,The method has 5 parameters. Parameters: treeName' key' value' version' operationType
Long Parameter List,Voron.Impl,BatchOperation,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,BatchOperation,The method has 5 parameters. Parameters: key' value' version' treeName' type
Long Parameter List,Voron.Impl,BatchOperation,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,BatchOperation,The method has 5 parameters. Parameters: key' value' version' treeName' type
Long Parameter List,Voron.Impl,BatchOperation,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,BatchOperation,The method has 5 parameters. Parameters: key' value' version' treeName' type
Long Parameter List,Voron.Impl.Journal,Win32FileJournalWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\Win32JournalWriter.cs,WriteFileGather,The method has 5 parameters. Parameters: hFile' aSegmentArray' nNumberOfBytesToWrite' lpReserved' lpOverlapped
Long Parameter List,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,Decode64,The method has 5 parameters. Parameters: input' inputLength' output' outputLength' knownOutputLength
Long Parameter List,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The method has 5 parameters. Parameters: hash_table' src' dst' src_len' dst_maxlen
Long Parameter List,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The method has 5 parameters. Parameters: hash_table' src' dst' src_len' dst_maxlen
Long Parameter List,Voron.Util,NativeFileMethods,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,WriteFile,The method has 5 parameters. Parameters: hFile' lpBuffer' nNumberOfBytesToWrite' lpNumberOfBytesWritten' lpOverlapped
Long Parameter List,Voron.Util,NativeFileMethods,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,ReadFile,The method has 5 parameters. Parameters: hFile' pBuffer' numBytesToRead' pNumberOfBytesRead' lpOverlapped
Long Parameter List,Voron.Util,NativeFileMethods,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,Voron.Impl.FreeSpace,FreeSpaceHandling,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\FreeSpaceHandling.cs,TryFindContinuousRange,The method has 6 parameters. Parameters: tx' it' num' current' currentSectionId' page
Long Parameter List,Voron.Impl.FreeSpace,FreeSpaceHandling,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\FreeSpaceHandling.cs,TryFindSmallValueMergingTwoSections,The method has 6 parameters. Parameters: tx' it' num' current' currentSectionId' result
Long Parameter List,Voron.Trees,Page,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\Page.cs,CreateNode,The method has 5 parameters. Parameters: index' key' flags' len' previousNodeVersion
Long Parameter List,Voron.Trees,PageSplitter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\PageSplitter.cs,PageSplitter,The method has 10 parameters. Parameters: tx' tree' cmp' newKey' len' pageNumber' nodeType' nodeVersion' cursor' treeState
Long Parameter List,Voron.Trees,PageSplitter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\PageSplitter.cs,AdjustSplitPosition,The method has 6 parameters. Parameters: key' len' page' currentIndex' splitIndex' newPosition
Long Parameter List,Voron.Trees,Tree,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\Tree.cs,DirectAdd,The method has 5 parameters. Parameters: tx' key' len' nodeType' version
Long Parameter List,Voron.Trees,Tree,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\Tree.cs,AddToRecentlyFoundPages,The method has 5 parameters. Parameters: tx' c' p' leftmostPage' rightmostPage
Long Parameter List,Voron.Trees,Tree,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\Tree.cs,TryOverwriteDataOrMultiValuePageRefNode,The method has 6 parameters. Parameters: updatedNode' key' len' requestedNodeType' version' pos
Long Parameter List,Voron.Trees,Tree,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\Tree.cs,TryOverwriteOverflowPages,The method has 7 parameters. Parameters: tx' treeState' updatedNode' key' len' version' pos
Long Identifier,Voron.Impl.Extensions,MiscExtensions,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Extensions\MiscExtensions.cs,GetTransactionToPageTranslation,The length of the parameter tempTransactionPageTranslaction is 31.
Long Identifier,Voron.Impl.Journal,JournalReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransaction,The length of the parameter tempTransactionPageTranslaction is 31.
Long Identifier,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,GetPagesFromJournals,The length of the parameter previousJournalMaxTransactionId is 31.
Long Identifier,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,GetPagesFromJournals,The length of the parameter currentJournalMaxTransactionId is 30.
Long Identifier,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,GetAndValidateOldestTransactionId,The length of the parameter currentJournalMaxTransactionId is 30.
Long Identifier,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,GetAndValidateOldestTransactionId,The length of the parameter previousJournalMaxTransactionId is 31.
Long Identifier,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,,The length of the parameter DelayedDataFileSynchronizationBytesLimit is 40.
Long Identifier,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,,The length of the parameter DelayedDataFileSynchronizationTimeLimit is 39.
Long Identifier,Voron.Impl.Paging,Win32PageFileBackedMemoryMappedPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PageFileBackedMemoryMappedPager.cs,AllocateMorePagesAndRemapContinuously,The length of the parameter allocationInfoAfterReallocation is 31.
Long Identifier,Voron.Util,EndOfDiskSpaceEvent,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\EndOfDiskSpaceEvent.cs,,The length of the parameter _availableSpaceWhenEventOccurred is 32.
Long Identifier,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,,The length of the parameter NOTCOMPRESSIBLE_DETECTIONLEVEL is 30.
Long Identifier,Voron,StorageEnvironment,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,FlushWritesToDataFileAsync,The length of the parameter sizeOfUnflushedTransactionsInJournalFile is 40.
Long Identifier,Voron,StorageEnvironment,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,,The length of the parameter _sizeOfUnflushedTransactionsInJournalFile is 41.
Long Statement,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,DumpHumanReadable,The length of the statement  "						writer.WriteLine("Page #{0}' NumberOfEntries = {1}' Flags = {2} (Leaf)' Used: {3} : {4}"' currentPage.PageNumber'currentPage.NumberOfEntries'currentPage.Flags' currentPage.SizeUsed' currentPage.CalcSizeUsed()); " is 210.
Long Statement,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,DumpHumanReadable,The length of the statement  "							writer.WriteLine("Node #{0}' Flags = {1}' {4} = {2}' Key = {3}' Entry Size: {5}"' nodeIndex' node->Flags' node->DataSize' MaxString(key.ToString()' 25)' node->Flags == NodeFlags.Data ? "Size" : "Page"' " is 201.
Long Statement,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,DumpHumanReadable,The length of the statement  "						writer.WriteLine("Page #{0}' NumberOfEntries = {1}' Flags = {2} (Branch)' Used: {3} : {4}"' currentPage.PageNumber' currentPage.NumberOfEntries' currentPage.Flags' currentPage.SizeUsed' currentPage.SizeUsed); " is 208.
Long Statement,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,DumpHumanReadable,The length of the statement  "							writer.WriteLine("Node #{2}' {0}  / to page #{1}' Entry Size: {3}"' GetBranchNodeString(nodeIndex' key' currentPage' node)' node->PageNumber' nodeIndex' " is 152.
Long Statement,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,Dump,The length of the statement  "                            references.AppendFormat("	p_{0}_refs:{3} -> p_{1} [label=\"{2}\"];"' p.PageNumber' child.PageNumber' GetBranchNodeString(i' key' p' node)' i).AppendLine(); " is 155.
Long Statement,Voron.Impl.Backup,IncrementalBackup,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Backup\IncrementalBackup.cs,ToFile,The length of the statement  "                            var journalFile = env.Journal.Files.FirstOrDefault(x => x.Number == journalNum); // first check journal files currently being in use " is 132.
Long Statement,Voron.Impl.Backup,IncrementalBackup,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Backup\IncrementalBackup.cs,Restore,The length of the statement  "                            var recoveryPager = new Win32MemoryMapPager(Path.Combine(tempDir' StorageEnvironmentOptions.JournalRecoveryName(journalNumber))); " is 129.
Long Statement,Voron.Impl,PageFromScratchBuffer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\ScratchBufferPool.cs,Equals,The length of the statement  "            return PositionInScratchBuffer == other.PositionInScratchBuffer && Size == other.Size && NumberOfPages == other.NumberOfPages; " is 126.
Long Statement,Voron.Impl,WriteBatch,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,TryGetValue,The length of the statement  "					//since in multi-tree there are many operations for single tree key' then fetching operation type and value is meaningless " is 122.
Long Statement,Voron.Impl,WriteBatch,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\WriteBatch.cs,Add,The length of the statement  "			//TODO : check up if adding empty values make sense in Voron --> in order to be consistent with existing behavior of Esent' this should be allowed " is 146.
Long Statement,Voron.Impl,Transaction,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,GetReadOnlyPage,The length of the statement  "            Debug.Assert(p != null && p.PageNumber == pageNumber' string.Format("Requested ReadOnly page #{0}. Got #{1} from {2}"' pageNumber' p.PageNumber' p.Source)); " is 156.
Long Statement,Voron.Impl,Transaction,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,AllocatePage,The length of the statement  "							"Currently configured storage quota is allowing to allocate the following maximum page number {1}' while the requested page number is {2}. " + " is 142.
Long Statement,Voron.Impl.Journal,ShippedTransactionsReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\ShippedTransactionsReader.cs,ReadFromShippedTransaction,The length of the statement  "			var compressedPages = (transaction.Header.CompressedSize / AbstractPager.PageSize) + (transaction.Header.CompressedSize % AbstractPager.PageSize == 0 ? 0 : 1); " is 159.
Long Statement,Voron.Impl.Journal,ShippedTransactionsReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\ShippedTransactionsReader.cs,ReadFromShippedTransaction,The length of the statement  "					LZ4.Decode64(compressedDataBufferPtr' transaction.Header.CompressedSize' _pager.AcquirePagePointer(currentPage)' transaction.Header.UncompressedSize' true); " is 156.
Long Statement,Voron.Impl.Journal,PagePosition,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalFile.cs,Equals,The length of the statement  "                return ScratchPos == other.ScratchPos && JournalPos == other.JournalPos && TransactionId == other.TransactionId && JournalNumber == other.JournalNumber; " is 152.
Long Statement,Voron.Impl.Journal,JournalReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionForShipping,The length of the statement  "			var compressedPageCount = (current->CompressedSize / AbstractPager.PageSize) + (current->CompressedSize % AbstractPager.PageSize == 0 ? 0 : 1); " is 143.
Long Statement,Voron.Impl.Journal,JournalReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionForShipping,The length of the statement  "				NativeMethods.memcpy(compressedDataPtr' _pager.AcquirePagePointer(_readingPage)' compressedPageCount * AbstractPager.PageSize); " is 127.
Long Statement,Voron.Impl.Journal,JournalReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransactionForShipping,The length of the statement  "				CompressedData = new MemoryStream(compressedPagesRaw)' //no need to compress the pages --> after being written to Journal they are already compressed " is 149.
Long Statement,Voron.Impl.Journal,JournalReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransaction,The length of the statement  "			var compressedPages = (current->CompressedSize / AbstractPager.PageSize) + (current->CompressedSize % AbstractPager.PageSize == 0 ? 0 : 1); " is 139.
Long Statement,Voron.Impl.Journal,JournalReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,ReadOneTransaction,The length of the statement  "				LZ4.Decode64(_pager.AcquirePagePointer(_readingPage)' current->CompressedSize' dataPage' current->UncompressedSize' true); " is 122.
Long Statement,Voron.Impl.Journal,JournalReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalReader.cs,TryReadAndValidateHeader,The length of the statement  "				// if the header marker is zero' we are probably in the area at the end of the log file' and have no additional log records " is 123.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,RecoverDatabase,The length of the statement  "				using (var recoveryPager = _env.Options.CreateScratchPager(StorageEnvironmentOptions.JournalRecoveryName(journalNumber))) " is 121.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,RecoverDatabase,The length of the statement  "						var jrnlWriter = _env.Options.CreateJournalWriter(journalNumber' pager.NumberOfAllocatedPages * AbstractPager.PageSize); " is 120.
Long Statement,Voron.Impl.Journal,WriteAheadJournal,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,CompressPages,The length of the statement  "			var compressedPages = (sizeAfterCompression / AbstractPager.PageSize) + (sizeAfterCompression % AbstractPager.PageSize == 0 ? 0 : 1); " is 133.
Long Statement,Voron.Impl.Journal,JournalShipper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ReadJournalForShippings,The length of the statement  "					if (_shippingSemaphore.TryEnterReadLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false) " is 124.
Long Statement,Voron.Impl.Journal,JournalShipper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ReadJournalForShippings,The length of the statement  "						var journalReader = new JournalReader(_waj._env.Options.OpenJournalPager(journalNumber)' null' lastTransactionId' null); " is 120.
Long Statement,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The length of the statement  "					if (_flushingSemaphore.TryEnterWriteLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false) " is 125.
Long Statement,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,UpdateFileHeaderAfterDataFileSync,The length of the statement  "					var compressedPages = (readTxHeader->CompressedSize / AbstractPager.PageSize) + (readTxHeader->CompressedSize % AbstractPager.PageSize == 0 ? 0 : 1); " is 149.
Long Statement,Voron.Impl.Paging,Win32PageFileBackedMemoryMappedPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PageFileBackedMemoryMappedPager.cs,AllocateMorePages,The length of the statement  "		                "Unable to allocate more pages - unsucsessfully tried to allocate continuous block of virtual memory with size = {0:##'###;;0} bytes"' " is 134.
Long Statement,Voron.Impl.Paging,Win32PageFileBackedMemoryMappedPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PageFileBackedMemoryMappedPager.cs,AllocateMorePagesAndRemapContinuously,The length of the statement  "					var newAlloctedBaseAddress = MemoryMapNativeMethods.MapViewOfFileEx(allocationInfo.MappedFile.SafeMemoryMappedFileHandle.DangerousGetHandle()' " is 142.
Long Statement,Voron.Impl.Paging,Win32PageFileBackedMemoryMappedPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PageFileBackedMemoryMappedPager.cs,AllocateMorePagesAndRemapContinuously,The length of the statement  "		            "Something bad has happened' after {0} tries' could not find any spot in virtual memory to remap continuous virtual memory for {1:##'###;;0} bytes"' " is 148.
Long Statement,Voron.Impl.Paging,Win32PageFileBackedMemoryMappedPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PageFileBackedMemoryMappedPager.cs,CreateInitialPagerState,The length of the statement  "				Accessor = null' //not available since MapViewOfFileEx is used (instead of MapViewOfFile - which is used in managed wrapper) " is 124.
Long Statement,Voron.Impl.Paging,Win32MemoryMapPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32MemoryMapPager.cs,AllocateMorePages,The length of the statement  "						"Unable to allocate more pages - unsucsessfully tried to allocate continuous block of virtual memory with size = {0:##'###;;0} bytes"' " is 134.
Long Statement,Voron.Impl.Paging,Win32MemoryMapPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32MemoryMapPager.cs,TryAllocateMoreContinuousPages,The length of the statement  "			var allocationInfo = RemapViewOfFileAtAddress(allocationSize' (ulong)_totalAllocationSize' PagerState.MapBase + _totalAllocationSize); " is 134.
Long Statement,Voron.Impl.Paging,Win32MemoryMapPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32MemoryMapPager.cs,CreatePagerState,The length of the statement  "				Accessor = null' //not available since MapViewOfFileEx is used (instead of MapViewOfFile - which is used in managed wrapper) " is 124.
Long Statement,Voron.Impl.Paging,Win32PureMemoryPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,AllocatePages,The length of the statement  "                var extResult = NativeMethods.VirtualAlloc(_baseAddress + _reservedSize' new UIntPtr(_reservedSize)' NativeMethods.AllocationType.RESERVE' NativeMethods.MemoryProtection.NOACCESS); " is 180.
Long Statement,Voron.Impl.Paging,Win32PureMemoryPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,AllocatePages,The length of the statement  "			var result = NativeMethods.VirtualAlloc(lpAddress' new UIntPtr(dwSize)' NativeMethods.AllocationType.COMMIT' NativeMethods.MemoryProtection.READWRITE); " is 151.
Long Statement,Voron.Impl.Paging,Win32PureMemoryPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Dispose,The length of the statement  "                NativeMethods.VirtualFree(_baseAddress +(i * _reservedSize)' new UIntPtr(_reservedSize)' NativeMethods.FreeType.MEM_RELEASE); " is 125.
Long Statement,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The length of the statement  "				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0) " is 121.
Long Statement,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The length of the statement  "						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals) " is 217.
Long Statement,Voron,DirectoryStorageEnvironmentOptions,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,CreateJournalWriter,The length of the statement  "				var result = _journals.GetOrAdd(name' _ => new Lazy<IJournalWriter>(() => new Win32FileJournalWriter(path' journalSize))); " is 122.
Long Statement,Voron,StorageEnvironment,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,LoadExistingDatabase,The length of the statement  "                var message = _journal.Files.Count == 0 ? "Unrecoverable database" : "Database recovered partially. Some data was lost."; " is 121.
Long Statement,Voron,StorageEnvironment,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,Stats,The length of the statement  "			var numberOfAllocatedPages = Math.Max(_dataPager.NumberOfAllocatedPages' State.NextPageNumber - 1); // async apply to data file task " is 132.
Long Statement,Voron,StorageEnvironment,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,FlushWritesToDataFileAsync,The length of the statement  "					        // we didn't have a write in the idle timeout (default: 5 seconds)' this is probably a good time to try and do a proper flush " is 125.
Long Statement,Voron.Impl.FileHeaders,HeaderAccessor,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,The length of the statement  "				throw new InvalidDataException("This is a db file for version " + f1->Version + "' which is not compatible with the current version " + Constants.CurrentVersion); " is 162.
Long Statement,Voron.Trees,Page,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\Page.cs,CopyNodeDataToEndOfPage,The length of the statement  "	        var nodeVersion = other->Version; // every time new node is allocated the version is increased' but in this case we do not want to increase it " is 142.
Long Statement,Voron.Trees,Tree,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\Tree.cs,CheckConcurrency,The length of the statement  "				throw new ConcurrencyException(string.Format("Cannot {0} '{1}'. Version mismatch. Expected: {2}. Actual: {3}."' actionType.ToString().ToLowerInvariant()' key' expectedVersion.Value' nodeVersion)); " is 196.
Long Statement,Voron.Trees,Tree,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\Tree.cs,TryOverwriteOverflowPages,The length of the statement  "				tx.Id <= tx.Environment.OldestTransaction) // ensure MVCC - do not overwrite if there is some older active transaction that might read those overflows " is 150.
Long Statement,Voron.Trees,TreeRebalancer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,MoveLeafNode,The length of the statement  "            byte* val = @from.Base + @from.KeysOffsets[@from.LastSearchPosition] + Constants.NodeHeaderSize + originalFromKeyStart.Size; " is 124.
Long Statement,Voron.Trees,TreeRebalancer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,MoveLeafNode,The length of the statement  "			var nodeVersion = fromNode->Version; // every time new node is allocated the version is increased' but in this case we do not want to increase it " is 145.
Virtual Method Call from Constructor,Voron.Impl,ScratchBufferPool,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\ScratchBufferPool.cs,ScratchBufferPool,The constructor "ScratchBufferPool" calls a virtual method "CreateScratchPager".
Virtual Method Call from Constructor,Voron.Impl.Journal,WriteAheadJournal,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,WriteAheadJournal,The constructor "WriteAheadJournal" calls a virtual method "CreateScratchPager".
Empty Catch Block,Voron.Debugging,DebugJournal,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,Flush,The method has an empty catch block.
Empty Catch Block,Voron.Debugging,DebugJournal,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Voron.Impl,TransactionMergingWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Voron,StorageEnvironment,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,FlushWritesToDataFileAsync,The method has an empty catch block.
Magic Number,Voron.Debugging,ActivityEntry,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: columnArray.Count != 4
Magic Number,Voron.Debugging,ActivityEntry,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: var activityEntry = new ActivityEntry(                              GenericUtil.ParseEnum<DebugActionType>(columnArray[0])'                              columnArray[2]'                              columnArray[1]'                              null);
Magic Number,Voron.Debugging,ActivityEntry,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: switch (type)                      {                          case DebugActionType.MultiAdd:                          case DebugActionType.MultiDelete:                                 value = new Slice(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                          default:                              if (recordOnlyValueLength)                              {                                  var length = long.Parse(columnArray[3]);                                  var bytes = new byte[length];                                  random.NextBytes(bytes);                                    value = new MemoryStream(bytes);                              }                              else                                  value = new MemoryStream(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                      }
Magic Number,Voron.Debugging,ActivityEntry,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: switch (type)                      {                          case DebugActionType.MultiAdd:                          case DebugActionType.MultiDelete:                                 value = new Slice(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                          default:                              if (recordOnlyValueLength)                              {                                  var length = long.Parse(columnArray[3]);                                  var bytes = new byte[length];                                  random.NextBytes(bytes);                                    value = new MemoryStream(bytes);                              }                              else                                  value = new MemoryStream(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                      }
Magic Number,Voron.Debugging,ActivityEntry,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: switch (type)                      {                          case DebugActionType.MultiAdd:                          case DebugActionType.MultiDelete:                                 value = new Slice(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                          default:                              if (recordOnlyValueLength)                              {                                  var length = long.Parse(columnArray[3]);                                  var bytes = new byte[length];                                  random.NextBytes(bytes);                                    value = new MemoryStream(bytes);                              }                              else                                  value = new MemoryStream(Encoding.UTF8.GetBytes(columnArray[3]));                              break;                      }
Magic Number,Voron.Debugging,ActivityEntry,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugJournal.cs,FromCsvLine,The following statement contains a magic number: var entry = new ActivityEntry(type'                          columnArray[2]'                          columnArray[1]'                          value);
Magic Number,Voron.Debugging,DebugStuff,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugStuff.cs,RenderAndShow,The following statement contains a magic number: (dateTime - _lastGenerated).TotalSeconds < 2.5
Magic Number,Voron.Debugging,DebugStuff,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugStuff.cs,RenderAndShow,The following statement contains a magic number: Thread.Sleep(500);
Magic Number,Voron.Debugging,DebugStuff,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\DebugStuff.cs,FindGraphviz,The following statement contains a magic number: i < 100
Magic Number,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,DumpHumanReadable,The following statement contains a magic number: writer.WriteLine("Node #{0}' Flags = {1}' {4} = {2}' Key = {3}' Entry Size: {5}"' nodeIndex' node->Flags' node->DataSize' MaxString(key.ToString()' 25)' node->Flags == NodeFlags.Data ? "Size" : "Page"'                                  SizeOf.NodeEntry(node));
Magic Number,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,Dump,The following statement contains a magic number: writer.WriteLine(@"  	subgraph cluster_p_{0} {{   		label=""Page #{0}"";  		color={3};  	p_{0} [label=""Page: {0}|{1}|Entries: {2:#'#} | {4:p} : {5:p} utilization""];    "' p.PageNumber' p.Flags' p.NumberOfEntries' p.IsLeaf ? "black" : "blue"'  	Math.Round(((AbstractPager.PageSize - p.SizeLeft) / (double)AbstractPager.PageSize)' 2)'      Math.Round(((AbstractPager.PageSize - p.CalcSizeLeft()) / (double)AbstractPager.PageSize)' 2));
Magic Number,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,Dump,The following statement contains a magic number: writer.WriteLine(@"  	subgraph cluster_p_{0} {{   		label=""Page #{0}"";  		color={3};  	p_{0} [label=""Page: {0}|{1}|Entries: {2:#'#} | {4:p} : {5:p} utilization""];    "' p.PageNumber' p.Flags' p.NumberOfEntries' p.IsLeaf ? "black" : "blue"'  	Math.Round(((AbstractPager.PageSize - p.SizeLeft) / (double)AbstractPager.PageSize)' 2)'      Math.Round(((AbstractPager.PageSize - p.CalcSizeLeft()) / (double)AbstractPager.PageSize)' 2));
Magic Number,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,Dump,The following statement contains a magic number: i != 0 && showNodesEvery >= 5
Magic Number,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,Dump,The following statement contains a magic number: writer.WriteLine("{0} - {2} {1:#'#}"' MaxString(key.ToString()' 25)'                                  node->DataSize' node->Flags == NodeFlags.Data ? "Size" : "Page");
Magic Number,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,MaxString,The following statement contains a magic number: return key.Substring(0' (size/2)) + "..." + key.Substring(key.Length - size/2' size/2);
Magic Number,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,MaxString,The following statement contains a magic number: return key.Substring(0' (size/2)) + "..." + key.Substring(key.Length - size/2' size/2);
Magic Number,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,MaxString,The following statement contains a magic number: return key.Substring(0' (size/2)) + "..." + key.Substring(key.Length - size/2' size/2);
Magic Number,Voron.Debugging,TreeDumper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Debugging\TreeDumper.cs,GetBranchNodeString,The following statement contains a magic number: return MaxString(keyStr' 25);
Magic Number,Voron.Impl.Backup,FullBackup,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Backup\FullBackup.cs,ToFile,The following statement contains a magic number: var copier = new DataCopier(AbstractPager.PageSize * 16);
Magic Number,Voron.Impl.Backup,FullBackup,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Backup\FullBackup.cs,ToFile,The following statement contains a magic number: Debug.Assert(HeaderAccessor.HeaderFileNames.Length == 2);
Magic Number,Voron.Impl.Backup,IncrementalBackup,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Backup\IncrementalBackup.cs,ToFile,The following statement contains a magic number: var copier = new DataCopier(AbstractPager.PageSize * 16);
Magic Number,Voron.Impl,PagerState,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\PagerState.cs,AddRef,The following statement contains a magic number: AddedRefs.Count > 500
Magic Number,Voron.Impl,PageFromScratchBuffer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\ScratchBufferPool.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Size.GetHashCode();
Magic Number,Voron.Impl,PageFromScratchBuffer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\ScratchBufferPool.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ NumberOfPages;
Magic Number,Voron.Impl,TransactionMergingWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: long maxSize = 16 * 1024 * 1024;
Magic Number,Voron.Impl,TransactionMergingWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: long maxSize = 16 * 1024 * 1024;
Magic Number,Voron.Impl,TransactionMergingWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: long maxSize = 16 * 1024 * 1024;
Magic Number,Voron.Impl,TransactionMergingWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: maxSize = (1024 * 1024);
Magic Number,Voron.Impl,TransactionMergingWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: maxSize = (1024 * 1024);
Magic Number,Voron.Impl,TransactionMergingWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: mine.Size < 128 * 1024
Magic Number,Voron.Impl,TransactionMergingWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\TransactionMergingWriter.cs,BuildBatchGroup,The following statement contains a magic number: mine.Size < 128 * 1024
Magic Number,Voron.Impl,TreeAndSliceComparer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\TreeAndSliceComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Item1.GetHashCode() ^ 397 * obj.Item2.GetHashCode();
Magic Number,Voron.Impl,Transaction,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,FreePage,The following statement contains a magic number: Debug.Assert(pageNumber >= 2);
Magic Number,Voron.Impl,Transaction,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,AddRecentlyFoundPage,The following statement contains a magic number: _recentlyFoundPages[tree] = pages = new RecentlyFoundPages(Flags == TransactionFlags.Read ? 8 : 2);
Magic Number,Voron.Impl,Transaction,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Transaction.cs,AddRecentlyFoundPage,The following statement contains a magic number: _recentlyFoundPages[tree] = pages = new RecentlyFoundPages(Flags == TransactionFlags.Read ? 8 : 2);
Magic Number,Voron.Impl.Journal,PagePosition,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalFile.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ JournalPos.GetHashCode();
Magic Number,Voron.Impl.Journal,PagePosition,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalFile.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ TransactionId.GetHashCode();
Magic Number,Voron.Impl.Journal,PagePosition,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\JournalFile.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ JournalNumber.GetHashCode();
Magic Number,Voron.Impl.Journal,Win32FileJournalWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\Win32JournalWriter.cs,WriteGather,The following statement contains a magic number: _nativeOverlapped->OffsetHigh = (int) (position >> 32);
Magic Number,Voron.Impl.Journal,Win32FileJournalWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\Win32JournalWriter.cs,WriteGather,The following statement contains a magic number: IntPtr.Size == 4
Magic Number,Voron.Impl.Journal,Win32FileJournalWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\Win32JournalWriter.cs,WriteGather,The following statement contains a magic number: WriteFileGather(_handle' _segments' (uint) pages.Length*4096' IntPtr.Zero' _nativeOverlapped);
Magic Number,Voron.Impl.Journal,Win32FileJournalWriter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\Win32JournalWriter.cs,Read,The following statement contains a magic number: var overlapped = new Overlapped((int) (position & 0xffffffff)' (int) (position >> 32)' IntPtr.Zero' null);
Magic Number,Voron.Impl.Journal,WriteAheadJournal,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,NextFile,The following statement contains a magic number: _currentJournalFileSize = Math.Min(_env.Options.MaxLogFileSize' _currentJournalFileSize * 2);
Magic Number,Voron.Impl.Journal,WriteAheadJournal,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,NextFile,The following statement contains a magic number: (now - _lastFile).TotalSeconds < 90
Magic Number,Voron.Impl.Journal,WriteAheadJournal,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,RecoverDatabase,The following statement contains a magic number: lastFile.AvailablePages >= 2
Magic Number,Voron.Impl.Journal,JournalShipper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ReadJournalForShippings,The following statement contains a magic number: _shippingSemaphore.TryEnterReadLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false
Magic Number,Voron.Impl.Journal,JournalShipper,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ReadJournalForShippings,The following statement contains a magic number: _shippingSemaphore.TryEnterReadLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false
Magic Number,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The following statement contains a magic number: _flushingSemaphore.TryEnterWriteLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false
Magic Number,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,ApplyLogsToDataFile,The following statement contains a magic number: _flushingSemaphore.TryEnterWriteLock(Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30)) == false
Magic Number,Voron.Impl.Journal,JournalApplicator,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,UpdateFileHeaderAfterDataFileSync,The following statement contains a magic number: var txHeaders = stackalloc TransactionHeader[2];
Magic Number,Voron.Impl.Paging,AbstractPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,AbstractPager,The following statement contains a magic number: MaxNodeSize = 1024;
Magic Number,Voron.Impl.Paging,AbstractPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,AbstractPager,The following statement contains a magic number: Debug.Assert((PageSize - Constants.PageHeaderSize) / Constants.MinKeysInPage >= 1024);
Magic Number,Voron.Impl.Paging,AbstractPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,AbstractPager,The following statement contains a magic number: PageMinSpace = (int)(PageMaxSpace * 0.33);
Magic Number,Voron.Impl.Paging,AbstractPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: _increaseSize = Math.Min(_increaseSize * 2' current + current / 4);
Magic Number,Voron.Impl.Paging,AbstractPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: _increaseSize = Math.Min(_increaseSize * 2' current + current / 4);
Magic Number,Voron.Impl.Paging,AbstractPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: timeSinceLastIncrease.TotalSeconds < 30
Magic Number,Voron.Impl.Paging,AbstractPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\AbstractPager.cs,GetNewLength,The following statement contains a magic number: var actualIncrease = Math.Min(_increaseSize' current / 4);
Magic Number,Voron.Impl.Paging,FilePager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\FilePager.cs,WriteDirect,The following statement contains a magic number: var overlapped = new Overlapped()              {                  OffsetLow = (int)(position & 0xffffffff)'                  OffsetHigh = (int)(position >> 32)'              };
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Impl.Paging,Win32PureMemoryPager,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Paging\Win32PureMemoryPager.cs,Win32PureMemoryPager,The following statement contains a magic number: _reservedSize = Environment.Is64BitProcess ? 4 * 1024 * 1024 * 1024UL : 128 * 1024 * 1024UL;
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Mask,The following statement contains a magic number: return (int)(((crc >> 15) | (crc << 17)) + MaskDelta);
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Mask,The following statement contains a magic number: return (int)(((crc >> 15) | (crc << 17)) + MaskDelta);
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Unmask,The following statement contains a magic number: return ((rot >> 17) | (rot << 15));
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Unmask,The following statement contains a magic number: return ((rot >> 17) | (rot << 15));
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: fixed (uint* t1 = Table_1)  				fixed (uint* t2 = Table_2)  				fixed (uint* t3 = Table_3)  				{  					byte* dataPtr = ptr + offset;  					byte* endPtr = dataPtr + count;  					uint c;  					uint uint32Value;    					crc ^= 0xFFFFFFFF;    					// Point x at first 4-byte aligned byte in string.  This might be  					// just past the end of the string.  					ulong pval = (ulong)dataPtr;  					byte* x = (byte*)(((pval + 3) >> 2) << 2);    					if (x <= endPtr)  					{  						// Process bytes until finished or p is 4-byte aligned  						while (dataPtr != x)  						{  							c = (crc & 0xff) ^ *dataPtr++;  							crc = *(t0 + c) ^ (crc >> 8);  						}  					}    					// Process bytes 16 at a time  					while ((endPtr - dataPtr) >= 16)  					{  						for (int i = 0; i < 4; i++)  						{  							uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  							c = crc ^ uint32Value;  							dataPtr += 4;  							crc = *(t3 + (c & 0xff)) ^  							      *(t2 + ((c >> 8) & 0xff)) ^  							      *(t1 + ((c >> 16) & 0xff)) ^  							      *(t0 + (c >> 24));  						}  					}    					// Process bytes 4 at a time  					while ((endPtr - dataPtr) >= 4)  					{  						uint32Value = *dataPtr | (uint)*(dataPtr + 1) << 8 | (uint)*(dataPtr + 2) << 16 | (uint)*(dataPtr + 3) << 24;  						c = crc ^ uint32Value;  						dataPtr += 4;  						crc = *(t3 + (c & 0xff)) ^  						      *(t2 + ((c >> 8) & 0xff)) ^  						      *(t1 + ((c >> 16) & 0xff)) ^  						      *(t0 + (c >> 24));  					}    					// Process the last few bytes  					while (dataPtr != endPtr)  					{  						c = (crc & 0xff) ^ *dataPtr++;  						crc = *(t0 + c) ^ (crc >> 8);  					}    					return crc ^ 0xFFFFFFFF;  				}
Magic Number,Voron.Util,Crc,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Crc.cs,Extend,The following statement contains a magic number: return (*(t0 + ((crcSeed & 0xff) ^ b)) ^ (crcSeed >> 8)) ^ 0xFFFFFFFF;
Magic Number,Voron.Util,ImmutableAppendOnlyList<T>,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\ImmutableAppendOnlyList.cs,Append,The following statement contains a magic number: var newArray = GrowTo(Math.Max(8' (int)Utils.NearestPowerOfTwo(newCount)));
Magic Number,Voron.Util,ImmutableAppendOnlyList<T>,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\ImmutableAppendOnlyList.cs,AppendRange,The following statement contains a magic number: var newArray = GrowTo(_count + nToAdd * 2);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,MaximumOutputLength,The following statement contains a magic number: return inputLength + (inputLength / 255) + 16;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,MaximumOutputLength,The following statement contains a magic number: return inputLength + (inputLength / 255) + 16;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: var src_LASTLITERALS_3 = src_LASTLITERALS - 3;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: hash_table[((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - src_base);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH_ADJUST);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: dst_p + length + (length >> 8) > dst_LASTLITERALS_3
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: *dst_p++ = 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: len -= 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: len > 254
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: do  						{  							*(ulong*)dst_p = *(ulong*)src_anchor;  							dst_p += 8;  							src_anchor += 8;  						} while (dst_p < _p);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: dst_p += 2;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: src_p += 4;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: src_ref += 4;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: src_p += 2;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: src_ref += 2;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: dst_p + (length >> 8) > dst_LASTLITERALS_1
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: *dst_p++ = 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: *dst_p++ = 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: length > 509
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: length -= 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: *dst_p++ = 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: length > 254
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH_ADJUST)] = (uint)(src_p - 2 - src_base);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH_ADJUST);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: *dst_p++ = 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compressCtx_64,The following statement contains a magic number: lastRun > 254
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: var src_LASTLITERALS_3 = src_LASTLITERALS - 3;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: h_fwd = ((((*(uint*)(src_p_fwd))) * 2654435761u) >> HASH64K_ADJUST);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: dst_p + length + (length >> 8) > dst_LASTLITERALS_3
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: *dst_p++ = 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: len -= 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: len > 254
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: dst_p += 8;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: src_anchor += 8;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: dst_p += 2;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: src_p += debruijn64[(((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL)) >> 58];
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: src_p += 4;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: src_ref += 4;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: src_p += 2;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: src_ref += 2;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: dst_p + (len >> 8) > dst_LASTLITERALS_1
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: *dst_p++ = 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: *dst_p++ = 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: len > 509
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: len -= 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: *dst_p++ = 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: len > 254
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: hash_table[((((*(uint*)(src_p - 2))) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: h = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: h_fwd = ((((*(uint*)(src_p))) * 2654435761u) >> HASH64K_ADJUST);
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: *dst_p++ = 255;
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_compress64kCtx_64,The following statement contains a magic number: lastRun > 254
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_len;  				byte* dst_cpy;    				var dst_LASTLITERALS = dst_end - LASTLITERALS;  				var dst_COPYLENGTH = dst_end - COPYLENGTH;  				var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);    				byte token;    				// Main Loop  				while (true)  				{  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						int len;  						for (; (len = *src_p++) == 255; length += 255)  						{  							/* do nothing */  						}  						length += len;  					}    					// copy literals  					dst_cpy = dst_p + length;    					if (dst_cpy > dst_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  						BlockCopy(src_p' dst_p' (length));  						src_p += length;  						break; // EOF  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) src_p++;  						length += *src_p++;  					}    					// copy repeated sequence  					if ((dst_p - dst_ref) < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					{  						do  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						} while (dst_p < dst_cpy);  					}  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)((src_p) - src);    				// write overflow error detected  			_output_error:  				return (int)(-((src_p) - src));  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,LZ4,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\LZ4.cs,LZ4_uncompress_unknownOutputSize_64,The following statement contains a magic number: fixed (int* dec64table = &DECODER_TABLE_64[0])  			{  				// r93  				var src_p = src;  				var src_end = src_p + src_len;  				byte* dst_ref;    				var dst_p = dst;  				var dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));  				var src_LASTLITERALS_1 = (src_end - (LASTLITERALS + 1));  				var dst_COPYLENGTH = (dst_end - COPYLENGTH);  				var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));  				var dst_LASTLITERALS = (dst_end - LASTLITERALS);  				var dst_MFLIMIT = (dst_end - MFLIMIT);    				// Special case  				if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0)    				// Main Loop  				while (true)  				{  					byte token;  					int length;    					// get runlength  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						var s = 255;  						while ((src_p < src_end) && (s == 255))  						{  							s = *src_p++;  							length += s;  						}  					}    					// copy literals  					dst_cpy = dst_p + length;    					if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  					{  						if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  						if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  						BlockCopy(src_p' dst_p' (length));  						dst_p += length;  						break; // Necessarily EOF' due to parsing restrictions  					}  					do  					{  						*(ulong*)dst_p = *(ulong*)src_p;  						dst_p += 8;  						src_p += 8;  					} while (dst_p < dst_cpy);  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;    					// get offset  					dst_ref = (dst_cpy) - (*(ushort*)(src_p));  					src_p += 2;  					if (dst_ref < dst) goto _output_error; // Error : offset outside of destination buffer    					// get matchlength  					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  						{  							int s = *src_p++;  							length += s;  							if (s == 255) continue;  							break;  						}  					}    					// copy repeated sequence  					if (dst_p - dst_ref < STEPSIZE_64)  					{  						var dec64 = dec64table[dst_p - dst_ref];    						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4;  						dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						(*(uint*)(dst_p)) = (*(uint*)(dst_ref));  						dst_p += STEPSIZE_64 - 4;  						dst_ref -= dec64;  					}  					else  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					}  					dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    					if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  					{  						if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  						while (dst_p < dst_COPYLENGTH)  						{  							*(ulong*)dst_p = *(ulong*)dst_ref;  							dst_p += 8;  							dst_ref += 8;  						}    						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						continue;  					}    					do  					{  						*(ulong*)dst_p = *(ulong*)dst_ref;  						dst_p += 8;  						dst_ref += 8;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy; // correction  				}    				// end of decoding  				return (int)(dst_p - dst);    			_output_error:    				// write overflow error detected  				return (int)-(src_p - src);  			}
Magic Number,Voron.Util,NativeFileMethods,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,SetFileLength,The following statement contains a magic number: var hi = (int)(length >> 32);
Magic Number,Voron.Util,NativeFileMethods,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,SetFileLength,The following statement contains a magic number: var filePath = new StringBuilder(256);
Magic Number,Voron.Util,NativeFileMethods,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,SetFileLength,The following statement contains a magic number: filePath.EnsureCapacity(filePath.Capacity*2);
Magic Number,Voron.Util,NativeFileMethods,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\NativeFileMethods.cs,SetFileLength,The following statement contains a magic number: GetFinalPathNameByHandle(fileHandle' filePath' filePath.Capacity' 0) > filePath.Capacity &&   						filePath.Capacity < 32767
Magic Number,Voron.Util,SkipList<TKey;TVal>,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\SkipList.cs,RandomHeight,The following statement contains a magic number: const int branching = 4;
Magic Number,Voron.Util,Utils,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Utils.cs,NearestPowerOfTwo,The following statement contains a magic number: v |= v >> 2;
Magic Number,Voron.Util,Utils,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Utils.cs,NearestPowerOfTwo,The following statement contains a magic number: v |= v >> 4;
Magic Number,Voron.Util,Utils,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Utils.cs,NearestPowerOfTwo,The following statement contains a magic number: v |= v >> 8;
Magic Number,Voron.Util,Utils,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Utils.cs,NearestPowerOfTwo,The following statement contains a magic number: v |= v >> 16;
Magic Number,Voron,StorageEnvironmentOptions,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxNumberOfPagesInJournalBeforeFlush = 1024;
Magic Number,Voron,StorageEnvironmentOptions,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: IdleFlushTimeout = 5000;
Magic Number,Voron,StorageEnvironmentOptions,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxLogFileSize = 64 * 1024 * 1024;
Magic Number,Voron,StorageEnvironmentOptions,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxLogFileSize = 64 * 1024 * 1024;
Magic Number,Voron,StorageEnvironmentOptions,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: MaxLogFileSize = 64 * 1024 * 1024;
Magic Number,Voron,StorageEnvironmentOptions,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: InitialLogFileSize = 64 * 1024;
Magic Number,Voron,StorageEnvironmentOptions,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironmentOptions.cs,StorageEnvironmentOptions,The following statement contains a magic number: InitialLogFileSize = 64 * 1024;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: const int p = 16777619;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: int hash = (int)2166136261;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: hash += hash << 13;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: hash ^= hash >> 7;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: hash += hash << 3;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: hash ^= hash >> 17;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashPointer,The following statement contains a magic number: hash += hash << 5;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: const int p = 16777619;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: int hash = (int) 2166136261;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: hash += hash << 13;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: hash ^= hash >> 7;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: hash += hash << 3;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: hash ^= hash >> 17;
Magic Number,Voron,Slice,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Slice.cs,ComputeHashArray,The following statement contains a magic number: hash += hash << 5;
Magic Number,Voron,StorageEnvironment,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,NewTransaction,The following statement contains a magic number: var wait = timeout ?? (Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30));
Magic Number,Voron,StorageEnvironment,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\StorageEnvironment.cs,NewTransaction,The following statement contains a magic number: var wait = timeout ?? (Debugger.IsAttached ? TimeSpan.FromMinutes(30) : TimeSpan.FromSeconds(30));
Magic Number,Voron,ValueReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\ValueReader.cs,CopyTo,The following statement contains a magic number: var buffer = new byte[4096];
Magic Number,Voron.Impl.FileHeaders,HeaderAccessor,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FileHeaders\HeaderAccessor.cs,Initialize,The following statement contains a magic number: var headers = stackalloc FileHeader[2];
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,FirstSetBit,The following statement contains a magic number: return i << 5 | HighestBitSet(_inner[i]);
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 2;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 4;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 8;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: v |= v >> 16;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HighestBitSet,The following statement contains a magic number: return MultiplyDeBruijnBitPosition[(uint)(v * 0x07C4ACDDU) >> 27];
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,Get,The following statement contains a magic number: return (_inner[index >> 5] & (1 << (index & 31))) != 0;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,Get,The following statement contains a magic number: return (_inner[index >> 5] & (1 << (index & 31))) != 0;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,Set,The following statement contains a magic number: _inner[index >> 5] |= (1 << (index & 31));
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,Set,The following statement contains a magic number: _inner[index >> 5] |= (1 << (index & 31));
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,HasStartRangeCount,The following statement contains a magic number: var len = _inner.Length*32;
Magic Number,Voron.Impl.FreeSpace,StreamBitArray,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\FreeSpace\StreamBitArray.cs,ToStream,The following statement contains a magic number: var ms = new MemoryStream(260);
Magic Number,Voron.Trees,PageSplitter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\PageSplitter.cs,SplitPageInHalf,The following statement contains a magic number: int splitIndex = _page.NumberOfEntries/2;
Magic Number,Voron.Trees,PageSplitter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\PageSplitter.cs,AdjustSplitPosition,The following statement contains a magic number: page.NumberOfEntries >= 20 && nodeSize <= AbstractPager.PageMaxSpace/16
Magic Number,Voron.Trees,PageSplitter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\PageSplitter.cs,AdjustSplitPosition,The following statement contains a magic number: page.NumberOfEntries >= 20 && nodeSize <= AbstractPager.PageMaxSpace/16
Magic Number,Voron.Trees,TreeRebalancer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,Execute,The following statement contains a magic number: parentPage.LastSearchPosition == 0 && parentPage.NumberOfEntries > 2
Magic Number,Voron.Trees,TreeRebalancer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,Execute,The following statement contains a magic number: var minKeys = page.IsBranch ? 2 : 1;
Magic Number,Voron.Trees,TreeRebalancer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,Execute,The following statement contains a magic number: Debug.Assert(parentPage.NumberOfEntries >= 2);
Magic Number,Voron.Trees,TreeRebalancer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,Execute,The following statement contains a magic number: minKeys = sibling.IsBranch ? 2 : 1;
Magic Number,Voron.Trees,TreeRebalancer,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Trees\TreeRebalancer.cs,MoveBranchNode,The following statement contains a magic number: Debug.Assert(from.NumberOfEntries >= 2);
Magic Number,Voron.Util.Conversion,BigEndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\BigEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: value = value >> 8;
Magic Number,Voron.Util.Conversion,BigEndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\BigEndianBitConverter.cs,FromBytes,The following statement contains a magic number: ret = unchecked((ret << 8) | buffer[startIndex+i]);
Magic Number,Voron.Util.Conversion,LittleEndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\LittleEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: value = value >> 8;
Magic Number,Voron.Util.Conversion,LittleEndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\LittleEndianBitConverter.cs,FromBytes,The following statement contains a magic number: ret = unchecked((ret << 8) | buffer[startIndex+bytesToConvert-1-i]);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToChar,The following statement contains a magic number: return unchecked((char) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToInt16,The following statement contains a magic number: return unchecked((short) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToInt32,The following statement contains a magic number: return unchecked((int) (CheckedFromBytes(value' startIndex' 4)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToInt64,The following statement contains a magic number: return CheckedFromBytes(value' startIndex' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToUInt16,The following statement contains a magic number: return unchecked((ushort) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return unchecked((uint) (CheckedFromBytes(value' startIndex' 4)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return unchecked((ulong) (CheckedFromBytes(value' startIndex' 8)));
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: int[] parts = new int[4];
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: parts[i] = ToInt32(value' startIndex+i*4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: i < 4
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: byte[] bytes = new byte[16];
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: CopyBytesImpl(parts[i]' 4' bytes' i*4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: CopyBytesImpl(parts[i]' 4' bytes' i*4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: i < 4
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytesImpl(parts[i]' 4' buffer' i*4+index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytesImpl(parts[i]' 4' buffer' i*4+index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: i < 4
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(DoubleToInt64Bits(value)' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(SingleToInt32Bits(value)' 4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 4);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(unchecked((long)value)' 8);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(DoubleToInt64Bits(value)' 8' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 4' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 8' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(SingleToInt32Bits(value)' 4' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 4' buffer' index);
Magic Number,Voron.Util.Conversion,EndianBitConverter,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Util\Conversion\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(unchecked((long)value)' 8' buffer' index);
Missing Default,Voron.Impl,SnapshotReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\SnapshotReader.cs,Read,The following switch statement is missing a default case: switch (operationType)  					{  						case WriteBatch.BatchOperationType.Add:  					    {  					        var reader = new ValueReader(stream);  					        return new ReadResult(reader' version.HasValue ? (ushort)(version.Value + 1) : tree.ReadVersion(Transaction' key));  					    }  						case WriteBatch.BatchOperationType.Delete:  							return null;  					}
Missing Default,Voron.Impl,SnapshotReader,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\SnapshotReader.cs,ReadVersion,The following switch statement is missing a default case: switch (operationType)  					{  						case WriteBatch.BatchOperationType.Add:  						case WriteBatch.BatchOperationType.Delete:  					        return (ushort)(version.Value + 1);  					}
Missing Default,Voron.Impl.Journal,UnmanagedVectorMemoryStream,D:\research\architectureSmells\repos\ayende_raven.voron\Voron\Impl\Journal\WriteAheadJournal.cs,Seek,The following switch statement is missing a default case: switch (origin)  			{  					case SeekOrigin.Current:  						if (Position + offset > Length)  							throw new ArgumentOutOfRangeException("offset");  						Position += offset;  						break;  					case SeekOrigin.Begin:  						if(offset > Length || offset < 0)  							throw new ArgumentOutOfRangeException("offset");  						Position = offset;  						break;  					case SeekOrigin.End:  						if(offset > Length)  							throw new ArgumentOutOfRangeException("offset");  						Position = Length - offset;  						break;  			}
