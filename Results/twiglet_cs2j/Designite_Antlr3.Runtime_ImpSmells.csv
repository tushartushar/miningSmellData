Implementation smell,Namespace,Class,File,Method,Description
Long Method,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The method has 158 lines of code.
Long Method,Antlr.Runtime,DFA,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\DFA.cs,Predict,The method has 100 lines of code.
Complex Method,Antlr.Runtime.Tree,BufferedTreeNodeStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\BufferedTreeNodeStream.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,Antlr.Runtime.Tree,BaseTree,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\BaseTree.cs,AddChild,Cyclomatic complexity of the method is 8
Complex Method,Antlr.Runtime.Tree,BaseTree,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\BaseTree.cs,ReplaceChildren,Cyclomatic complexity of the method is 10
Complex Method,Antlr.Runtime.Tree,TreeWizard,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreeWizard.cs,ParseCore,Cyclomatic complexity of the method is 9
Complex Method,Antlr.Runtime.Tree,TreePatternLexer,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreePatternLexer.cs,NextToken,Cyclomatic complexity of the method is 14
Complex Method,Antlr.Runtime.Tree,TreePatternParser,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreePatternParser.cs,ParseNode,Cyclomatic complexity of the method is 12
Complex Method,Antlr.Runtime,BufferedTokenStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\BufferedTokenStream.cs,GetTokens,Cyclomatic complexity of the method is 8
Complex Method,Antlr.Runtime,LegacyCommonTokenStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\LegacyCommonTokenStream.cs,GetTokens,Cyclomatic complexity of the method is 8
Complex Method,Antlr.Runtime,DFA,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\DFA.cs,Predict,Cyclomatic complexity of the method is 20
Complex Method,Antlr.Runtime,TokenRewriteStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\TokenRewriteStream.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,Antlr.Runtime,TokenRewriteStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\TokenRewriteStream.cs,ReduceToSingleOperationPerIndex,Cyclomatic complexity of the method is 20
Long Parameter List,Antlr.Runtime.Debug,ProxyToken,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,ProxyToken,The method has 6 parameters. Parameters: index' type' channel' line' charPos' text
Long Parameter List,Antlr.Runtime.Debug,ProxyTree,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,ProxyTree,The method has 6 parameters. Parameters: ID' type' line' charPos' tokenIndex' text
Long Parameter List,Antlr.Runtime.JavaExtensions,Check,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.JavaExtensions\Check.cs,JoinSelectors,The method has 5 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,Antlr.Runtime.Tree,TreeWizard,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreeWizard.cs,VisitCore,The method has 5 parameters. Parameters: t' parent' childIndex' ttype' visitor
Long Parameter List,Antlr.Runtime,CommonToken,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\CommonToken.cs,CommonToken,The method has 5 parameters. Parameters: input' type' channel' start' stop
Long Identifier,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,,The length of the parameter _maxLookaheadInCurrentDecision is 30.
Long Statement,Antlr.Runtime.Debug,DebugEventSocketProxy,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\DebugEventSocketProxy.cs,EndBacktrack,The length of the statement  "            Transmit("endBacktrack\t" + level + "\t" + (successful ? DebugEventListenerConstants.True : DebugEventListenerConstants.False)); " is 128.
Long Statement,Antlr.Runtime.JavaExtensions,EnumerableExtensions,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.JavaExtensions\EnumerableExtensions.cs,Average,The length of the statement  "            return Average<int' long' double>(source' delegate(long a' int b) { return a + b; }' delegate(long a' long b) { return (double)a / (double)b; }); " is 145.
Long Statement,Antlr.Runtime.JavaExtensions,EnumerableExtensions,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.JavaExtensions\EnumerableExtensions.cs,Average,The length of the statement  "            return Average<double' double' double>(source' delegate(double a' double b) { return a + b; }' delegate(double a' long b) { return a / b; }); " is 141.
Long Statement,Antlr.Runtime,CommonToken,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\CommonToken.cs,ToString,The length of the statement  "			return "[@" + TokenIndex + "'" + start + ":" + stop + "='" + txt + "''<" + type + ">" + channelStr + "'" + line + ":" + CharPositionInLine + "]"; " is 145.
Long Statement,Antlr.Runtime,DFA,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\DFA.cs,Predict,The length of the statement  "						Console.Error.WriteLine("DFA " + decisionNumber + " state " + s + " LA(1)=" + (char)input.LA(1) + "(" + input.LA(1) + ")' index="+input.Index); " is 143.
Long Statement,Antlr.Runtime,MismatchedTokenException,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\MismatchedTokenException.cs,ToString,The length of the statement  "            string unexpected = (tokenNames != null && unexpectedType >= 0 && unexpectedType < tokenNames.Length) ? tokenNames[unexpectedType] : unexpectedType.ToString(); " is 159.
Long Statement,Antlr.Runtime,MismatchedTokenException,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\MismatchedTokenException.cs,ToString,The length of the statement  "            string expected = (tokenNames != null && expecting >= 0 && expecting < tokenNames.Length) ? tokenNames[expecting] : expecting.ToString(); " is 137.
Long Statement,Antlr.Runtime,UnwantedTokenException,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\UnwantedTokenException.cs,ToString,The length of the statement  "            //string unexpected = ( tokenNames != null && unexpectedType >= 0 && unexpectedType < tokenNames.Length ) ? tokenNames[unexpectedType] : unexpectedType.ToString(); " is 163.
Long Statement,Antlr.Runtime,UnwantedTokenException,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\UnwantedTokenException.cs,ToString,The length of the statement  "            string expected = (tokenNames != null && expecting >= 0 && expecting < tokenNames.Length) ? tokenNames[expecting] : expecting.ToString(); " is 137.
Long Statement,Antlr.Runtime,Lexer,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\Lexer.cs,NextToken,The length of the statement  "                    IToken eof = new CommonToken((ICharStream)input' CharStreamConstants.EndOfFile' TokenChannels.Default' input.Index' input.Index); " is 129.
Complex Conditional,Antlr.Runtime.Tree,TreePatternLexer,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreePatternLexer.cs,NextToken,The conditional expression  "c == ' ' || c == '\n' || c == '\r' || c == '\t'"  is complex.
Complex Conditional,Antlr.Runtime.Tree,TreePatternLexer,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreePatternLexer.cs,NextToken,The conditional expression  "(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_'"  is complex.
Complex Conditional,Antlr.Runtime.Tree,TreePatternLexer,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreePatternLexer.cs,NextToken,The conditional expression  "(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||  							(c >= '0' && c <= '9') || c == '_'"  is complex.
Complex Conditional,Antlr.Runtime.Tree,TreePatternParser,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreePatternParser.cs,ParseTree,The conditional expression  "ttype == TreePatternLexer.BEGIN ||  					ttype == TreePatternLexer.ID ||  					ttype == TreePatternLexer.PERCENT ||  					ttype == TreePatternLexer.DOT"  is complex.
Complex Conditional,Antlr.Runtime,TokenRewriteStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\TokenRewriteStream.cs,Replace,The conditional expression  "from > to || from < 0 || to < 0 || to >= _tokens.Count"  is complex.
Virtual Method Call from Constructor,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,RemoteDebugEventSocketListener,The constructor "RemoteDebugEventSocketListener" calls a virtual method "OpenConnection".
Virtual Method Call from Constructor,Antlr.Runtime.Debug,ParseTreeBuilder,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\ParseTreeBuilder.cs,ParseTreeBuilder,The constructor "ParseTreeBuilder" calls a virtual method "Create".
Virtual Method Call from Constructor,Antlr.Runtime.Tree,TreeParser,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreeParser.cs,TreeParser,The constructor "TreeParser" calls a virtual method "SetTreeNodeStream".
Virtual Method Call from Constructor,Antlr.Runtime.Tree,TreeParser,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreeParser.cs,TreeParser,The constructor "TreeParser" calls a virtual method "SetTreeNodeStream".
Virtual Method Call from Constructor,Antlr.Runtime.Tree,TreeWizard,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreeWizard.cs,TreeWizard,The constructor "TreeWizard" calls a virtual method "ComputeTokenTypes".
Virtual Method Call from Constructor,Antlr.Runtime.Tree,RewriteRuleElementStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\RewriteRuleElementStream.cs,RewriteRuleElementStream,The constructor "RewriteRuleElementStream" calls a virtual method "Add".
Virtual Method Call from Constructor,Antlr.Runtime,ANTLRFileStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\ANTLRFileStream.cs,ANTLRFileStream,The constructor "ANTLRFileStream" calls a virtual method "Load".
Virtual Method Call from Constructor,Antlr.Runtime,ANTLRInputStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\ANTLRInputStream.cs,ANTLRInputStream,The constructor "ANTLRInputStream" calls a virtual method "Load".
Virtual Method Call from Constructor,Antlr.Runtime,ANTLRReaderStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\ANTLRReaderStream.cs,ANTLRReaderStream,The constructor "ANTLRReaderStream" calls a virtual method "Load".
Virtual Method Call from Constructor,Antlr.Runtime,BaseRecognizer,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\BaseRecognizer.cs,BaseRecognizer,The constructor "BaseRecognizer" calls a virtual method "InitDFAs".
Empty Catch Block,Antlr.Runtime.Tree,TreeFilter,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\TreeFilter.cs,ApplyOnce,The method has an empty catch block.
Magic Number,Antlr.Runtime.Debug,DebugEventSocketProxy,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\DebugEventSocketProxy.cs,RecognitionException,The following statement contains a magic number: StringBuilder buf = new StringBuilder(50);
Magic Number,Antlr.Runtime.Debug,DebugEventSocketProxy,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\DebugEventSocketProxy.cs,SemanticPredicate,The following statement contains a magic number: StringBuilder buf = new StringBuilder(50);
Magic Number,Antlr.Runtime.Debug,DebugEventSocketProxy,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\DebugEventSocketProxy.cs,ConsumeNode,The following statement contains a magic number: StringBuilder buf = new StringBuilder(50);
Magic Number,Antlr.Runtime.Debug,DebugEventSocketProxy,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\DebugEventSocketProxy.cs,LT,The following statement contains a magic number: StringBuilder buf = new StringBuilder(50);
Magic Number,Antlr.Runtime.Debug,DebugEventSocketProxy,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\DebugEventSocketProxy.cs,ErrorNode,The following statement contains a magic number: StringBuilder buf = new StringBuilder(50);
Magic Number,Antlr.Runtime.Debug,DebugEventSocketProxy,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\DebugEventSocketProxy.cs,CreateNode,The following statement contains a magic number: StringBuilder buf = new StringBuilder(50);
Magic Number,Antlr.Runtime.Debug,DebugEventSocketProxy,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\DebugEventSocketProxy.cs,SerializeToken,The following statement contains a magic number: StringBuilder buf = new StringBuilder(50);
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,Dispatch,The following statement contains a magic number: if (elements[0].Equals("enterRule")) {                  listener.EnterRule(elements[1]' elements[2]);              } else if (elements[0].Equals("exitRule")) {                  listener.ExitRule(elements[1]' elements[2]);              } else if (elements[0].Equals("enterAlt")) {                  listener.EnterAlt(int.Parse(elements[1]));              } else if (elements[0].Equals("enterSubRule")) {                  listener.EnterSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("exitSubRule")) {                  listener.ExitSubRule(int.Parse(elements[1]));              } else if (elements[0].Equals("enterDecision")) {                  listener.EnterDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("exitDecision")) {                  listener.ExitDecision(int.Parse(elements[1]));              } else if (elements[0].Equals("location")) {                  listener.Location(int.Parse(elements[1])'                                    int.Parse(elements[2]));              } else if (elements[0].Equals("consumeToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeToken(t);              } else if (elements[0].Equals("consumeHiddenToken")) {                  ProxyToken t = DeserializeToken(elements' 1);                  if (t.TokenIndex == previousTokenIndex) {                      tokenIndexesInvalid = true;                  }                  previousTokenIndex = t.TokenIndex;                  listener.ConsumeHiddenToken(t);              } else if (elements[0].Equals("LT")) {                  IToken t = DeserializeToken(elements' 2);                  listener.LT(int.Parse(elements[1])' t);              } else if (elements[0].Equals("mark")) {                  listener.Mark(int.Parse(elements[1]));              } else if (elements[0].Equals("rewind")) {                  if (elements[1] != null) {                      listener.Rewind(int.Parse(elements[1]));                  } else {                      listener.Rewind();                  }              } else if (elements[0].Equals("beginBacktrack")) {                  listener.BeginBacktrack(int.Parse(elements[1]));              } else if (elements[0].Equals("endBacktrack")) {                  int level = int.Parse(elements[1]);                  int successI = int.Parse(elements[2]);                  listener.EndBacktrack(level' successI == DebugEventListenerConstants.True);              } else if (elements[0].Equals("exception")) {  #if true                  throw new System.NotImplementedException();  #else                  string excName = elements[1];                  string indexS = elements[2];                  string lineS = elements[3];                  string posS = elements[4];                  Class excClass = null;                  try                  {                      excClass = Class.forName( excName );                      RecognitionException e =                          (RecognitionException)excClass.newInstance();                      e.index = int.Parse( indexS );                      e.line = int.Parse( lineS );                      e.charPositionInLine = int.Parse( posS );                      listener.recognitionException( e );                  }                  catch ( ClassNotFoundException cnfe )                  {                      Console.Error.println( "can't find class " + cnfe );                      cnfe.printStackTrace( Console.Error );                  }                  catch ( InstantiationException ie )                  {                      Console.Error.println( "can't instantiate class " + ie );                      ie.printStackTrace( Console.Error );                  }                  catch ( IllegalAccessException iae )                  {                      Console.Error.println( "can't access class " + iae );                      iae.printStackTrace( Console.Error );                  }  #endif              } else if (elements[0].Equals("beginResync")) {                  listener.BeginResync();              } else if (elements[0].Equals("endResync")) {                  listener.EndResync();              } else if (elements[0].Equals("terminate")) {                  listener.Terminate();              } else if (elements[0].Equals("semanticPredicate")) {                  bool result = bool.Parse(elements[1]);                  string predicateText = elements[2];                  predicateText = UnEscapeNewlines(predicateText);                  listener.SemanticPredicate(result'                                             predicateText);              } else if (elements[0].Equals("consumeNode")) {                  ProxyTree node = DeserializeNode(elements' 1);                  listener.ConsumeNode(node);              } else if (elements[0].Equals("LN")) {                  int i = int.Parse(elements[1]);                  ProxyTree node = DeserializeNode(elements' 2);                  listener.LT(i' node);              } else if (elements[0].Equals("createNodeFromTokenElements")) {                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.CreateNode(node);              } else if (elements[0].Equals("createNode")) {                  int ID = int.Parse(elements[1]);                  int tokenIndex = int.Parse(elements[2]);                  // create dummy node/token filled with ID' tokenIndex                  ProxyTree node = new ProxyTree(ID);                  ProxyToken token = new ProxyToken(tokenIndex);                  listener.CreateNode(node' token);              } else if (elements[0].Equals("nilNode")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.NilNode(node);              } else if (elements[0].Equals("errorNode")) {                  // TODO: do we need a special tree here?                  int ID = int.Parse(elements[1]);                  int type = int.Parse(elements[2]);                  string text = elements[3];                  text = UnEscapeNewlines(text);                  ProxyTree node = new ProxyTree(ID' type' -1' -1' -1' text);                  listener.ErrorNode(node);              } else if (elements[0].Equals("becomeRoot")) {                  int newRootID = int.Parse(elements[1]);                  int oldRootID = int.Parse(elements[2]);                  ProxyTree newRoot = new ProxyTree(newRootID);                  ProxyTree oldRoot = new ProxyTree(oldRootID);                  listener.BecomeRoot(newRoot' oldRoot);              } else if (elements[0].Equals("addChild")) {                  int rootID = int.Parse(elements[1]);                  int childID = int.Parse(elements[2]);                  ProxyTree root = new ProxyTree(rootID);                  ProxyTree child = new ProxyTree(childID);                  listener.AddChild(root' child);              } else if (elements[0].Equals("setTokenBoundaries")) {                  int ID = int.Parse(elements[1]);                  ProxyTree node = new ProxyTree(ID);                  listener.SetTokenBoundaries(                      node'                      int.Parse(elements[2])'                      int.Parse(elements[3]));              } else {                  Console.Error.WriteLine("unknown debug event: " + line);              }
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,DeserializeNode,The following statement contains a magic number: int tokenLine = int.Parse(elements[offset + 2]);
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,DeserializeNode,The following statement contains a magic number: int charPositionInLine = int.Parse(elements[offset + 3]);
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,DeserializeNode,The following statement contains a magic number: int tokenIndex = int.Parse(elements[offset + 4]);
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,DeserializeNode,The following statement contains a magic number: string text = elements[offset + 5];
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,DeserializeToken,The following statement contains a magic number: string channelS = elements[offset + 2];
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,DeserializeToken,The following statement contains a magic number: string lineS = elements[offset + 3];
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,DeserializeToken,The following statement contains a magic number: string posS = elements[offset + 4];
Magic Number,Antlr.Runtime.Debug,RemoteDebugEventSocketListener,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\RemoteDebugEventSocketListener.cs,DeserializeToken,The following statement contains a magic number: string text = elements[offset + 5];
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ExitDecision,The following statement contains a magic number: if (_parser.isCyclicDecision) {                  if (numCyclicDecisions >= decisionMaxCyclicLookaheads.Length) {                      Array.Resize(ref decisionMaxCyclicLookaheads' decisionMaxCyclicLookaheads.Length * 2);                  }                  decisionMaxCyclicLookaheads[numCyclicDecisions - 1] = _maxLookaheadInCurrentDecision;              } else {                  if (numFixedDecisions >= decisionMaxFixedLookaheads.Length) {                      Array.Resize(ref decisionMaxFixedLookaheads' decisionMaxFixedLookaheads.Length * 2);                  }                  decisionMaxFixedLookaheads[numFixedDecisions - 1] = _maxLookaheadInCurrentDecision;              }
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ExitDecision,The following statement contains a magic number: if (_parser.isCyclicDecision) {                  if (numCyclicDecisions >= decisionMaxCyclicLookaheads.Length) {                      Array.Resize(ref decisionMaxCyclicLookaheads' decisionMaxCyclicLookaheads.Length * 2);                  }                  decisionMaxCyclicLookaheads[numCyclicDecisions - 1] = _maxLookaheadInCurrentDecision;              } else {                  if (numFixedDecisions >= decisionMaxFixedLookaheads.Length) {                      Array.Resize(ref decisionMaxFixedLookaheads' decisionMaxFixedLookaheads.Length * 2);                  }                  decisionMaxFixedLookaheads[numFixedDecisions - 1] = _maxLookaheadInCurrentDecision;              }
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[2]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[27]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[3]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[4]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[5]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[6]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[7]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[8]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[9]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[10]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[11]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[12]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[13]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[14]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[15]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[16]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[17]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[18]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[28]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[25]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[26]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[19]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[20]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[21]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[22]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[23]);
Magic Number,Antlr.Runtime.Debug,Profiler,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Debug\Profiler.cs,ToString,The following statement contains a magic number: buf.Append(fields[24]);
Magic Number,Antlr.Runtime.Tree,BufferedTreeNodeStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\BufferedTreeNodeStream.cs,ToString,The following statement contains a magic number: if (tokens != null) {                  int beginTokenIndex = adaptor.GetTokenStartIndex(start);                  int endTokenIndex = adaptor.GetTokenStopIndex(stop);                  // if it's a tree' use start/stop index from start node                  // else use token range from start/stop nodes                  if (adaptor.GetType(stop) == TokenTypes.Up) {                      endTokenIndex = adaptor.GetTokenStopIndex(start);                  } else if (adaptor.GetType(stop) == TokenTypes.EndOfFile) {                      endTokenIndex = Count - 2; // don't use EOF                  }                  return tokens.ToString(beginTokenIndex' endTokenIndex);              }
Magic Number,Antlr.Runtime.Tree,RewriteRuleElementStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime.Tree\RewriteRuleElementStream.cs,Add,The following statement contains a magic number: elements = new ArrayList(5);
Magic Number,Antlr.Runtime,LegacyCommonTokenStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\LegacyCommonTokenStream.cs,LegacyCommonTokenStream,The following statement contains a magic number: tokens = new List<IToken>(500);
Magic Number,Antlr.Runtime,DFA,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\DFA.cs,UnpackEncodedString,The following statement contains a magic number: for ( int i = 0; i < encodedString.Length; i += 2 )                  size += (int)encodedString[i];
Magic Number,Antlr.Runtime,DFA,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\DFA.cs,UnpackEncodedString,The following statement contains a magic number: for ( int i = 0; i < encodedString.Length; i += 2 )              {                  char n = encodedString[i];                  char v = encodedString[i+1];                  // add v n times to data                  for ( int j = 1; j <= n; j++ )                      data[di++] = (short)v;              }
Magic Number,Antlr.Runtime,DFA,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\DFA.cs,UnpackEncodedStringToUnsignedChars,The following statement contains a magic number: for ( int i = 0; i < encodedString.Length; i += 2 )                  size += (int)encodedString[i];
Magic Number,Antlr.Runtime,DFA,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\DFA.cs,UnpackEncodedStringToUnsignedChars,The following statement contains a magic number: for ( int i = 0; i < encodedString.Length; i += 2 )              {                  char n = encodedString[i];                  char v = encodedString[i+1];                  // add v n times to data                  for ( int j = 1; j <= n; j++ )                      data[di++] = v;              }
Magic Number,Antlr.Runtime,ANTLRReaderStream,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\ANTLRReaderStream.cs,Load,The following statement contains a magic number: try  			{  				// alloc initial buffer size.  				data = new char[size];  				// read all the data in chunks of readChunkSize  				int numRead = 0;  				int p = 0;  				do  				{  					if (p + readChunkSize > data.Length)  					{ // overflow?  						char[] newdata = new char[data.Length * 2]; // resize  						Array.Copy(data' 0' newdata' 0' data.Length);  						data = newdata;  					}  					numRead = reader.Read(data' p' readChunkSize);  					p += numRead;  				} while (numRead != 0); // while not EOF  				// set the actual size of the data available;  				// EOF subtracted one above in p+=numRead; add one back  				//n = p + 1;  				n = p;  			}  			finally  			{  				reader.Close();  			}
Magic Number,Antlr.Runtime,BaseRecognizer,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\BaseRecognizer.cs,MismatchIsUnwantedToken,The following statement contains a magic number: return input.LA(2) == ttype;
Magic Number,Antlr.Runtime,BaseRecognizer,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\BaseRecognizer.cs,PushFollow,The following statement contains a magic number: if ((state._fsp + 1) >= state.following.Length) {                  Array.Resize(ref state.following' state.following.Length * 2);              }
Missing Default,Antlr.Runtime,Lexer,C:\repos\twiglet_cs2j\CSharpTranslator\src\Antlr.Runtime\Antlr.Runtime\Lexer.cs,GetCharErrorDisplay,The following switch statement is missing a default case: switch (c) {                  case TokenTypes.EndOfFile:                      s = "<EOF>";                      break;                  case '\n':                      s = "\\n";                      break;                  case '\t':                      s = "\\t";                      break;                  case '\r':                      s = "\\r";                      break;              }
