Implementation smell,Namespace,Class,File,Method,Description
Long Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileExpression,The method has 239 lines of code.
Long Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCall,The method has 139 lines of code.
Long Method,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,ProcessMethodDecencies,The method has 119 lines of code.
Long Method,CIL2Java,InterMethod,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\InterMethod.cs,InterMethod,The method has 169 lines of code.
Long Method,CIL2Java,InterType,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\InterType.cs,InterType,The method has 139 lines of code.
Long Method,CIL2Java,StackSimulator,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\StackSimulator.cs,SimulateStack,The method has 117 lines of code.
Long Method,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The method has 123 lines of code.
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileNode,Cyclomatic complexity of the method is 9
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCondition,Cyclomatic complexity of the method is 10
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileExpression,Cyclomatic complexity of the method is 150
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GenerateDebugInfo,Cyclomatic complexity of the method is 26
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GenerateMethodPointerClass,Cyclomatic complexity of the method is 11
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,TranslateType,Cyclomatic complexity of the method is 10
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,PreprocessorFindAndMoveSuperOrThisCalls,Cyclomatic complexity of the method is 9
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,PreprocessorFindDefaultCtorCallInValueTypeCtor,Cyclomatic complexity of the method is 8
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,PreprocessorCheckUninitializedLocalVarsExpression,Cyclomatic complexity of the method is 8
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,PreprocessorCheckUninitializedLocalVarsBranch,Cyclomatic complexity of the method is 14
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GenerateMethodProlog,Cyclomatic complexity of the method is 10
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileNewarr,Cyclomatic complexity of the method is 9
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileStelem,Cyclomatic complexity of the method is 10
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdelem,Cyclomatic complexity of the method is 13
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCall,Cyclomatic complexity of the method is 31
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileRet,Cyclomatic complexity of the method is 8
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileJmp,Cyclomatic complexity of the method is 11
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdcI4,Cyclomatic complexity of the method is 10
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileConvTo1,Cyclomatic complexity of the method is 10
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileConvTo2,Cyclomatic complexity of the method is 10
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileConvTo4,Cyclomatic complexity of the method is 8
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileConvTo8,Cyclomatic complexity of the method is 8
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCondition,Cyclomatic complexity of the method is 13
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileFlowB,Cyclomatic complexity of the method is 10
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileFlowC,Cyclomatic complexity of the method is 9
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileMath,Cyclomatic complexity of the method is 15
Complex Method,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GetSize,Cyclomatic complexity of the method is 12
Complex Method,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,AddTypeDefinitionToCompile,Cyclomatic complexity of the method is 8
Complex Method,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,PrecompilePass,Cyclomatic complexity of the method is 14
Complex Method,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,CompileField,Cyclomatic complexity of the method is 22
Complex Method,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,ProcessMethodDecencies,Cyclomatic complexity of the method is 42
Complex Method,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,Resolve,Cyclomatic complexity of the method is 22
Complex Method,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,CompileMethod,Cyclomatic complexity of the method is 13
Complex Method,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,ComplileType,Cyclomatic complexity of the method is 16
Complex Method,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,GenerateValueTypeEquals,Cyclomatic complexity of the method is 8
Complex Method,CIL2Java,JavaByRefType,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler\Compiler.ByRef.cs,ToString,Cyclomatic complexity of the method is 11
Complex Method,CIL2Java,InterField,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\InterField.cs,InterField,Cyclomatic complexity of the method is 8
Complex Method,CIL2Java,InterMethod,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\InterMethod.cs,InterMethod,Cyclomatic complexity of the method is 37
Complex Method,CIL2Java,InterType,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\InterType.cs,InterType,Cyclomatic complexity of the method is 27
Complex Method,CIL2Java,InterType,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\InterType.cs,CheckOverloadingMethods,Cyclomatic complexity of the method is 17
Complex Method,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass1,Cyclomatic complexity of the method is 11
Complex Method,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,Cyclomatic complexity of the method is 19
Complex Method,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,AddArrayStore,Cyclomatic complexity of the method is 8
Complex Method,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,AddArrayLoad,Cyclomatic complexity of the method is 8
Complex Method,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,AddIntConst,Cyclomatic complexity of the method is 10
Complex Method,CIL2Java,JavaHelpers,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaHelpers.cs,JavaPrimitiveToArrayType,Cyclomatic complexity of the method is 10
Complex Method,CIL2Java,Program,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Program.cs,ParseCommandLine,Cyclomatic complexity of the method is 24
Complex Method,CIL2Java,StackSimulator,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\StackSimulator.cs,SimulateStack,Cyclomatic complexity of the method is 29
Complex Method,CIL2Java,Utils,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Utils.cs,GetJavaTypeName,Cyclomatic complexity of the method is 8
Complex Method,CIL2Java.Java,ElementValue,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Annotation.cs,Read,Cyclomatic complexity of the method is 14
Complex Method,CIL2Java.Java,Attribute,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attribute.cs,ReadAttribute,Cyclomatic complexity of the method is 16
Complex Method,CIL2Java.Java,ConstantPoolReader,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\ConstantPoolReader.cs,Read,Cyclomatic complexity of the method is 18
Complex Method,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,Cyclomatic complexity of the method is 21
Complex Method,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Dump,Cyclomatic complexity of the method is 10
Complex Method,CIL2Java.Java.Attributes,RuntimeParameterAnnotations,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\RuntimeVisibleParameterAnnotations.cs,GetParametersCount,Cyclomatic complexity of the method is 9
Long Parameter List,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CodeCompiler,The method has 5 parameters. Parameters: resolver' namesController' byRefController' method' constsPool
Long Parameter List,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCheckOvf,The method has 5 parameters. Parameters: e' from' mask' minValue' maxValue
Long Parameter List,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileFlowB,The method has 5 parameters. Parameters: e' intBr' refBr' otherBr' unsigned
Long Parameter List,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileFlowC,The method has 5 parameters. Parameters: e' IntCmp' RefCmp' OtherCmp' unsigned
Long Parameter List,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileMath,The method has 6 parameters. Parameters: e' expect' intOp' longOp' floatOp' doubleOp
Long Parameter List,CIL2Java,InterParameter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\InterParameter.cs,InterParameter,The method has 5 parameters. Parameters: index' type' name' isBoxed' isJavaBoxed
Long Parameter List,CIL2Java.Java,JavaInstructionDescption,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\ByteCode.cs,JavaInstructionDescption,The method has 5 parameters. Parameters: Size' PushAction' PopAction' OpType' BranchType
Long Identifier,CIL2Java,ClassNames,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\ClassNames.cs,,The length of the parameter JavaBoxedInterfacesMapAttribute is 31.
Long Identifier,CIL2Java,ClassNames,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\ClassNames.cs,,The length of the parameter InterfacesMapGetAdapterMethodName is 33.
Long Identifier,CIL2Java,ClassNames,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\ClassNames.cs,,The length of the parameter ArraysInterfaceAdapterTypeName is 30.
Long Identifier,CIL2Java,ClassNames,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\ClassNames.cs,,The length of the parameter DelegateRunnerParamFieldNamePrefix is 34.
Long Identifier,CIL2Java,JavaHelpers,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaHelpers.cs,,The length of the parameter PrimitiveTypeToJavaPrimitiveWorkingArray is 40.
Long Statement,CIL2Java,BinaryReaderBigEndian,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BinaryReaderBigEndian.cs,ReadBytesRequired,The length of the statement  "                throw new EndOfStreamException(string.Format("{0} bytes required from stream' but only {1} returned."' byteCount' result.Length)); " is 130.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,Compile,The length of the statement  "            DecompilerContext context = new DecompilerContext(methodDef.Module) { CurrentType = methodDef.DeclaringType' CurrentMethod = methodDef }; " is 137.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileTryBlock,The length of the statement  "                    int varIndex = GetVarIndex(cblock.ExceptionVariable ?? new ILVariable { Name = "tmp_Exception"' Type = cblock.ExceptionType' IsGenerated = true }); " is 147.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,PreprocessorCheckUninitializedLocalVarsBranch,The length of the statement  "                    if (block.TryBlock != null) newResult = newResult.Union(PreprocessorCheckUninitializedLocalVarsBranch(block.TryBlock' result)).ToList(); " is 136.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,PreprocessorCheckUninitializedLocalVarsBranch,The length of the statement  "                    if (block.FaultBlock != null) newResult = newResult.Union(PreprocessorCheckUninitializedLocalVarsBranch(block.FaultBlock' result)).ToList(); " is 140.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,PreprocessorCheckUninitializedLocalVarsBranch,The length of the statement  "                    if (block.FinallyBlock != null) newResult = newResult.Union(PreprocessorCheckUninitializedLocalVarsBranch(block.FinallyBlock' result)).ToList(); " is 144.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GetNextFreeVar,The length of the statement  "                        tempVars.Add(new TempVar() { type = type' index = result' startInstr = codeGenerator.NextInstructionIndex' endInstr = -1 }); " is 124.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GetNextFreeVar,The length of the statement  "                    tempVars.Add(new TempVar() { type = type' index = result' startInstr = codeGenerator.NextInstructionIndex' endInstr = -1 }); " is 124.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GetNextFreeVar,The length of the statement  "            tempVars.Add(new TempVar() { type = type' index = result' startInstr = codeGenerator.NextInstructionIndex' endInstr = -1 }); " is 124.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileStelem,The length of the statement  "                    case ILCode.Stelem_I: operand = InterType.PrimitiveTypes[(int)(Program.AsX64 ? PrimitiveType.Int64 : PrimitiveType.Int32)]; break; " is 130.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileStelem,The length of the statement  "            JavaPrimitiveType valueJPType = operand != null ? JavaHelpers.InterTypeToJavaPrimitive(operand) : JavaPrimitiveType.Ref; " is 120.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdelem,The length of the statement  "                    case ILCode.Ldelem_I: operand = InterType.PrimitiveTypes[(int)(Program.AsX64 ? PrimitiveType.Int64 : PrimitiveType.Int32)]; break; " is 130.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdloca,The length of the statement  "                codeGenerator.AddLocalVarInstruction(LocalVarInstruction.Store' JavaHelpers.InterTypeToJavaPrimitive(operandType)' varIndex' e); " is 128.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileMonitorEnter,The length of the statement  "                    CompileExpression(new ILExpression(ILCode.Stloc' flagArg.Operand' new ILExpression(ILCode.Ldc_I4' 1))' ExpectType.None); " is 120.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileMonitorEnter,The length of the statement  "                    CompileExpression(new ILExpression(ILCode.Stsfld' flagArg.Operand' new ILExpression(ILCode.Ldc_I4' 1))' ExpectType.None); " is 121.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileMonitorEnter,The length of the statement  "                    CompileExpression(new ILExpression(ILCode.Stfld' flagArg.Operand' flagArg.Arguments[0]' new ILExpression(ILCode.Ldc_I4' 1))' ExpectType.None); " is 142.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCall,The length of the statement  "            if ((!operand.ReturnParameter.Type.IsPrimitive) || (operand.ReturnParameter.Type.PrimitiveType != PrimitiveType.Void) || " is 120.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileRet,The length of the statement  "                    if ((returnType.PrimitiveType == PrimitiveType.Byte) || (returnType.PrimitiveType == PrimitiveType.SByte) || (returnType.PrimitiveType == PrimitiveType.Bool)) " is 158.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdtoken,The length of the statement  "                    .Add(OpCodes._new' new Java.Constants.Class(namesController.TypeNameToJava(ClassNames.SystemRuntimeTypeHandle.ClassName))' e) " is 125.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdtoken,The length of the statement  "                    .Add(OpCodes._new' new Java.Constants.Class(namesController.TypeNameToJava(ClassNames.SystemRuntimeFieldHandle.ClassName))' e) " is 126.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdtoken,The length of the statement  "                    .Add(OpCodes._new' new Java.Constants.Class(namesController.TypeNameToJava(ClassNames.SystemRuntimeMethodHandle.ClassName))' e) " is 127.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdtoken,The length of the statement  "                    .Add(OpCodes.anewarray' new Java.Constants.Class(namesController.TypeNameToJava(ClassNames.JavaLangClass.ClassName))' e); " is 121.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileArglist,The length of the statement  "                .Add(OpCodes._new' new Java.Constants.Class(namesController.TypeNameToJava(ClassNames.SystemRuntimeArgumentHandle.ClassName))' e) " is 129.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileArglist,The length of the statement  "                .AddLoad(JavaPrimitiveType.Ref' var2Index.Where(K => K.Key.Name == ClassNames.VarArgParamName).FirstOrDefault().Value' e) " is 121.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileMkrefany,The length of the statement  "                .Add(OpCodes._new' new Java.Constants.Class(namesController.TypeNameToJava(ClassNames.SystemTypedReference.ClassName))' e) " is 122.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileRefanytype,The length of the statement  "                .Add(OpCodes._new' new Java.Constants.Class(namesController.TypeNameToJava(ClassNames.SystemRuntimeTypeHandle.ClassName))' e) " is 125.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdloc,The length of the statement  "            codeGenerator.AddLocalVarInstruction(LocalVarInstruction.Load' JavaHelpers.InterTypeToJavaPrimitive(operandType)' varIndex' e); " is 127.
Long Statement,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileStloc,The length of the statement  "                codeGenerator.AddLocalVarInstruction(LocalVarInstruction.Store' JavaHelpers.InterTypeToJavaPrimitive(operandType)' varIndex' e); " is 128.
Long Statement,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,GenerateDelegateRunner,The length of the statement  "                AccessFlags = Java.Attributes.InnerClasses.InnerClassAccessFlags.Final | Java.Attributes.InnerClasses.InnerClassAccessFlags.Private' " is 132.
Long Statement,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,CompileDelegateBeginInvoke,The length of the statement  "            InterMethod beginInvokeMethod = type.Methods.Where(M => M.Name == ClassNames.DelegateBeginInvokeMethodName).FirstOrDefault(); " is 125.
Long Statement,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,CompileDelegateBeginInvoke,The length of the statement  "                .Add(OpCodes._new' new Java.Constants.Class(TypeNameToJava(ClassNames.SystemRuntimeRemotingMessagingAsyncResult.ClassName))) " is 124.
Long Statement,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,CompileDelegateEndInvoke,The length of the statement  "            InterMethod endInvokeMethod = type.Methods.Where(M => M.Name == ClassNames.DelegateEndInvokeMethodName).FirstOrDefault(); " is 121.
Long Statement,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,CompileDelegateEndInvoke,The length of the statement  "                .Add(OpCodes.checkcast' new Java.Constants.Class(TypeNameToJava(ClassNames.SystemRuntimeRemotingMessagingAsyncResult.ClassName))) " is 129.
Long Statement,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,CompileDelegateEndInvoke,The length of the statement  "                    .Add(OpCodes.checkcast' new Java.Constants.Class(currentJavaClass.ThisClass + "$" + ClassNames.DelegateRunnerClassName)) " is 120.
Long Statement,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,PrecompilePass,The length of the statement  "                typesToCompile[i].CheckOverloadingMethods(this' loadedModules.Where(MD => MD.Name == "c2j_mscorlib.dll").FirstOrDefault()); " is 123.
Long Statement,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,CompilePrimitive,The length of the statement  "            MethodRef ctorValueMethodRef = new MethodRef(currentJavaClass.ThisClass' ctorValueMethod.Name' ctorValueMethod.Descriptor); " is 123.
Long Statement,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,Resolve,The length of the statement  "                    DecompilerContext context = new DecompilerContext(methodDef.Module) { CurrentType = methodDef.DeclaringType' CurrentMethod = methodDef }; " is 137.
Long Statement,CIL2Java,InterMethod,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\InterMethod.cs,ToString,The length of the statement  "            return returnParam.Type.ToString() + " " + declType.ToString() + "::" + name + "(" + string.Join("'"' parameters.Select(P => P.Type.ToString() + " " + P.Name).ToArray()) + ")"; " is 176.
Long Statement,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The length of the statement  "                            codeBytesWriter.WriteBE((short)(outputCodeOffsets[outputCode[labels[(string)instr.Operand]]] - outputCodeOffsets[instr])); " is 122.
Long Statement,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The length of the statement  "                                    codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.Pairs[j].Item2]]] - outputCodeOffsets[instr]); " is 120.
Long Statement,CIL2Java,Program,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Program.cs,ParseCommandLine,The length of the statement  "                Console.WriteLine("Usage: " + Path.GetFileName(typeof(Program).Assembly.Location) + " [Optional parameters] [Input 1] [Input 2] ..."); " is 134.
Long Statement,CIL2Java,Program,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Program.cs,Main,The length of the statement  "                ReplacedAssemblies.Add("mscorlib"' Path.Combine(Path.GetDirectoryName(typeof(Program).Assembly.Location)' "c2j_mscorlib.dll")); " is 127.
Long Statement,CIL2Java,Program,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Program.cs,Main,The length of the statement  "                ReplacedAssemblies.Add("System"' Path.Combine(Path.GetDirectoryName(typeof(Program).Assembly.Location)' "c2j_System.dll")); " is 123.
Long Statement,CIL2Java,Program,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Program.cs,Main,The length of the statement  "                ReplacedAssemblies.Add("System.Core"' Path.Combine(Path.GetDirectoryName(typeof(Program).Assembly.Location)' "c2j_System.Core.dll")); " is 133.
Long Statement,CIL2Java.Java,Annotation,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Annotation.cs,ToString,The length of the statement  "            string Result = "Annotation:" + Environment.NewLine + "  Type: " + Type + Environment.NewLine + "  Value pairs:" + Environment.NewLine; " is 135.
Long Statement,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The length of the statement  "            Attributes.LineNumberTable lnt = codeAttr.Attributes.Where(A => A is Attributes.LineNumberTable).FirstOrDefault() as Attributes.LineNumberTable; " is 144.
Long Statement,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The length of the statement  "                                    writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp); " is 123.
Long Statement,CIL2Java.Java.Attributes,Code,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\Code.cs,ToString,The length of the statement  "                    Result += "  " + string.Format("{0'5} {1'5} {2'5}  {3}"' E.StartPC' E.EncPC' E.HandlerPC' E.CatchType == 0 ? "any" : E.CatchType.ToString()) + Environment.NewLine; " is 163.
Long Statement,CIL2Java.Java.Attributes,Code,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\Code.cs,Dump,The length of the statement  "                    writer.WriteLine("{0}    {1'4:X} {2'4:X}   {3'4:X}  {4}"' indent' e.StartPC' e.EncPC' e.HandlerPC' e.CatchType == 0 ? "any" : e.CatchType.ToString()); " is 150.
Long Statement,CIL2Java.Java.Attributes,LocalVariableTable,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\LocalVariableTable.cs,ToString,The length of the statement  "                Result += "  " + V.StartPC + "' " + V.Length + "' " + V.Name + "' " + V.Descriptor + "' " + V.Index + System.Environment.NewLine; " is 129.
Long Statement,CIL2Java.Java.Attributes,LocalVariableTable,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\LocalVariableTable.cs,Dump,The length of the statement  "                writer.WriteLine("{0}    {1'5:G}    {2'4:X}     {3'4:X}  {4}  {5}"' indent' v.Index' v.StartPC' v.Length' v.Name' v.Descriptor); " is 128.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,TranslateType,The conditional expression  "((expected == ExpectType.Boxed) || (expected == ExpectType.Reference))                  && ((type.IsPrimitive) || (type.IsEnum) || (type.IsValueType))"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCall,The conditional expression  "(operand.IsConstructor) && (operand.DeclaringType.IsValueType) && (operand.Parameters.Count < e.Arguments.Count)                  && (!thisMethod.IsConstructor)"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCall,The conditional expression  "(operand.IsConstructor) || (operand.IsPrivate) ||                  ((operand.IsSame(thisMethod)) && (thisMethod.DeclaringType.BaseType == operand.DeclaringType))"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCall,The conditional expression  "(!operand.ReturnParameter.Type.IsPrimitive) || (operand.ReturnParameter.Type.PrimitiveType != PrimitiveType.Void) ||                  (operand.ReturnParameter.IsBoxed) || (operand.ReturnParameter.IsJavaBoxed)"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileJmp,The conditional expression  "(operand.IsConstructor) || (operand.IsPrivate) ||                  ((operand.IsSame(thisMethod)) && (thisMethod.DeclaringType.BaseType == operand.DeclaringType))"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileConvTo1,The conditional expression  "(isToUnsigned && !isFromUnsigned) || (!isToUnsigned && isFromUnsigned)"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileConvTo2,The conditional expression  "(isToUnsigned && !isFromUnsigned) || (!isToUnsigned && isFromUnsigned)"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileConvTo4,The conditional expression  "(isToUnsigned && !isFromUnsigned) || (!isToUnsigned && isFromUnsigned)"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileConvTo8,The conditional expression  "(isToUnsigned && !isFromUnsigned) || (!isToUnsigned && isFromUnsigned)"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileFieldLoad,The conditional expression  "((operand.IsPrivate) && (operand.DeclaringType != thisMethod.DeclaringType)) ||                  ((operand.IsProtected) && (operand.DeclaringType != thisMethod.DeclaringType) &&                  (!thisMethod.DeclaringType.IsSuper(operand.DeclaringType)))"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileFieldStore,The conditional expression  "((operand.IsPrivate) && (operand.DeclaringType != thisMethod.DeclaringType)) ||                  ((operand.IsProtected) && (operand.DeclaringType != thisMethod.DeclaringType) &&                  (!thisMethod.DeclaringType.IsSuper(operand.DeclaringType)))"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileDivUn,The conditional expression  "(jp == JavaPrimitiveType.Bool) || (jp == JavaPrimitiveType.Byte) || (jp == JavaPrimitiveType.Char) ||                  (jp == JavaPrimitiveType.Short)"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileRemUn,The conditional expression  "(jp == JavaPrimitiveType.Bool) || (jp == JavaPrimitiveType.Byte) || (jp == JavaPrimitiveType.Char) ||                  (jp == JavaPrimitiveType.Short)"  is complex.
Complex Conditional,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileStloc,The conditional expression  "(operandType.IsPrimitive) && ((operandType.PrimitiveType == PrimitiveType.UInt64) ||                          (operandType.PrimitiveType == PrimitiveType.Int64) || (operandType.PrimitiveType == PrimitiveType.Double))"  is complex.
Complex Conditional,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,ProcessMethodDecencies,The conditional expression  "(expected != null) && (expected.IsInterface) && (inferred != null) && (inferred.IsArray)"  is complex.
Complex Conditional,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,CompileMethod,The conditional expression  "(method.IsFinal) || ((!method.IsVirtual) && (!method.IsConstructor)) && (!method.IsStatic)"  is complex.
Empty Catch Block,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,WriteClass,The method has an empty catch block.
Empty Catch Block,CIL2Java,Program,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Program.cs,Main,The method has an empty catch block.
Empty Catch Block,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The method has an empty catch block.
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt16,The following statement contains a magic number: return (ushort)((Array[StartIndex] << 8) | (Array[StartIndex + 1]));
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt16,The following statement contains a magic number: return (short)((Array[StartIndex] << 8) | (Array[StartIndex + 1]));
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt32,The following statement contains a magic number: return (uint)(                  (Array[StartIndex    ] << 24) |                  (Array[StartIndex + 1] << 16) |                  (Array[StartIndex + 2] << 8) |                  (Array[StartIndex + 3])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt32,The following statement contains a magic number: return (uint)(                  (Array[StartIndex    ] << 24) |                  (Array[StartIndex + 1] << 16) |                  (Array[StartIndex + 2] << 8) |                  (Array[StartIndex + 3])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt32,The following statement contains a magic number: return (uint)(                  (Array[StartIndex    ] << 24) |                  (Array[StartIndex + 1] << 16) |                  (Array[StartIndex + 2] << 8) |                  (Array[StartIndex + 3])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt32,The following statement contains a magic number: return (uint)(                  (Array[StartIndex    ] << 24) |                  (Array[StartIndex + 1] << 16) |                  (Array[StartIndex + 2] << 8) |                  (Array[StartIndex + 3])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt32,The following statement contains a magic number: return (uint)(                  (Array[StartIndex    ] << 24) |                  (Array[StartIndex + 1] << 16) |                  (Array[StartIndex + 2] << 8) |                  (Array[StartIndex + 3])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt32,The following statement contains a magic number: return (int)(                  (Array[StartIndex    ] << 24) |                  (Array[StartIndex + 1] << 16) |                  (Array[StartIndex + 2] << 8) |                  (Array[StartIndex + 3])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt32,The following statement contains a magic number: return (int)(                  (Array[StartIndex    ] << 24) |                  (Array[StartIndex + 1] << 16) |                  (Array[StartIndex + 2] << 8) |                  (Array[StartIndex + 3])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt32,The following statement contains a magic number: return (int)(                  (Array[StartIndex    ] << 24) |                  (Array[StartIndex + 1] << 16) |                  (Array[StartIndex + 2] << 8) |                  (Array[StartIndex + 3])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt32,The following statement contains a magic number: return (int)(                  (Array[StartIndex    ] << 24) |                  (Array[StartIndex + 1] << 16) |                  (Array[StartIndex + 2] << 8) |                  (Array[StartIndex + 3])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt32,The following statement contains a magic number: return (int)(                  (Array[StartIndex    ] << 24) |                  (Array[StartIndex + 1] << 16) |                  (Array[StartIndex + 2] << 8) |                  (Array[StartIndex + 3])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToInt64,The following statement contains a magic number: return (long)(                  (Array[StartIndex    ] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ToUInt64,The following statement contains a magic number: return (ulong)(                  (Array[StartIndex] << 56) |                  (Array[StartIndex + 1] << 48) |                  (Array[StartIndex + 2] << 40) |                  (Array[StartIndex + 3] << 32) |                  (Array[StartIndex + 4] << 24) |                  (Array[StartIndex + 5] << 16) |                  (Array[StartIndex + 6] << 8) |                  (Array[StartIndex + 7])              );
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,WrtiteUInt16,The following statement contains a magic number: Array[StartIndex]       = (byte)((Value >> 8) & 0xff);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,WrtiteInt16,The following statement contains a magic number: Array[StartIndex]       = (byte)((Value >> 8) & 0xff);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,WrtiteInt32,The following statement contains a magic number: Array[StartIndex]       = (byte)((Value >> 24) & 0xff);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,WrtiteInt32,The following statement contains a magic number: Array[StartIndex + 1]   = (byte)((Value >> 16) & 0xff);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,WrtiteInt32,The following statement contains a magic number: Array[StartIndex + 2]   = (byte)((Value >>  8) & 0xff);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,WrtiteInt32,The following statement contains a magic number: Array[StartIndex + 2]   = (byte)((Value >>  8) & 0xff);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,WrtiteInt32,The following statement contains a magic number: Array[StartIndex + 3]   = (byte)((Value      ) & 0xff);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ReadAsInt32,The following statement contains a magic number: Result = (Result << 8) | (Array[StartIndex + 1]);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ReadAsInt32,The following statement contains a magic number: Result = (Result << 8) | (Array[StartIndex + 2]);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ReadAsInt32,The following statement contains a magic number: Result = (Result << 8) | (Array[StartIndex + 2]);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ReadAsInt32,The following statement contains a magic number: Length > 2
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ReadAsInt32,The following statement contains a magic number: Result = (Result << 8) | (Array[StartIndex + 3]);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ReadAsInt32,The following statement contains a magic number: Result = (Result << 8) | (Array[StartIndex + 3]);
Magic Number,CIL2Java,BitConverterBE,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\BitConverterBE.cs,ReadAsInt32,The following statement contains a magic number: Length > 3
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GenerateMethodPointerClass,The following statement contains a magic number: codeWriter.AddLoad(JavaHelpers.InterTypeToJavaPrimitive(operand.Parameters[i].Type)' i + 2);
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileStelem,The following statement contains a magic number: CompileExpression(e.Arguments[2]' valueExpectType);
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileArrayCall,The following statement contains a magic number: CompileExpression(e.Arguments[i + 2]' ExpectType.Primitive);
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileAddressOf,The following statement contains a magic number: CompileExpression(e.Arguments[i + 2]' ExpectType.Primitive);
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdcI4,The following statement contains a magic number: switch (operand)              {                  case -1: codeGenerator.Add(Java.OpCodes.iconst_m1' null' e); break;                  case 0: codeGenerator.Add(Java.OpCodes.iconst_0' null' e); break;                  case 1: codeGenerator.Add(Java.OpCodes.iconst_1' null' e); break;                  case 2: codeGenerator.Add(Java.OpCodes.iconst_2' null' e); break;                  case 3: codeGenerator.Add(Java.OpCodes.iconst_3' null' e); break;                  case 4: codeGenerator.Add(Java.OpCodes.iconst_4' null' e); break;                  case 5: codeGenerator.Add(Java.OpCodes.iconst_5' null' e); break;                    default:                      if ((operand >= sbyte.MinValue) && (operand <= sbyte.MaxValue))                          codeGenerator.Add(Java.OpCodes.bipush' (sbyte)operand' e);                      else if ((operand >= short.MinValue) && (operand <= short.MaxValue))                          codeGenerator.Add(Java.OpCodes.sipush' (short)operand);                      else                          codeGenerator.Add(Java.OpCodes.ldc' new Java.Constants.Integer(operand)' e);                      break;              }
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdcI4,The following statement contains a magic number: switch (operand)              {                  case -1: codeGenerator.Add(Java.OpCodes.iconst_m1' null' e); break;                  case 0: codeGenerator.Add(Java.OpCodes.iconst_0' null' e); break;                  case 1: codeGenerator.Add(Java.OpCodes.iconst_1' null' e); break;                  case 2: codeGenerator.Add(Java.OpCodes.iconst_2' null' e); break;                  case 3: codeGenerator.Add(Java.OpCodes.iconst_3' null' e); break;                  case 4: codeGenerator.Add(Java.OpCodes.iconst_4' null' e); break;                  case 5: codeGenerator.Add(Java.OpCodes.iconst_5' null' e); break;                    default:                      if ((operand >= sbyte.MinValue) && (operand <= sbyte.MaxValue))                          codeGenerator.Add(Java.OpCodes.bipush' (sbyte)operand' e);                      else if ((operand >= short.MinValue) && (operand <= short.MaxValue))                          codeGenerator.Add(Java.OpCodes.sipush' (short)operand);                      else                          codeGenerator.Add(Java.OpCodes.ldc' new Java.Constants.Integer(operand)' e);                      break;              }
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdcI4,The following statement contains a magic number: switch (operand)              {                  case -1: codeGenerator.Add(Java.OpCodes.iconst_m1' null' e); break;                  case 0: codeGenerator.Add(Java.OpCodes.iconst_0' null' e); break;                  case 1: codeGenerator.Add(Java.OpCodes.iconst_1' null' e); break;                  case 2: codeGenerator.Add(Java.OpCodes.iconst_2' null' e); break;                  case 3: codeGenerator.Add(Java.OpCodes.iconst_3' null' e); break;                  case 4: codeGenerator.Add(Java.OpCodes.iconst_4' null' e); break;                  case 5: codeGenerator.Add(Java.OpCodes.iconst_5' null' e); break;                    default:                      if ((operand >= sbyte.MinValue) && (operand <= sbyte.MaxValue))                          codeGenerator.Add(Java.OpCodes.bipush' (sbyte)operand' e);                      else if ((operand >= short.MinValue) && (operand <= short.MaxValue))                          codeGenerator.Add(Java.OpCodes.sipush' (short)operand);                      else                          codeGenerator.Add(Java.OpCodes.ldc' new Java.Constants.Integer(operand)' e);                      break;              }
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdcI4,The following statement contains a magic number: switch (operand)              {                  case -1: codeGenerator.Add(Java.OpCodes.iconst_m1' null' e); break;                  case 0: codeGenerator.Add(Java.OpCodes.iconst_0' null' e); break;                  case 1: codeGenerator.Add(Java.OpCodes.iconst_1' null' e); break;                  case 2: codeGenerator.Add(Java.OpCodes.iconst_2' null' e); break;                  case 3: codeGenerator.Add(Java.OpCodes.iconst_3' null' e); break;                  case 4: codeGenerator.Add(Java.OpCodes.iconst_4' null' e); break;                  case 5: codeGenerator.Add(Java.OpCodes.iconst_5' null' e); break;                    default:                      if ((operand >= sbyte.MinValue) && (operand <= sbyte.MaxValue))                          codeGenerator.Add(Java.OpCodes.bipush' (sbyte)operand' e);                      else if ((operand >= short.MinValue) && (operand <= short.MaxValue))                          codeGenerator.Add(Java.OpCodes.sipush' (short)operand);                      else                          codeGenerator.Add(Java.OpCodes.ldc' new Java.Constants.Integer(operand)' e);                      break;              }
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdcDecimal,The following statement contains a magic number: codeGenerator                  .Add(OpCodes._new' new Java.Constants.Class(namesController.TypeNameToJava(ClassNames.SystemDecimal.ClassNames))' e)                  .Add(OpCodes.dup' null' e)                    .Add(OpCodes.iconst_4' null' e)                  .AddNewArray(JavaArrayType.Int' e)                    .Add(OpCodes.dup' null' e)                  .Add(OpCodes.iconst_0' null' e)                  .AddIntConst(bits[0]' e)                  .Add(OpCodes.iastore' null' e)                    .Add(OpCodes.dup' null' e)                  .Add(OpCodes.iconst_1' null' e)                  .AddIntConst(bits[1]' e)                  .Add(OpCodes.iastore' null' e)                    .Add(OpCodes.dup' null' e)                  .Add(OpCodes.iconst_2' null' e)                  .AddIntConst(bits[2]' e)                  .Add(OpCodes.iastore' null' e)                    .Add(OpCodes.dup' null' e)                  .Add(OpCodes.iconst_3' null' e)                  .AddIntConst(bits[3]' e)                  .Add(OpCodes.iastore' null' e)                    .Add(OpCodes.invokespecial' ClassNames.SystemDecimal.FromBitsCtorRef' e);
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdcDecimal,The following statement contains a magic number: codeGenerator                  .Add(OpCodes._new' new Java.Constants.Class(namesController.TypeNameToJava(ClassNames.SystemDecimal.ClassNames))' e)                  .Add(OpCodes.dup' null' e)                    .Add(OpCodes.iconst_4' null' e)                  .AddNewArray(JavaArrayType.Int' e)                    .Add(OpCodes.dup' null' e)                  .Add(OpCodes.iconst_0' null' e)                  .AddIntConst(bits[0]' e)                  .Add(OpCodes.iastore' null' e)                    .Add(OpCodes.dup' null' e)                  .Add(OpCodes.iconst_1' null' e)                  .AddIntConst(bits[1]' e)                  .Add(OpCodes.iastore' null' e)                    .Add(OpCodes.dup' null' e)                  .Add(OpCodes.iconst_2' null' e)                  .AddIntConst(bits[2]' e)                  .Add(OpCodes.iastore' null' e)                    .Add(OpCodes.dup' null' e)                  .Add(OpCodes.iconst_3' null' e)                  .AddIntConst(bits[3]' e)                  .Add(OpCodes.iastore' null' e)                    .Add(OpCodes.invokespecial' ClassNames.SystemDecimal.FromBitsCtorRef' e);
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileConvRUn,The following statement contains a magic number: switch (gettedJava)              {                  case JavaPrimitiveType.Bool:                  case JavaPrimitiveType.Byte:                  case JavaPrimitiveType.Short:                  case JavaPrimitiveType.Char:                  case JavaPrimitiveType.Int:                      codeGenerator                          .Add(Java.OpCodes.i2l' e)                          .AddLongConst(0xffffffffL' e)                          .Add(Java.OpCodes.land' e)                          .Add(Java.OpCodes.l2d);                      break;                    case JavaPrimitiveType.Long:                      int tmpVar = GetNextFreeVar(JavaPrimitiveType.Int);                        // Pseudocode (ulong value -> double result):                      // int bit = ((int)value) & 0x01;                      // double result = (double)(value >>> 1)                      // result *= 2                      // result += (double)bit                      codeGenerator                          .Add(OpCodes.dup2' null' e)                 //save original value for future                          .Add(OpCodes.l2i' null' e)                          .Add(OpCodes.iconst_1' null' e)                          .Add(OpCodes.iand' null' e)                 //get last bit of value                          .AddStore(JavaPrimitiveType.Int' tmpVar' e) //and save it. Now in stack original value.                          .Add(OpCodes.iconst_1' null' e)                          .Add(OpCodes.lushr' null' e)                //unsigned divide value by 2 to make it positive                          .Add(OpCodes.l2d' null' e)                  //convert it to double = value / 2                          .AddDoubleConst(2.0' e)                          .Add(OpCodes.dmul' null' e)                 //and multiple double by 2 to restore original value                          .AddLoad(JavaPrimitiveType.Int' tmpVar' e)  //restore last bit of original value                          .Add(OpCodes.i2d' null' e)                          .Add(OpCodes.dadd' null' e);                // and add it to result double                          FreeVar(tmpVar' JavaPrimitiveType.Int);                      break;                    default:                      throw new Exception();  //This never must be happend in valid IL code              }
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileTernaryOp,The following statement contains a magic number: conditionNode.FalseBlock = new ILBlock(e.Arguments[2]);
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCpblk,The following statement contains a magic number: CompileExpression(e.Arguments[2]' ExpectType.Primitive);
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileInitblk,The following statement contains a magic number: CompileExpression(e.Arguments[2]' ExpectType.Primitive);
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GetSize,The following statement contains a magic number: switch (operand.PrimitiveType)                  {                      case PrimitiveType.Bool:                      case PrimitiveType.Byte:                      case PrimitiveType.SByte:                          return 1;                        case PrimitiveType.Char:                      case PrimitiveType.Int16:                      case PrimitiveType.UInt16:                          return 2;                        case PrimitiveType.Int32:                      case PrimitiveType.UInt32:                      case PrimitiveType.Single:                          return 4;                        case PrimitiveType.Int64:                      case PrimitiveType.UInt64:                      case PrimitiveType.Double:                          return 8;                        case PrimitiveType.IntPtr:                      case PrimitiveType.UIntPtr:                          if (Program.AsX64)                              return 8;                          else                              return 4;                        default:                          return 0;                  }
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GetSize,The following statement contains a magic number: switch (operand.PrimitiveType)                  {                      case PrimitiveType.Bool:                      case PrimitiveType.Byte:                      case PrimitiveType.SByte:                          return 1;                        case PrimitiveType.Char:                      case PrimitiveType.Int16:                      case PrimitiveType.UInt16:                          return 2;                        case PrimitiveType.Int32:                      case PrimitiveType.UInt32:                      case PrimitiveType.Single:                          return 4;                        case PrimitiveType.Int64:                      case PrimitiveType.UInt64:                      case PrimitiveType.Double:                          return 8;                        case PrimitiveType.IntPtr:                      case PrimitiveType.UIntPtr:                          if (Program.AsX64)                              return 8;                          else                              return 4;                        default:                          return 0;                  }
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GetSize,The following statement contains a magic number: switch (operand.PrimitiveType)                  {                      case PrimitiveType.Bool:                      case PrimitiveType.Byte:                      case PrimitiveType.SByte:                          return 1;                        case PrimitiveType.Char:                      case PrimitiveType.Int16:                      case PrimitiveType.UInt16:                          return 2;                        case PrimitiveType.Int32:                      case PrimitiveType.UInt32:                      case PrimitiveType.Single:                          return 4;                        case PrimitiveType.Int64:                      case PrimitiveType.UInt64:                      case PrimitiveType.Double:                          return 8;                        case PrimitiveType.IntPtr:                      case PrimitiveType.UIntPtr:                          if (Program.AsX64)                              return 8;                          else                              return 4;                        default:                          return 0;                  }
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GetSize,The following statement contains a magic number: switch (operand.PrimitiveType)                  {                      case PrimitiveType.Bool:                      case PrimitiveType.Byte:                      case PrimitiveType.SByte:                          return 1;                        case PrimitiveType.Char:                      case PrimitiveType.Int16:                      case PrimitiveType.UInt16:                          return 2;                        case PrimitiveType.Int32:                      case PrimitiveType.UInt32:                      case PrimitiveType.Single:                          return 4;                        case PrimitiveType.Int64:                      case PrimitiveType.UInt64:                      case PrimitiveType.Double:                          return 8;                        case PrimitiveType.IntPtr:                      case PrimitiveType.UIntPtr:                          if (Program.AsX64)                              return 8;                          else                              return 4;                        default:                          return 0;                  }
Magic Number,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,GetSize,The following statement contains a magic number: switch (operand.PrimitiveType)                  {                      case PrimitiveType.Bool:                      case PrimitiveType.Byte:                      case PrimitiveType.SByte:                          return 1;                        case PrimitiveType.Char:                      case PrimitiveType.Int16:                      case PrimitiveType.UInt16:                          return 2;                        case PrimitiveType.Int32:                      case PrimitiveType.UInt32:                      case PrimitiveType.Single:                          return 4;                        case PrimitiveType.Int64:                      case PrimitiveType.UInt64:                      case PrimitiveType.Double:                          return 8;                        case PrimitiveType.IntPtr:                      case PrimitiveType.UIntPtr:                          if (Program.AsX64)                              return 8;                          else                              return 4;                        default:                          return 0;                  }
Magic Number,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,GenerateDelegateRunner,The following statement contains a magic number: ctorCodeWriter                      .Add(OpCodes.aload_0)                      .AddLoad(jp' i + 2)                      .Add(OpCodes.putfield' paramFieldRef);
Magic Number,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,CompileDelegateBeginInvoke,The following statement contains a magic number: i < paramsCount - 2
Magic Number,CIL2Java,InterMethod,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\InterMethod.cs,InterMethod,The following statement contains a magic number: (methodMapCustomAttr.ConstructorArguments.Count > 2) && ((bool)methodMapCustomAttr.ConstructorArguments[2].Value)
Magic Number,CIL2Java,InterMethod,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\InterMethod.cs,InterMethod,The following statement contains a magic number: (methodMapCustomAttr.ConstructorArguments.Count > 2) && ((bool)methodMapCustomAttr.ConstructorArguments[2].Value)
Magic Number,CIL2Java,InterType,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\InterType.cs,Special,The following statement contains a magic number: resolver.Resolve(typeDef.Methods.Where(M => ((M.IsConstructor) && (M.Parameters.Count == 2) &&                      (M.Parameters[0].ParameterType.FullName == M.Parameters[1].ParameterType.FullName) &&                      (M.Parameters[0].ParameterType.FullName == ClassNames.ObjectTypeName))).FirstOrDefault()' this.genericArgs);
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,CalculateInterfaceCallArgsCount,The following statement contains a magic number: Result += (byte)(Array ? 1 : 2);
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass1,The following statement contains a magic number: instr.Operand = (uint)(constIndex | ((argsCount + 1) << 24));
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass1,The following statement contains a magic number: int paddingLendth = (4 - ((offset + 1) % 4)) % 4;
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass1,The following statement contains a magic number: int paddingLendth = (4 - ((offset + 1) % 4)) % 4;
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass1,The following statement contains a magic number: int paddingLendth = (4 - ((offset + 1) % 4)) % 4;
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass1,The following statement contains a magic number: size = 1    //opcode                          + paddingLendth //padding                          + 4     //default                          + 4     //npairs                          + op.Pairs.Length * 8;
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass1,The following statement contains a magic number: size = 1    //opcode                          + paddingLendth //padding                          + 4     //default                          + 4     //npairs                          + op.Pairs.Length * 8;
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass1,The following statement contains a magic number: size = 1    //opcode                          + paddingLendth //padding                          + 4     //default                          + 4     //npairs                          + op.Pairs.Length * 8;
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass1,The following statement contains a magic number: size = (size - 1) * 2 + 1;
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The following statement contains a magic number: switch (descr.OpType)                  {                      case Java.ByteCode.JavaOperandType.ConstValue:                          switch (operandSize)                          {                              case 1: codeBytesWriter.Write((sbyte)instr.Operand); break;                              case 2: codeBytesWriter.WriteBE((short)instr.Operand); break;                              case 4: codeBytesWriter.WriteBE((int)instr.Operand); break;                          }                          break;                        case Java.ByteCode.JavaOperandType.ConstPool:                          if (operandSize == 1)                              codeBytesWriter.Write((byte)((ushort)instr.Operand));                          else                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.LocalVar:                          if (instr.Operand is ushort)                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          else                              codeBytesWriter.Write((byte)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.Offset:                          if (instr.Operand is string)                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[outputCode[labels[(string)instr.Operand]]] - outputCodeOffsets[instr]));                          else                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[(JavaInstruction)instr.Operand] - outputCodeOffsets[instr]));                          break;                        case Java.ByteCode.JavaOperandType.Special:                          switch (instr.Opcode)                          {                              case Java.OpCodes.iinc:                                  if (instr.Operand is int)                                      codeBytesWriter.WriteBE((int)instr.Operand);                                  else                                      codeBytesWriter.WriteBE((short)instr.Operand);                                  break;                                case Java.OpCodes.tableswitch:                                  //TODO: Java.OpCodes.tableswitch                                  break;                                case Java.OpCodes.lookupswitch:                                  LookupswitchOperand lookUpOperand = (LookupswitchOperand)instr.Operand;                                    int padding = (4 - ((outputCodeOffsets[instr] + 1) % 4)) % 4;                                  codeBytesWriter.Write(new byte[padding]);                                  codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.DefaultLabel]]] - outputCodeOffsets[instr]);                                  codeBytesWriter.WriteBE(lookUpOperand.Pairs.Length);                                    for (int j = 0; j < lookUpOperand.Pairs.Length; j++)                                  {                                      codeBytesWriter.WriteBE(lookUpOperand.Pairs[j].Item1);                                      codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.Pairs[j].Item2]]] - outputCodeOffsets[instr]);                                  }                                    break;                                case Java.OpCodes.invokeinterface:                              case Java.OpCodes.invokedynamic:                                  uint op = (uint)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(op & 0xfff));                                  codeBytesWriter.WriteBE((ushort)(op >> 16));                                  break;                                case Java.OpCodes.newarray:                                  codeBytesWriter.Write((byte)instr.Operand);                                  break;                                case Java.OpCodes.wide:                                  break;                                case Java.OpCodes.multianewarray:                                  int data = (int)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(data & 0xffff));                                  codeBytesWriter.Write((byte)((data & 0xff0000) >> 16));                                  break;                          }                          break;                  }
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The following statement contains a magic number: switch (descr.OpType)                  {                      case Java.ByteCode.JavaOperandType.ConstValue:                          switch (operandSize)                          {                              case 1: codeBytesWriter.Write((sbyte)instr.Operand); break;                              case 2: codeBytesWriter.WriteBE((short)instr.Operand); break;                              case 4: codeBytesWriter.WriteBE((int)instr.Operand); break;                          }                          break;                        case Java.ByteCode.JavaOperandType.ConstPool:                          if (operandSize == 1)                              codeBytesWriter.Write((byte)((ushort)instr.Operand));                          else                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.LocalVar:                          if (instr.Operand is ushort)                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          else                              codeBytesWriter.Write((byte)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.Offset:                          if (instr.Operand is string)                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[outputCode[labels[(string)instr.Operand]]] - outputCodeOffsets[instr]));                          else                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[(JavaInstruction)instr.Operand] - outputCodeOffsets[instr]));                          break;                        case Java.ByteCode.JavaOperandType.Special:                          switch (instr.Opcode)                          {                              case Java.OpCodes.iinc:                                  if (instr.Operand is int)                                      codeBytesWriter.WriteBE((int)instr.Operand);                                  else                                      codeBytesWriter.WriteBE((short)instr.Operand);                                  break;                                case Java.OpCodes.tableswitch:                                  //TODO: Java.OpCodes.tableswitch                                  break;                                case Java.OpCodes.lookupswitch:                                  LookupswitchOperand lookUpOperand = (LookupswitchOperand)instr.Operand;                                    int padding = (4 - ((outputCodeOffsets[instr] + 1) % 4)) % 4;                                  codeBytesWriter.Write(new byte[padding]);                                  codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.DefaultLabel]]] - outputCodeOffsets[instr]);                                  codeBytesWriter.WriteBE(lookUpOperand.Pairs.Length);                                    for (int j = 0; j < lookUpOperand.Pairs.Length; j++)                                  {                                      codeBytesWriter.WriteBE(lookUpOperand.Pairs[j].Item1);                                      codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.Pairs[j].Item2]]] - outputCodeOffsets[instr]);                                  }                                    break;                                case Java.OpCodes.invokeinterface:                              case Java.OpCodes.invokedynamic:                                  uint op = (uint)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(op & 0xfff));                                  codeBytesWriter.WriteBE((ushort)(op >> 16));                                  break;                                case Java.OpCodes.newarray:                                  codeBytesWriter.Write((byte)instr.Operand);                                  break;                                case Java.OpCodes.wide:                                  break;                                case Java.OpCodes.multianewarray:                                  int data = (int)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(data & 0xffff));                                  codeBytesWriter.Write((byte)((data & 0xff0000) >> 16));                                  break;                          }                          break;                  }
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The following statement contains a magic number: switch (descr.OpType)                  {                      case Java.ByteCode.JavaOperandType.ConstValue:                          switch (operandSize)                          {                              case 1: codeBytesWriter.Write((sbyte)instr.Operand); break;                              case 2: codeBytesWriter.WriteBE((short)instr.Operand); break;                              case 4: codeBytesWriter.WriteBE((int)instr.Operand); break;                          }                          break;                        case Java.ByteCode.JavaOperandType.ConstPool:                          if (operandSize == 1)                              codeBytesWriter.Write((byte)((ushort)instr.Operand));                          else                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.LocalVar:                          if (instr.Operand is ushort)                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          else                              codeBytesWriter.Write((byte)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.Offset:                          if (instr.Operand is string)                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[outputCode[labels[(string)instr.Operand]]] - outputCodeOffsets[instr]));                          else                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[(JavaInstruction)instr.Operand] - outputCodeOffsets[instr]));                          break;                        case Java.ByteCode.JavaOperandType.Special:                          switch (instr.Opcode)                          {                              case Java.OpCodes.iinc:                                  if (instr.Operand is int)                                      codeBytesWriter.WriteBE((int)instr.Operand);                                  else                                      codeBytesWriter.WriteBE((short)instr.Operand);                                  break;                                case Java.OpCodes.tableswitch:                                  //TODO: Java.OpCodes.tableswitch                                  break;                                case Java.OpCodes.lookupswitch:                                  LookupswitchOperand lookUpOperand = (LookupswitchOperand)instr.Operand;                                    int padding = (4 - ((outputCodeOffsets[instr] + 1) % 4)) % 4;                                  codeBytesWriter.Write(new byte[padding]);                                  codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.DefaultLabel]]] - outputCodeOffsets[instr]);                                  codeBytesWriter.WriteBE(lookUpOperand.Pairs.Length);                                    for (int j = 0; j < lookUpOperand.Pairs.Length; j++)                                  {                                      codeBytesWriter.WriteBE(lookUpOperand.Pairs[j].Item1);                                      codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.Pairs[j].Item2]]] - outputCodeOffsets[instr]);                                  }                                    break;                                case Java.OpCodes.invokeinterface:                              case Java.OpCodes.invokedynamic:                                  uint op = (uint)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(op & 0xfff));                                  codeBytesWriter.WriteBE((ushort)(op >> 16));                                  break;                                case Java.OpCodes.newarray:                                  codeBytesWriter.Write((byte)instr.Operand);                                  break;                                case Java.OpCodes.wide:                                  break;                                case Java.OpCodes.multianewarray:                                  int data = (int)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(data & 0xffff));                                  codeBytesWriter.Write((byte)((data & 0xff0000) >> 16));                                  break;                          }                          break;                  }
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The following statement contains a magic number: switch (descr.OpType)                  {                      case Java.ByteCode.JavaOperandType.ConstValue:                          switch (operandSize)                          {                              case 1: codeBytesWriter.Write((sbyte)instr.Operand); break;                              case 2: codeBytesWriter.WriteBE((short)instr.Operand); break;                              case 4: codeBytesWriter.WriteBE((int)instr.Operand); break;                          }                          break;                        case Java.ByteCode.JavaOperandType.ConstPool:                          if (operandSize == 1)                              codeBytesWriter.Write((byte)((ushort)instr.Operand));                          else                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.LocalVar:                          if (instr.Operand is ushort)                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          else                              codeBytesWriter.Write((byte)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.Offset:                          if (instr.Operand is string)                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[outputCode[labels[(string)instr.Operand]]] - outputCodeOffsets[instr]));                          else                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[(JavaInstruction)instr.Operand] - outputCodeOffsets[instr]));                          break;                        case Java.ByteCode.JavaOperandType.Special:                          switch (instr.Opcode)                          {                              case Java.OpCodes.iinc:                                  if (instr.Operand is int)                                      codeBytesWriter.WriteBE((int)instr.Operand);                                  else                                      codeBytesWriter.WriteBE((short)instr.Operand);                                  break;                                case Java.OpCodes.tableswitch:                                  //TODO: Java.OpCodes.tableswitch                                  break;                                case Java.OpCodes.lookupswitch:                                  LookupswitchOperand lookUpOperand = (LookupswitchOperand)instr.Operand;                                    int padding = (4 - ((outputCodeOffsets[instr] + 1) % 4)) % 4;                                  codeBytesWriter.Write(new byte[padding]);                                  codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.DefaultLabel]]] - outputCodeOffsets[instr]);                                  codeBytesWriter.WriteBE(lookUpOperand.Pairs.Length);                                    for (int j = 0; j < lookUpOperand.Pairs.Length; j++)                                  {                                      codeBytesWriter.WriteBE(lookUpOperand.Pairs[j].Item1);                                      codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.Pairs[j].Item2]]] - outputCodeOffsets[instr]);                                  }                                    break;                                case Java.OpCodes.invokeinterface:                              case Java.OpCodes.invokedynamic:                                  uint op = (uint)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(op & 0xfff));                                  codeBytesWriter.WriteBE((ushort)(op >> 16));                                  break;                                case Java.OpCodes.newarray:                                  codeBytesWriter.Write((byte)instr.Operand);                                  break;                                case Java.OpCodes.wide:                                  break;                                case Java.OpCodes.multianewarray:                                  int data = (int)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(data & 0xffff));                                  codeBytesWriter.Write((byte)((data & 0xff0000) >> 16));                                  break;                          }                          break;                  }
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The following statement contains a magic number: switch (descr.OpType)                  {                      case Java.ByteCode.JavaOperandType.ConstValue:                          switch (operandSize)                          {                              case 1: codeBytesWriter.Write((sbyte)instr.Operand); break;                              case 2: codeBytesWriter.WriteBE((short)instr.Operand); break;                              case 4: codeBytesWriter.WriteBE((int)instr.Operand); break;                          }                          break;                        case Java.ByteCode.JavaOperandType.ConstPool:                          if (operandSize == 1)                              codeBytesWriter.Write((byte)((ushort)instr.Operand));                          else                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.LocalVar:                          if (instr.Operand is ushort)                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          else                              codeBytesWriter.Write((byte)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.Offset:                          if (instr.Operand is string)                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[outputCode[labels[(string)instr.Operand]]] - outputCodeOffsets[instr]));                          else                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[(JavaInstruction)instr.Operand] - outputCodeOffsets[instr]));                          break;                        case Java.ByteCode.JavaOperandType.Special:                          switch (instr.Opcode)                          {                              case Java.OpCodes.iinc:                                  if (instr.Operand is int)                                      codeBytesWriter.WriteBE((int)instr.Operand);                                  else                                      codeBytesWriter.WriteBE((short)instr.Operand);                                  break;                                case Java.OpCodes.tableswitch:                                  //TODO: Java.OpCodes.tableswitch                                  break;                                case Java.OpCodes.lookupswitch:                                  LookupswitchOperand lookUpOperand = (LookupswitchOperand)instr.Operand;                                    int padding = (4 - ((outputCodeOffsets[instr] + 1) % 4)) % 4;                                  codeBytesWriter.Write(new byte[padding]);                                  codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.DefaultLabel]]] - outputCodeOffsets[instr]);                                  codeBytesWriter.WriteBE(lookUpOperand.Pairs.Length);                                    for (int j = 0; j < lookUpOperand.Pairs.Length; j++)                                  {                                      codeBytesWriter.WriteBE(lookUpOperand.Pairs[j].Item1);                                      codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.Pairs[j].Item2]]] - outputCodeOffsets[instr]);                                  }                                    break;                                case Java.OpCodes.invokeinterface:                              case Java.OpCodes.invokedynamic:                                  uint op = (uint)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(op & 0xfff));                                  codeBytesWriter.WriteBE((ushort)(op >> 16));                                  break;                                case Java.OpCodes.newarray:                                  codeBytesWriter.Write((byte)instr.Operand);                                  break;                                case Java.OpCodes.wide:                                  break;                                case Java.OpCodes.multianewarray:                                  int data = (int)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(data & 0xffff));                                  codeBytesWriter.Write((byte)((data & 0xff0000) >> 16));                                  break;                          }                          break;                  }
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The following statement contains a magic number: switch (descr.OpType)                  {                      case Java.ByteCode.JavaOperandType.ConstValue:                          switch (operandSize)                          {                              case 1: codeBytesWriter.Write((sbyte)instr.Operand); break;                              case 2: codeBytesWriter.WriteBE((short)instr.Operand); break;                              case 4: codeBytesWriter.WriteBE((int)instr.Operand); break;                          }                          break;                        case Java.ByteCode.JavaOperandType.ConstPool:                          if (operandSize == 1)                              codeBytesWriter.Write((byte)((ushort)instr.Operand));                          else                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.LocalVar:                          if (instr.Operand is ushort)                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          else                              codeBytesWriter.Write((byte)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.Offset:                          if (instr.Operand is string)                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[outputCode[labels[(string)instr.Operand]]] - outputCodeOffsets[instr]));                          else                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[(JavaInstruction)instr.Operand] - outputCodeOffsets[instr]));                          break;                        case Java.ByteCode.JavaOperandType.Special:                          switch (instr.Opcode)                          {                              case Java.OpCodes.iinc:                                  if (instr.Operand is int)                                      codeBytesWriter.WriteBE((int)instr.Operand);                                  else                                      codeBytesWriter.WriteBE((short)instr.Operand);                                  break;                                case Java.OpCodes.tableswitch:                                  //TODO: Java.OpCodes.tableswitch                                  break;                                case Java.OpCodes.lookupswitch:                                  LookupswitchOperand lookUpOperand = (LookupswitchOperand)instr.Operand;                                    int padding = (4 - ((outputCodeOffsets[instr] + 1) % 4)) % 4;                                  codeBytesWriter.Write(new byte[padding]);                                  codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.DefaultLabel]]] - outputCodeOffsets[instr]);                                  codeBytesWriter.WriteBE(lookUpOperand.Pairs.Length);                                    for (int j = 0; j < lookUpOperand.Pairs.Length; j++)                                  {                                      codeBytesWriter.WriteBE(lookUpOperand.Pairs[j].Item1);                                      codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.Pairs[j].Item2]]] - outputCodeOffsets[instr]);                                  }                                    break;                                case Java.OpCodes.invokeinterface:                              case Java.OpCodes.invokedynamic:                                  uint op = (uint)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(op & 0xfff));                                  codeBytesWriter.WriteBE((ushort)(op >> 16));                                  break;                                case Java.OpCodes.newarray:                                  codeBytesWriter.Write((byte)instr.Operand);                                  break;                                case Java.OpCodes.wide:                                  break;                                case Java.OpCodes.multianewarray:                                  int data = (int)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(data & 0xffff));                                  codeBytesWriter.Write((byte)((data & 0xff0000) >> 16));                                  break;                          }                          break;                  }
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The following statement contains a magic number: switch (descr.OpType)                  {                      case Java.ByteCode.JavaOperandType.ConstValue:                          switch (operandSize)                          {                              case 1: codeBytesWriter.Write((sbyte)instr.Operand); break;                              case 2: codeBytesWriter.WriteBE((short)instr.Operand); break;                              case 4: codeBytesWriter.WriteBE((int)instr.Operand); break;                          }                          break;                        case Java.ByteCode.JavaOperandType.ConstPool:                          if (operandSize == 1)                              codeBytesWriter.Write((byte)((ushort)instr.Operand));                          else                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.LocalVar:                          if (instr.Operand is ushort)                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          else                              codeBytesWriter.Write((byte)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.Offset:                          if (instr.Operand is string)                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[outputCode[labels[(string)instr.Operand]]] - outputCodeOffsets[instr]));                          else                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[(JavaInstruction)instr.Operand] - outputCodeOffsets[instr]));                          break;                        case Java.ByteCode.JavaOperandType.Special:                          switch (instr.Opcode)                          {                              case Java.OpCodes.iinc:                                  if (instr.Operand is int)                                      codeBytesWriter.WriteBE((int)instr.Operand);                                  else                                      codeBytesWriter.WriteBE((short)instr.Operand);                                  break;                                case Java.OpCodes.tableswitch:                                  //TODO: Java.OpCodes.tableswitch                                  break;                                case Java.OpCodes.lookupswitch:                                  LookupswitchOperand lookUpOperand = (LookupswitchOperand)instr.Operand;                                    int padding = (4 - ((outputCodeOffsets[instr] + 1) % 4)) % 4;                                  codeBytesWriter.Write(new byte[padding]);                                  codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.DefaultLabel]]] - outputCodeOffsets[instr]);                                  codeBytesWriter.WriteBE(lookUpOperand.Pairs.Length);                                    for (int j = 0; j < lookUpOperand.Pairs.Length; j++)                                  {                                      codeBytesWriter.WriteBE(lookUpOperand.Pairs[j].Item1);                                      codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.Pairs[j].Item2]]] - outputCodeOffsets[instr]);                                  }                                    break;                                case Java.OpCodes.invokeinterface:                              case Java.OpCodes.invokedynamic:                                  uint op = (uint)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(op & 0xfff));                                  codeBytesWriter.WriteBE((ushort)(op >> 16));                                  break;                                case Java.OpCodes.newarray:                                  codeBytesWriter.Write((byte)instr.Operand);                                  break;                                case Java.OpCodes.wide:                                  break;                                case Java.OpCodes.multianewarray:                                  int data = (int)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(data & 0xffff));                                  codeBytesWriter.Write((byte)((data & 0xff0000) >> 16));                                  break;                          }                          break;                  }
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,AddLocalVarInstruction,The following statement contains a magic number: varIndex < 4
Magic Number,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,AddIInc,The following statement contains a magic number: int operand = (varIndex << 16) | (value & 0xffff);
Magic Number,CIL2Java,Messages,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Messages.cs,Message,The following statement contains a magic number: MessageIndex -= 1000;
Magic Number,CIL2Java,Messages,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Messages.cs,Message,The following statement contains a magic number: RawCode >= 1000
Magic Number,CIL2Java,StackSimulator,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\StackSimulator.cs,SimulateStack,The following statement contains a magic number: Size = (Size - 1) * 2 + 1;
Magic Number,CIL2Java,StackSimulator,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\StackSimulator.cs,SimulateStack,The following statement contains a magic number: uint tmp = ((uint)((Operand & 0xffff0000) >> 16) | (uint)((Operand & 0xffff) << 16));
Magic Number,CIL2Java,StackSimulator,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\StackSimulator.cs,SimulateStack,The following statement contains a magic number: uint tmp = ((uint)((Operand & 0xffff0000) >> 16) | (uint)((Operand & 0xffff) << 16));
Magic Number,CIL2Java.Java,Attribute,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attribute.cs,ReadAttribute,The following statement contains a magic number: long Next = (long)Reader.BaseStream.Position - (long)(Length - 6);
Magic Number,CIL2Java.Java,ByteCode,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\ByteCode.cs,GetMethodParamsCount,The following statement contains a magic number: Result += Array ? 1 : 2;
Magic Number,CIL2Java.Java,ByteCode,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\ByteCode.cs,GetFieldSize,The following statement contains a magic number: return 2;
Magic Number,CIL2Java.Java,Class,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Class.cs,Class,The following statement contains a magic number: MajorVersion = 49;
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: operandSize *= 2;
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following statement contains a magic number: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Magic Number,CIL2Java.Java,Method,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Method.cs,CalculateParametesSlots,The following statement contains a magic number: result += 2;
Magic Number,CIL2Java.Java.Attributes,ConstantValue,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\ConstantValue.cs,Write,The following statement contains a magic number: Writer.WriteBE((uint)2);
Magic Number,CIL2Java.Java.Attributes,Exceptions,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\Exceptions.cs,Write,The following statement contains a magic number: uint Length = (uint)(ExceptionsTable.Count * 2 + 2);
Magic Number,CIL2Java.Java.Attributes,Exceptions,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\Exceptions.cs,Write,The following statement contains a magic number: uint Length = (uint)(ExceptionsTable.Count * 2 + 2);
Magic Number,CIL2Java.Java.Attributes,InnerClasses,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\InnerClasses.cs,Write,The following statement contains a magic number: uint Length = (uint)(Classes.Count * 8) + 2;
Magic Number,CIL2Java.Java.Attributes,InnerClasses,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\InnerClasses.cs,Write,The following statement contains a magic number: uint Length = (uint)(Classes.Count * 8) + 2;
Magic Number,CIL2Java.Java.Attributes,LineNumberTable,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\LineNumberTable.cs,Write,The following statement contains a magic number: uint Length = (uint)((Table.Count * 4) + 2);
Magic Number,CIL2Java.Java.Attributes,LineNumberTable,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\LineNumberTable.cs,Write,The following statement contains a magic number: uint Length = (uint)((Table.Count * 4) + 2);
Magic Number,CIL2Java.Java.Attributes,LocalVariableTable,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\LocalVariableTable.cs,Write,The following statement contains a magic number: uint Length = (uint)(Table.Count * 10 + 2);
Magic Number,CIL2Java.Java.Attributes,LocalVariableTable,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\LocalVariableTable.cs,Write,The following statement contains a magic number: uint Length = (uint)(Table.Count * 10 + 2);
Magic Number,CIL2Java.Java.Attributes,Signature,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\Signature.cs,Write,The following statement contains a magic number: Writer.WriteBE((uint)2);
Magic Number,CIL2Java.Java.Attributes,SourceFile,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Attributes\SourceFile.cs,Write,The following statement contains a magic number: Writer.WriteBE((uint)2);
Magic Number,CIL2Java.Java.Constants,Class,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\Class.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(2);
Magic Number,CIL2Java.Java.Constants,Double,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\Double.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(8);
Magic Number,CIL2Java.Java.Constants,FieldRef,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\FieldRef.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(4);
Magic Number,CIL2Java.Java.Constants,FieldRef,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\FieldRef.cs,FillData,The following statement contains a magic number: ushort NameAndTypeIndex = BitConverterBE.ToUInt16(Data' 2);
Magic Number,CIL2Java.Java.Constants,Float,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\Float.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(4);
Magic Number,CIL2Java.Java.Constants,Integer,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\Integer.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(4);
Magic Number,CIL2Java.Java.Constants,InterfaceMethodRef,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\InterfaceMethodRef.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(4);
Magic Number,CIL2Java.Java.Constants,InterfaceMethodRef,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\InterfaceMethodRef.cs,FillData,The following statement contains a magic number: ushort NameAndTypeIndex = BitConverterBE.ToUInt16(Data' 2);
Magic Number,CIL2Java.Java.Constants,InvokeDynamic,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\InvokeDynamic.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(4);
Magic Number,CIL2Java.Java.Constants,InvokeDynamic,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\InvokeDynamic.cs,FillData,The following statement contains a magic number: NameAndType N = (NameAndType)Reader.GetFilledConstant(BitConverterBE.ToUInt16(Data' 2));
Magic Number,CIL2Java.Java.Constants,Long,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\Long.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(8);
Magic Number,CIL2Java.Java.Constants,MethodHandle,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\MethodHandle.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(3);
Magic Number,CIL2Java.Java.Constants,MethodRef,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\MethodRef.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(4);
Magic Number,CIL2Java.Java.Constants,MethodRef,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\MethodRef.cs,FillData,The following statement contains a magic number: ushort NameAndTypeIndex = BitConverterBE.ToUInt16(Data' 2);
Magic Number,CIL2Java.Java.Constants,MethodType,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\MethodType.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(2);
Magic Number,CIL2Java.Java.Constants,NameAndType,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\NameAndType.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(4);
Magic Number,CIL2Java.Java.Constants,NameAndType,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\NameAndType.cs,FillData,The following statement contains a magic number: ushort DescriptorIndex = BitConverterBE.ToUInt16(Data' 2);
Magic Number,CIL2Java.Java.Constants,String,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Constants\String.cs,ReadData,The following statement contains a magic number: return Reader.ReadBytes(2);
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileStelem,The following switch statement is missing a default case: switch (e.Code)                  {                      case ILCode.Stelem_I: operand = InterType.PrimitiveTypes[(int)(Program.AsX64 ? PrimitiveType.Int64 : PrimitiveType.Int32)]; break;                      case ILCode.Stelem_I1: operand = InterType.PrimitiveTypes[(int)PrimitiveType.SByte]; break;                      case ILCode.Stelem_I2: operand = InterType.PrimitiveTypes[(int)PrimitiveType.Int16]; break;                      case ILCode.Stelem_I4: operand = InterType.PrimitiveTypes[(int)PrimitiveType.Int32]; break;                      case ILCode.Stelem_I8: operand = InterType.PrimitiveTypes[(int)PrimitiveType.Int64]; break;                      case ILCode.Stelem_R4: operand = InterType.PrimitiveTypes[(int)PrimitiveType.Single]; break;                      case ILCode.Stelem_R8: operand = InterType.PrimitiveTypes[(int)PrimitiveType.Double]; break;                  }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileLdelem,The following switch statement is missing a default case: switch (e.Code)                  {                      case ILCode.Ldelem_I: operand = InterType.PrimitiveTypes[(int)(Program.AsX64 ? PrimitiveType.Int64 : PrimitiveType.Int32)]; break;                      case ILCode.Ldelem_I1: operand = InterType.PrimitiveTypes[(int)PrimitiveType.SByte]; break;                      case ILCode.Ldelem_I2: operand = InterType.PrimitiveTypes[(int)PrimitiveType.Int16]; break;                      case ILCode.Ldelem_I4: operand = InterType.PrimitiveTypes[(int)PrimitiveType.Int32]; break;                      case ILCode.Ldelem_I8: operand = InterType.PrimitiveTypes[(int)PrimitiveType.Int64]; break;                      case ILCode.Ldelem_R4: operand = InterType.PrimitiveTypes[(int)PrimitiveType.Single]; break;                      case ILCode.Ldelem_R8: operand = InterType.PrimitiveTypes[(int)PrimitiveType.Double]; break;                      case ILCode.Ldelem_U1: operand = InterType.PrimitiveTypes[(int)PrimitiveType.Byte]; break;                      case ILCode.Ldelem_U2: operand = InterType.PrimitiveTypes[(int)PrimitiveType.UInt16]; break;                      case ILCode.Ldelem_U4: operand = InterType.PrimitiveTypes[(int)PrimitiveType.UInt32]; break;                  }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCall,The following switch statement is missing a default case: switch (callType)              {                  case CallType.Interface:                      codeGenerator.AddInstruction(new JavaInstruction(Java.OpCodes.invokeinterface' javaOperand' e));                      break;                    case CallType.Special:                      codeGenerator.AddInstruction(new JavaInstruction(Java.OpCodes.invokespecial' javaOperand' e));                      break;                    case CallType.Static:                      codeGenerator.AddInstruction(new JavaInstruction(Java.OpCodes.invokestatic' javaOperand' e));                      break;                    case CallType.Virtual:                      codeGenerator.AddInstruction(new JavaInstruction(Java.OpCodes.invokevirtual' javaOperand' e));                      break;              }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileJmp,The following switch statement is missing a default case: switch (callType)              {                  case CallType.Interface:                      codeGenerator.AddInstruction(new JavaInstruction(Java.OpCodes.invokeinterface' javaOperand' e));                      break;                    case CallType.Special:                      codeGenerator.AddInstruction(new JavaInstruction(Java.OpCodes.invokespecial' javaOperand' e));                      break;                    case CallType.Static:                      codeGenerator.AddInstruction(new JavaInstruction(Java.OpCodes.invokestatic' javaOperand' e));                      break;                    case CallType.Virtual:                      codeGenerator.AddInstruction(new JavaInstruction(Java.OpCodes.invokevirtual' javaOperand' e));                      break;              }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileCondition,The following switch statement is missing a default case: switch (gettedType)                  {                      case JavaPrimitiveType.Double: codeGenerator.Add(Java.OpCodes.d2i' null' e); break;                      case JavaPrimitiveType.Float: codeGenerator.Add(Java.OpCodes.f2i' null' e); break;                      case JavaPrimitiveType.Long: codeGenerator.Add(Java.OpCodes.l2i' null' e); break;                      case JavaPrimitiveType.Ref: branchCode = invert ? OpCodes.ifnull : OpCodes.ifnonnull; break;                  }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,TranslateToBool,The following switch statement is missing a default case: switch (gettedType)              {                  case JavaPrimitiveType.Double: codeGenerator.Add(Java.OpCodes.d2i' null' tag); break;                  case JavaPrimitiveType.Float: codeGenerator.Add(Java.OpCodes.f2i' null' tag); break;                  case JavaPrimitiveType.Long: codeGenerator.Add(Java.OpCodes.l2i' null' tag); break;                  case JavaPrimitiveType.Ref: cmpOp = (cmpOp == Java.OpCodes.ifne ? Java.OpCodes.ifnonnull : Java.OpCodes.ifnull); break;              }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileFlowB,The following switch statement is missing a default case: switch (prim)                  {                      case JavaPrimitiveType.Bool:                      case JavaPrimitiveType.Byte:                          modifOp = () => codeGenerator.AddIntConst(0x80' e).Add(OpCodes.ixor' null' e);                          break;                        case JavaPrimitiveType.Short:                          modifOp = () => codeGenerator.AddIntConst(0x8000' e).Add(OpCodes.ixor' null' e);                          break;                        case JavaPrimitiveType.Int:                          modifOp = () => codeGenerator.AddIntConst((unchecked((int)0x80000000))' e).Add(OpCodes.ixor' null' e);                          break;                        case JavaPrimitiveType.Long:                          modifOp = () => codeGenerator.AddLongConst((unchecked((long)0x8000000000000000))' e).Add(OpCodes.lxor' null' e);                          break;                  }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileFlowC,The following switch statement is missing a default case: switch (jpt)                  {                      case JavaPrimitiveType.Bool:                      case JavaPrimitiveType.Byte:                          modifOp = () => codeGenerator.AddIntConst(0x80' e).Add(OpCodes.ixor' null' e);                          break;                        case JavaPrimitiveType.Short:                          modifOp = () => codeGenerator.AddIntConst(0x8000' e).Add(OpCodes.ixor' null' e);                          break;                        case JavaPrimitiveType.Int:                          modifOp = () => codeGenerator.AddIntConst((unchecked((int)0x80000000))' e).Add(OpCodes.ixor' null' e);                          break;                        case JavaPrimitiveType.Long:                          modifOp = () => codeGenerator.AddLongConst((unchecked((long)0x8000000000000000))' e).Add(OpCodes.lxor' null' e);                          break;                  }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileFlowC,The following switch statement is missing a default case: switch (jpt)              {                  case JavaPrimitiveType.Bool:                  case JavaPrimitiveType.Byte:                  case JavaPrimitiveType.Char:                  case JavaPrimitiveType.Short:                  case JavaPrimitiveType.Int:                      codeGenerator.Add(IntCmp' trueLabel' e);                      break;                    case JavaPrimitiveType.Ref: codeGenerator.Add(RefCmp' trueLabel' e); break;                    case JavaPrimitiveType.Long: codeGenerator.Add(Java.OpCodes.lcmp' null' e).Add(OtherCmp' trueLabel' e); break;                  case JavaPrimitiveType.Float: codeGenerator.Add(Java.OpCodes.fcmpg' null' e).Add(OtherCmp' trueLabel' e); break;                  case JavaPrimitiveType.Double: codeGenerator.Add(Java.OpCodes.dcmpg' null' e).Add(OtherCmp' trueLabel' e); break;              }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileMath,The following switch statement is missing a default case: switch (e.Code)                  {                      case ILCode.Add_Ovf: methodName = "Add_Ovf"; break;                      case ILCode.Add_Ovf_Un: methodName = "Add_Ovf_Un"; break;                      case ILCode.Sub_Ovf: methodName = "Sub_Ovf"; break;                      case ILCode.Sub_Ovf_Un: methodName = "Sub_Ovf_Un"; break;                      case ILCode.Mul_Ovf: methodName = "Mul_Ovf"; break;                      case ILCode.Mul_Ovf_Un: methodName = "Mul_Ovf_Un"; break;                  }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileMath,The following switch statement is missing a default case: switch (jp)                  {                      case JavaPrimitiveType.Bool:                      case JavaPrimitiveType.Byte: methodDescriptor = "(BB)B"; break;                      case JavaPrimitiveType.Char: methodDescriptor = "(CC)C"; break;                      case JavaPrimitiveType.Int: methodDescriptor = "(II)I"; break;                      case JavaPrimitiveType.Long: methodDescriptor = "(JJ)J"; break;                      case JavaPrimitiveType.Short: methodDescriptor = "(SS)S"; break;                  }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileMath,The following switch statement is missing a default case: switch (jp)              {                  case JavaPrimitiveType.Long: opcode = longOp; break;                  case JavaPrimitiveType.Float: opcode = floatOp; break;                  case JavaPrimitiveType.Double: opcode = doubleOp; break;                    case JavaPrimitiveType.Ref:                      throw new Exception();  //TODO: normal error              }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileNeg,The following switch statement is missing a default case: switch (jp)              {                  case JavaPrimitiveType.Long: opcode = OpCodes.lneg; break;                  case JavaPrimitiveType.Float: opcode = OpCodes.fneg; break;                  case JavaPrimitiveType.Double: opcode = OpCodes.dneg; break;                    case JavaPrimitiveType.Ref:                      throw new Exception();  //TODO: normal error              }
Missing Default,CIL2Java,CodeCompiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\CodeCompiler.cs,CompileInitobj,The following switch statement is missing a default case: switch (jp)                  {                      case JavaPrimitiveType.Bool:                      case JavaPrimitiveType.Byte:                      case JavaPrimitiveType.Char:                      case JavaPrimitiveType.Int:                      case JavaPrimitiveType.Short:                          codeGenerator.AddIntConst(0' e);                          break;                        case JavaPrimitiveType.Long: codeGenerator.AddLongConst(0L' e); break;                      case JavaPrimitiveType.Float: codeGenerator.AddFloatConst(0.0f' e); break;                      case JavaPrimitiveType.Double: codeGenerator.AddDoubleConst(0.0' e); break;                      case JavaPrimitiveType.Ref: codeGenerator.Add(OpCodes.aconst_null' e); break;                  }
Missing Default,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,GenerateByRefTypesCode,The following switch statement is missing a default case: switch (javaType.place)                  {                      case ByRefPlace.Unknown: GenerateBaseByRefType(javaType.type); break;                      case ByRefPlace.Local: GenerateLocalByRefType(javaType.type); break;                      case ByRefPlace.Field: GenerateFieldByRefType(javaType.type); break;                      case ByRefPlace.Array: GenerateArrayByRefType(javaType.type); break;                  }
Missing Default,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,ProcessMethodDecencies,The following switch statement is missing a default case: switch (e.Code)                          {                              case ILCode.Ldflda:                              case ILCode.Ldsflda:                                  if (fld.FieldType.IsValueType)                                      fld.DeclaringType.AddFieldAccessor(new FieldAccessor(FieldAccessorType.Getter' fld));                                  break;                                case ILCode.Ldfld:                              case ILCode.Ldsfld:                                  fld.DeclaringType.AddFieldAccessor(new FieldAccessor(FieldAccessorType.Getter' fld));                                  break;                                case ILCode.Stfld:                              case ILCode.Stsfld:                                  fld.DeclaringType.AddFieldAccessor(new FieldAccessor(FieldAccessorType.Setter' fld));                                  break;                          }
Missing Default,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,Resolve,The following switch statement is missing a default case: switch (typeRef.MetadataType)              {                  case MetadataType.Boolean: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.Bool]; break;                  case MetadataType.Byte: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.Byte]; break;                  case MetadataType.Char: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.Char]; break;                  case MetadataType.Double: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.Double]; break;                  case MetadataType.Int16: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.Int16]; break;                  case MetadataType.Int32: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.Int32]; break;                  case MetadataType.Int64: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.Int64]; break;                  case MetadataType.IntPtr: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.IntPtr]; break;                  case MetadataType.SByte: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.SByte]; break;                  case MetadataType.Single: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.Single]; break;                  case MetadataType.UInt16: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.UInt16]; break;                  case MetadataType.UInt32: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.UInt32]; break;                  case MetadataType.UInt64: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.UInt64]; break;                  case MetadataType.UIntPtr: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.UIntPtr]; break;                  case MetadataType.Void: primitive = InterType.PrimitiveTypes[(int)PrimitiveType.Void]; break;              }
Missing Default,CIL2Java,Compiler,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler.cs,GenerateValueTypeEquals,The following switch statement is missing a default case: switch (JavaHelpers.InterTypeToJavaPrimitive(fld.FieldType))                      {                          case JavaPrimitiveType.Bool:                          case JavaPrimitiveType.Byte:                          case JavaPrimitiveType.Char:                          case JavaPrimitiveType.Int:                          case JavaPrimitiveType.Short:                              codeGenerator.Add(OpCodes.if_icmpne' "false");                              break;                            case JavaPrimitiveType.Long:                              codeGenerator.Add(OpCodes.lcmp).Add(OpCodes.ifne' "false");                              break;                            case JavaPrimitiveType.Float:                              codeGenerator.Add(OpCodes.fcmpg).Add(OpCodes.ifne' "false");                              break;                            case JavaPrimitiveType.Double:                              codeGenerator.Add(OpCodes.dcmpg).Add(OpCodes.ifne' "false");                              break;                      }
Missing Default,CIL2Java,JavaByRefType,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler\Compiler.ByRef.cs,ToString,The following switch statement is missing a default case: switch (place)                  {                      case ByRefPlace.Local: result.Append(ClassNames.ByRef.PlaceLocal); break;                      case ByRefPlace.Field: result.Append(ClassNames.ByRef.PlaceField); break;                      case ByRefPlace.Array: result.Append(ClassNames.ByRef.PlaceArray); break;                  }
Missing Default,CIL2Java,JavaByRefType,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Compiler\Compiler.ByRef.cs,ToString,The following switch statement is missing a default case: switch (type)                  {                      case JavaPrimitiveType.Bool: result.Append(ClassNames.ByRef.TypeBool); break;                      case JavaPrimitiveType.Byte: result.Append(ClassNames.ByRef.TypeByte); break;                      case JavaPrimitiveType.Char: result.Append(ClassNames.ByRef.TypeChar); break;                      case JavaPrimitiveType.Double: result.Append(ClassNames.ByRef.TypeDouble); break;                      case JavaPrimitiveType.Float: result.Append(ClassNames.ByRef.TypeFloat); break;                      case JavaPrimitiveType.Int: result.Append(ClassNames.ByRef.TypeInt); break;                      case JavaPrimitiveType.Long: result.Append(ClassNames.ByRef.TypeLong); break;                      case JavaPrimitiveType.Ref: result.Append(ClassNames.ByRef.TypeRef); break;                      case JavaPrimitiveType.Short: result.Append(ClassNames.ByRef.TypeShort); break;                  }
Missing Default,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The following switch statement is missing a default case: switch (descr.OpType)                  {                      case Java.ByteCode.JavaOperandType.ConstValue:                          switch (operandSize)                          {                              case 1: codeBytesWriter.Write((sbyte)instr.Operand); break;                              case 2: codeBytesWriter.WriteBE((short)instr.Operand); break;                              case 4: codeBytesWriter.WriteBE((int)instr.Operand); break;                          }                          break;                        case Java.ByteCode.JavaOperandType.ConstPool:                          if (operandSize == 1)                              codeBytesWriter.Write((byte)((ushort)instr.Operand));                          else                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.LocalVar:                          if (instr.Operand is ushort)                              codeBytesWriter.WriteBE((ushort)instr.Operand);                          else                              codeBytesWriter.Write((byte)instr.Operand);                          break;                        case Java.ByteCode.JavaOperandType.Offset:                          if (instr.Operand is string)                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[outputCode[labels[(string)instr.Operand]]] - outputCodeOffsets[instr]));                          else                              codeBytesWriter.WriteBE((short)(outputCodeOffsets[(JavaInstruction)instr.Operand] - outputCodeOffsets[instr]));                          break;                        case Java.ByteCode.JavaOperandType.Special:                          switch (instr.Opcode)                          {                              case Java.OpCodes.iinc:                                  if (instr.Operand is int)                                      codeBytesWriter.WriteBE((int)instr.Operand);                                  else                                      codeBytesWriter.WriteBE((short)instr.Operand);                                  break;                                case Java.OpCodes.tableswitch:                                  //TODO: Java.OpCodes.tableswitch                                  break;                                case Java.OpCodes.lookupswitch:                                  LookupswitchOperand lookUpOperand = (LookupswitchOperand)instr.Operand;                                    int padding = (4 - ((outputCodeOffsets[instr] + 1) % 4)) % 4;                                  codeBytesWriter.Write(new byte[padding]);                                  codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.DefaultLabel]]] - outputCodeOffsets[instr]);                                  codeBytesWriter.WriteBE(lookUpOperand.Pairs.Length);                                    for (int j = 0; j < lookUpOperand.Pairs.Length; j++)                                  {                                      codeBytesWriter.WriteBE(lookUpOperand.Pairs[j].Item1);                                      codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.Pairs[j].Item2]]] - outputCodeOffsets[instr]);                                  }                                    break;                                case Java.OpCodes.invokeinterface:                              case Java.OpCodes.invokedynamic:                                  uint op = (uint)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(op & 0xfff));                                  codeBytesWriter.WriteBE((ushort)(op >> 16));                                  break;                                case Java.OpCodes.newarray:                                  codeBytesWriter.Write((byte)instr.Operand);                                  break;                                case Java.OpCodes.wide:                                  break;                                case Java.OpCodes.multianewarray:                                  int data = (int)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(data & 0xffff));                                  codeBytesWriter.Write((byte)((data & 0xff0000) >> 16));                                  break;                          }                          break;                  }
Missing Default,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The following switch statement is missing a default case: switch (operandSize)                          {                              case 1: codeBytesWriter.Write((sbyte)instr.Operand); break;                              case 2: codeBytesWriter.WriteBE((short)instr.Operand); break;                              case 4: codeBytesWriter.WriteBE((int)instr.Operand); break;                          }
Missing Default,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,LinkPass2,The following switch statement is missing a default case: switch (instr.Opcode)                          {                              case Java.OpCodes.iinc:                                  if (instr.Operand is int)                                      codeBytesWriter.WriteBE((int)instr.Operand);                                  else                                      codeBytesWriter.WriteBE((short)instr.Operand);                                  break;                                case Java.OpCodes.tableswitch:                                  //TODO: Java.OpCodes.tableswitch                                  break;                                case Java.OpCodes.lookupswitch:                                  LookupswitchOperand lookUpOperand = (LookupswitchOperand)instr.Operand;                                    int padding = (4 - ((outputCodeOffsets[instr] + 1) % 4)) % 4;                                  codeBytesWriter.Write(new byte[padding]);                                  codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.DefaultLabel]]] - outputCodeOffsets[instr]);                                  codeBytesWriter.WriteBE(lookUpOperand.Pairs.Length);                                    for (int j = 0; j < lookUpOperand.Pairs.Length; j++)                                  {                                      codeBytesWriter.WriteBE(lookUpOperand.Pairs[j].Item1);                                      codeBytesWriter.WriteBE(outputCodeOffsets[outputCode[labels[lookUpOperand.Pairs[j].Item2]]] - outputCodeOffsets[instr]);                                  }                                    break;                                case Java.OpCodes.invokeinterface:                              case Java.OpCodes.invokedynamic:                                  uint op = (uint)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(op & 0xfff));                                  codeBytesWriter.WriteBE((ushort)(op >> 16));                                  break;                                case Java.OpCodes.newarray:                                  codeBytesWriter.Write((byte)instr.Operand);                                  break;                                case Java.OpCodes.wide:                                  break;                                case Java.OpCodes.multianewarray:                                  int data = (int)instr.Operand;                                  codeBytesWriter.WriteBE((ushort)(data & 0xffff));                                  codeBytesWriter.Write((byte)((data & 0xff0000) >> 16));                                  break;                          }
Missing Default,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,AddLocalVarLoad,The following switch statement is missing a default case: switch (varType)              {                  case JavaPrimitiveType.Bool:                  case JavaPrimitiveType.Byte:                  case JavaPrimitiveType.Char:                  case JavaPrimitiveType.Short:                  case JavaPrimitiveType.Int:                      shortOpcode = Java.OpCodes.iload_0;                      longOpcode = Java.OpCodes.iload;                      break;                    case JavaPrimitiveType.Long:                      shortOpcode = Java.OpCodes.lload_0;                      longOpcode = Java.OpCodes.lload;                      break;                    case JavaPrimitiveType.Float:                      shortOpcode = Java.OpCodes.fload_0;                      longOpcode = Java.OpCodes.fload;                      break;                    case JavaPrimitiveType.Double:                      shortOpcode = Java.OpCodes.dload_0;                      longOpcode = Java.OpCodes.dload;                      break;              }
Missing Default,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,AddLocalVarStore,The following switch statement is missing a default case: switch (varType)              {                  case JavaPrimitiveType.Bool:                  case JavaPrimitiveType.Byte:                  case JavaPrimitiveType.Char:                  case JavaPrimitiveType.Short:                  case JavaPrimitiveType.Int:                      shortOpcode = Java.OpCodes.istore_0;                      longOpcode = Java.OpCodes.istore;                      break;                    case JavaPrimitiveType.Long:                      shortOpcode = Java.OpCodes.lstore_0;                      longOpcode = Java.OpCodes.lstore;                      break;                    case JavaPrimitiveType.Float:                      shortOpcode = Java.OpCodes.fstore_0;                      longOpcode = Java.OpCodes.fstore;                      break;                    case JavaPrimitiveType.Double:                      shortOpcode = Java.OpCodes.dstore_0;                      longOpcode = Java.OpCodes.dstore;                      break;              }
Missing Default,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,AddReturn,The following switch statement is missing a default case: switch (jp)              {                  case JavaPrimitiveType.Bool:                  case JavaPrimitiveType.Byte:                  case JavaPrimitiveType.Char:                  case JavaPrimitiveType.Int:                  case JavaPrimitiveType.Short:                      opcode = Java.OpCodes.ireturn;                      break;                    case JavaPrimitiveType.Long: opcode = Java.OpCodes.lreturn; break;                  case JavaPrimitiveType.Float: opcode = Java.OpCodes.freturn; break;                  case JavaPrimitiveType.Double: opcode = Java.OpCodes.dreturn; break;                  case JavaPrimitiveType.Void: opcode = Java.OpCodes._return; break;              }
Missing Default,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,AddDefaultValue,The following switch statement is missing a default case: switch (jp)              {                  case JavaPrimitiveType.Bool:                  case JavaPrimitiveType.Byte:                  case JavaPrimitiveType.Char:                  case JavaPrimitiveType.Int:                  case JavaPrimitiveType.Short:                      opcode = Java.OpCodes.iconst_0;                      break;                    case JavaPrimitiveType.Long:                      opcode = Java.OpCodes.lconst_0;                      break;                    case JavaPrimitiveType.Float:                      opcode = Java.OpCodes.fconst_0;                      break;                    case JavaPrimitiveType.Double:                      opcode = Java.OpCodes.dconst_0;                      break;              }
Missing Default,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,AddArrayStore,The following switch statement is missing a default case: switch (arrType)              {                  case JavaArrayType.Boolean: opcode = Java.OpCodes.bastore; break;                  case JavaArrayType.Byte: opcode = Java.OpCodes.bastore; break;                  case JavaArrayType.Char: opcode = Java.OpCodes.castore; break;                  case JavaArrayType.Double: opcode = Java.OpCodes.dastore; break;                  case JavaArrayType.Float: opcode = Java.OpCodes.fastore; break;                  case JavaArrayType.Int: opcode = Java.OpCodes.iastore; break;                  case JavaArrayType.Long: opcode = Java.OpCodes.lastore; break;                  case JavaArrayType.Short: opcode = Java.OpCodes.sastore; break;              }
Missing Default,CIL2Java,JavaBytecodeWriter,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\JavaBytecodeWriter.cs,AddArrayLoad,The following switch statement is missing a default case: switch (arrType)              {                  case JavaArrayType.Boolean: opcode = Java.OpCodes.baload; break;                  case JavaArrayType.Byte: opcode = Java.OpCodes.baload; break;                  case JavaArrayType.Char: opcode = Java.OpCodes.caload; break;                  case JavaArrayType.Double: opcode = Java.OpCodes.daload; break;                  case JavaArrayType.Float: opcode = Java.OpCodes.faload; break;                  case JavaArrayType.Int: opcode = Java.OpCodes.iaload; break;                  case JavaArrayType.Long: opcode = Java.OpCodes.laload; break;                  case JavaArrayType.Short: opcode = Java.OpCodes.saload; break;              }
Missing Default,CIL2Java,Utils,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Utils.cs,GetJavaTypeName,The following switch statement is missing a default case: switch (pt)              {                  case PrimitiveType.Bool: prefix = "boolean"; break;                  case PrimitiveType.Char: prefix = "char"; break;                  case PrimitiveType.Double: prefix = "double"; break;                    case PrimitiveType.SByte:                  case PrimitiveType.Byte:                      prefix = "byte";                      break;                    case PrimitiveType.Int16:                  case PrimitiveType.UInt16:                      prefix = "short";                      break;                    case PrimitiveType.Int32:                  case PrimitiveType.UInt32:                      prefix = "int";                      break;                    case PrimitiveType.Int64:                  case PrimitiveType.UInt64:                      prefix = "long";                      break;                    case PrimitiveType.Single:                      prefix = "float";                      break;              }
Missing Default,CIL2Java,Utils,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Utils.cs,IsConv,The following switch statement is missing a default case: switch (il)              {                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_I:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_I1:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_I2:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_I4:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_I8:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_I:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_I_Un:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_I1:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_I1_Un:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_I2:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_I2_Un:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_I4:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_I4_Un:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_I8:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_I8_Un:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_U:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_U_Un:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_U1:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_U1_Un:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_U2:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_U2_Un:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_U4:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_U4_Un:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_U8:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_Ovf_U8_Un:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_R_Un:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_R4:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_R8:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_U:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_U1:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_U2:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_U4:                  case ICSharpCode.Decompiler.ILAst.ILCode.Conv_U8:                      return true;              }
Missing Default,CIL2Java,Utils,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Utils.cs,IsExternalRealization,The following switch statement is missing a default case: switch (self)              {                  case ILCode.Div_Un:                  case ILCode.Rem_Un:                  case ILCode.Ckfinite:                  case ILCode.Cpblk:                  case ILCode.Initblk:                      return true;              }
Missing Default,CIL2Java.Java,ConstantPoolReader,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\ConstantPoolReader.cs,Read,The following switch statement is missing a default case: switch (Tag)                  {                      case ConstantTag.Utf8:                  Result = new Constants.Utf8(); break;                      case ConstantTag.Integer:               Result = new Constants.Integer(); break;                      case ConstantTag.Float:                 Result = new Constants.Float(); break;                      case ConstantTag.Long:                  Result = new Constants.Long(); break;                      case ConstantTag.Double:                Result = new Constants.Double(); break;                      case ConstantTag.Class:                 Result = new Constants.Class(); break;                      case ConstantTag.String:                Result = new Constants.String(); break;                      case ConstantTag.FieldRef:              Result = new Constants.FieldRef(); break;                      case ConstantTag.MethodRef:             Result = new Constants.MethodRef(); break;                      case ConstantTag.InterfaceMethodRef:    Result = new Constants.InterfaceMethodRef(); break;                      case ConstantTag.NameAndType:           Result = new Constants.NameAndType(); break;                      case ConstantTag.MethodHandle:          Result = new Constants.MethodHandle(); break;                      case ConstantTag.MethodType:            Result = new Constants.MethodType(); break;                      case ConstantTag.InvokeDynamic:         Result = new Constants.InvokeDynamic(); break;                  }
Missing Default,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following switch statement is missing a default case: switch (descr.OpType)                  {                      case ByteCode.JavaOperandType.ConstPool:                          ushort index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = pool[index].ToString();                          break;                        case ByteCode.JavaOperandType.ConstValue:                      case ByteCode.JavaOperandType.LocalVar:                          operandStr = BitConverterBE.ReadAsInt32(code' i + 1' operandSize).ToString();                          break;                        case ByteCode.JavaOperandType.Offset:                          short offset = (short)BitConverterBE.ReadAsInt32(code' i + 1' operandSize);                          operandStr = String.Format("{0'4:X}"' (i + offset));                          break;                        case ByteCode.JavaOperandType.Special:                          switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          };                          break;                  }
Missing Default,CIL2Java.Java,Dumper,D:\research\architectureSmells\repos\zebraxxl_CIL2Java\CIL2Java\Java\Dumper.cs,Disasm,The following switch statement is missing a default case: switch (op)                          {                              case OpCodes.iinc:                                  int op1 = BitConverterBE.ReadAsInt32(code' i + 1' operandSize / 2);                                  int op2 = BitConverterBE.ReadAsInt32(code' i + 1 + operandSize / 2' operandSize / 2);                                  operandStr = String.Format("{0}' {1}"' op1' op2);                                  break;                                case OpCodes.lookupswitch:                                  int paddingLength = (4 - ((i + 1) % 4)) % 4;                                  int _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int npairs = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int pairsStart = i + paddingLength + 9;                                  operandSize = npairs * 8 + 8 + paddingLength;                                    writer.WriteLine(" default: {0'4:X}' npairs: {1}"' _default' npairs);                                    for (int pair = 0; pair < npairs; pair++)                                  {                                      int pairValue = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8)' 4);                                      int pairOffset = BitConverterBE.ReadAsInt32(code' pairsStart + (pair * 8) + 4' 4);                                        writer.WriteLine("                     {0'4:X} : {1}"' pairOffset' pairValue);                                  }                                  break;                                case OpCodes.tableswitch:                                  paddingLength = (4 - ((i + 1) % 4)) % 4;                                  _default = BitConverterBE.ReadAsInt32(code' i + paddingLength + 1' 4);                                  int low = BitConverterBE.ReadAsInt32(code' i + paddingLength + 5' 4);                                  int hight = BitConverterBE.ReadAsInt32(code' i + paddingLength + 9' 4);                                    writer.WriteLine(" default: {0'4:X}' low: {1}' hight: {2}"' _default' low' hight);                                  int jmpCount = hight - low + 1;                                  int jmpStart = i + paddingLength + 13;                                  operandSize = jmpCount * 4 + 13 + paddingLength;                                    for (int jmp = 0; jmp < jmpCount; jmp++)                                      writer.WriteLine("                     {0'4:X} : {1}"' BitConverterBE.ReadAsInt32(code' jmpStart + jmp * 4' 4)' low + jmp);                                  break;                                case OpCodes.invokeinterface:                              case OpCodes.invokedynamic:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  operandStr = pool[index].ToString();                                  break;                                case OpCodes.newarray:                                  operandStr = ArrayTypes[code[i + 1]];                                  break;                                case OpCodes.multianewarray:                                  index = (ushort)BitConverterBE.ReadAsInt32(code' i + 1' 2);                                  byte dismensions = code[i + 3];                                  operandStr = String.Format("{0}' {1}"' dismensions' pool[index].ToString());                                  break;                          }
