Implementation smell,Namespace,Class,File,Method,Description
Long Method,Manos,ManosMimeTypes,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\ManosMimeTypes.cs,ManosMimeTypes,The method has 498 lines of code.
Long Method,Manos.Http,HttpMultiPartFormDataHandler,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpMultiPartFormDataHandler.cs,HandleData,The method has 101 lines of code.
Long Method,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The method has 1020 lines of code.
Long Method,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The method has 132 lines of code.
Long Method,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,InitHtmlEntities,The method has 258 lines of code.
Complex Method,Manos,ManosModule,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\ManosModule.cs,AddImplicitRoutes,Cyclomatic complexity of the method is 9
Complex Method,Manos,Pipeline,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\Pipeline.cs,StepCompleted,Cyclomatic complexity of the method is 9
Complex Method,Manos,UnsafeString,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\UnsafeString.cs,Escape,Cyclomatic complexity of the method is 24
Complex Method,Manos.Http,HttpCookie,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpCookie.cs,ToHeaderString,Cyclomatic complexity of the method is 8
Complex Method,Manos.Http,HttpFormDataHandler,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpFormDataHandler.cs,HandleData,Cyclomatic complexity of the method is 11
Complex Method,Manos.Http,HttpMultiPartFormDataHandler,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpMultiPartFormDataHandler.cs,HandleData,Cyclomatic complexity of the method is 58
Complex Method,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,HttpParser,Cyclomatic complexity of the method is 11
Complex Method,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,Cyclomatic complexity of the method is 526
Complex Method,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,start_req_method_assign,Cyclomatic complexity of the method is 11
Complex Method,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,header_almost_done,Cyclomatic complexity of the method is 12
Complex Method,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,headers_almost_done,Cyclomatic complexity of the method is 12
Complex Method,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,parsing_header,Cyclomatic complexity of the method is 9
Complex Method,Manos.Http,HttpHeaders,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpHeaders.cs,Parse,Cyclomatic complexity of the method is 9
Complex Method,Manos.Http,HttpHeaders,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpHeaders.cs,NormalizeName,Cyclomatic complexity of the method is 8
Complex Method,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,Cyclomatic complexity of the method is 46
Complex Method,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,Cyclomatic complexity of the method is 8
Complex Method,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,ParseUrlEncodedData,Cyclomatic complexity of the method is 11
Complex Method,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,Cyclomatic complexity of the method is 21
Complex Method,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlEncode,Cyclomatic complexity of the method is 29
Complex Method,Manos.Routing,RouteHandler,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\RouteHandler.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,CreateAction,Cyclomatic complexity of the method is 8
Complex Method,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,EmitFastInt,Cyclomatic complexity of the method is 21
Complex Method,Manos.Routing,ParameterizedActionTarget,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionTarget.cs,TryConvertType,Cyclomatic complexity of the method is 12
Complex Method,Manos.Routing,SimpleMatchOperation,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\SimpleMatchOperation.cs,IsMatch,Cyclomatic complexity of the method is 10
Complex Method,Manos.Collections,DataDictionary,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Collections\DataDictionary.cs,Set,Cyclomatic complexity of the method is 8
Complex Method,Manos.Templates,TemplateParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Template\TemplateParser.cs,ParsePage,Cyclomatic complexity of the method is 19
Complex Method,Manos.Templates,TemplateParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Template\TemplateParser.cs,ParseStatement,Cyclomatic complexity of the method is 33
Complex Method,Manos.Templates,TemplateTokenizer,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Template\TemplateTokenizer.cs,_GetNextToken,Cyclomatic complexity of the method is 10
Complex Method,Manos.Templates,TemplateTokenizer,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Template\TemplateTokenizer.cs,UpdateInCodeBlock,Cyclomatic complexity of the method is 10
Long Parameter List,Manos,AppHost,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\AppHost.cs,AddTimeout,The method has 5 parameters.
Long Parameter List,Manos,Timeout,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\Timeout.cs,Timeout,The method has 5 parameters.
Long Parameter List,Manos.Http,ParserSettings,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\ParserSettings.cs,Raise,The method has 5 parameters.
Long Parameter List,Manos.Routing,StringMatchOperation,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\StringMatchOperation.cs,IsMatchInternal,The method has 5 parameters.
Long Parameter List,Manos.Routing,ParameterizedActionTarget,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionTarget.cs,TryConvertUnsafeString,The method has 5 parameters.
Long Parameter List,Manos.Templates,Token,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Template\TemplateTokenizer.cs,Token,The method has 5 parameters.
Long Statement,Manos,ManosConfig,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\ManosConfig.cs,Load,The length of the statement  "	string source = Environment.GetEnvironmentVariable ("MANOS_CONFIG") ?? Path.Combine (Environment.CurrentDirectory' "manos.config"); " is 131.
Long Statement,Manos.Http,HttpFormDataHandler,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpFormDataHandler.cs,FinishPair,The length of the statement  "	entity.PostData.Set (HttpUtility.UrlDecode (key_buffer.ToString ()' e)' HttpUtility.UrlDecode (value_buffer.ToString ()' e)); " is 125.
Long Statement,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The length of the statement  "		/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start: " is 121.
Long Statement,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The length of the statement  "		/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: { " is 130.
Long Statement,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The length of the statement  "		/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start: " is 121.
Long Statement,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The length of the statement  "		 * message' inform the callbacks about the progress made so far*/settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark); " is 147.
Long Statement,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,AddBasicAuthentication,The length of the statement  "	entity.Headers.SetNormalizedHeader ("Authorization"' "Basic " + Convert.ToBase64String (Encoding.ASCII.GetBytes (authd))); " is 122.
Long Statement,Manos.Logging,ManosConsoleLogger,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Logging\ManosConsoleLogger.cs,WriteString,The length of the statement  "	Console.WriteLine (String.Format ("{0} [{1}] {2} - {3}"' DateTime.Now.ToString ("HH':'mm':'ss'.'fffffff")' level' name' fmt)); " is 126.
Long Statement,Manos.Templates,TemplateParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Template\TemplateParser.cs,ParseVariable,The length of the statement  "		RaiseFailure (tk' String.Format ("Invalid variable statement found' '{0}' token found when a {1} was expected."' tk.Current.Value' environment.VariableEndString)); " is 163.
Complex Conditional,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlEncode,The conditional expression  "c == '&' || c == '"' || c == '<' || c == '>' || c > 159 || c == '\''"  is complex.
Magic Number,Manos,AppHost,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\AppHost.cs,InitializeTLS,The following statement contains a magic number: RegenerateDHParams (1024);  
Magic Number,Manos,Pipeline,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\Pipeline.cs,Execute,The following statement contains a magic number: if (handler == null) {  	ctx.Response.StatusCode = 404;  	ctx.Response.End (app.Get404Response ());  	return;  }  
Magic Number,Manos,Pipeline,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\Pipeline.cs,Execute,The following statement contains a magic number: ctx.Response.StatusCode = 404;  
Magic Number,Manos,Pipeline,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\Pipeline.cs,Execute,The following statement contains a magic number: ctx.Response.StatusCode = 200;  
Magic Number,Manos,Pipeline,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\Pipeline.cs,Execute,The following statement contains a magic number: try {  	handler.Invoke (app' ctx);  } catch (Exception e) {  	Console.Error.WriteLine ("Exception in transaction handler:");  	Console.Error.WriteLine (e);  	ctx.Response.StatusCode = 500;  	ctx.Response.End (app.Get500Response ());  	//  	// TODO: Maybe the cleanest thing to do is  	// have a HandleError' HandleException thing  	// on HttpTransaction' along with an UnhandledException  	// method/event on ManosModule.  	//  	// end = true;  }  
Magic Number,Manos,Pipeline,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\Pipeline.cs,Execute,The following statement contains a magic number: ctx.Response.StatusCode = 500;  
Magic Number,Manos,Pipeline,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\Pipeline.cs,Execute,The following statement contains a magic number: if (ctx.Response.StatusCode == 404) {  	step = PipelineStep.WaitingForEnd;  	ctx.Response.End ();  	return;  }  
Magic Number,Manos.Http,HttpMethodBytes,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpMethod.cs,Init,The following statement contains a magic number: methods [method] = Encoding.ASCII.GetBytes (method.ToString ().Substring (5));  
Magic Number,Manos.Http,HttpMultiPartFormDataHandler,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpMultiPartFormDataHandler.cs,FinishFormData,The following statement contains a magic number: if (form_data.Count <= 2)  	return;  
Magic Number,Manos.Http,HttpMultiPartFormDataHandler,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpMultiPartFormDataHandler.cs,FinishFormData,The following statement contains a magic number: form_data.RemoveRange (form_data.Count - 2' 2);  
Magic Number,Manos.Http,HttpMultiPartFormDataHandler,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpMultiPartFormDataHandler.cs,FinishFormData,The following statement contains a magic number: form_data.RemoveRange (form_data.Count - 2' 2);  
Magic Number,Manos.Http,HttpMultiPartFormDataHandler,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpMultiPartFormDataHandler.cs,FinishFileData,The following statement contains a magic number: uploaded_file.Contents.SetLength (uploaded_file.Contents.Position - 2);  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: while (data.Length > 0) {  	p = (int)data.Position;  	int pe = (int)data.Length;  	byte ch = 0;  	// the current character to process.  	int c = -1;  	// utility variably used for up- and downcasing etc.  	int to_read = 0;  	// used to keep track of how much of body' etc. is left to read  	if (state != State.body_identity)  		ch = data.ReadByte ();  	if (parsing_header (state)) {  		++nread;  		if (nread > HTTP_MAX_HEADER_SIZE) {  			settings.RaiseOnError (this' "possible buffer overflow"' data' p_err);  		}  	}  	switch (state) {  	/* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  		settings.RaiseOnError (this' "Connection already closed"' data' p_err);  		// JACKSON: Added this break  		break;  	case State.start_res_or_res:  		if (CR == ch || LF == ch) {  			break;  		}  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		if (H == ch)  			state = State.res_or_resp_H;  		else {  			type = ParserType.HTTP_REQUEST;  			method = start_req_method_assign (ch);  			if (HttpMethod.ERROR == method)  				settings.RaiseOnError (this' "invalid method"' data' p_err);  			index = 1;  			state = State.req_method;  		}  		break;  	case State.res_or_resp_H:  		if (T == ch) {  			type = ParserType.HTTP_RESPONSE;  			state = State.res_HT;  		} else {  			if (E != ch)  				settings.RaiseOnError (this' "not E"' data' p_err);  			type = ParserType.HTTP_REQUEST;  			method = HttpMethod.HTTP_HEAD;  			index = 2;  			state = State.req_method;  		}  		break;  	case State.start_res:  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		switch (ch) {  		case H:  			state = State.res_H;  			break;  		case CR:  		case LF:  			break;  		default:  			settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  			break;  		}  		break;  	case State.res_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T"' data' p_err);  		state = State.res_HT;  		break;  	case State.res_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "Not T2"' data' p_err);  		state = State.res_HTT;  		break;  	case State.res_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "Not P"' data' p_err);  		state = State.res_HTTP;  		break;  	case State.res_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "Not '/'"' data' p_err);  		state = State.res_first_http_major;  		break;  	case State.res_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.res_http_major;  		break;  	/* major HTTP version or dot */case State.res_http_major:  		if (DOT == ch) {  			state = State.res_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_major *= 10;  		http_major += (ch - 0x30);  		if (http_major > 999)  			settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.res_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.res_http_minor;  		break;  	/* minor HTTP version or end of request line */case State.res_http_minor:  		if (SPACE == ch) {  			state = State.res_first_status_code;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Not a digit"' data' p_err);  		http_minor *= 10;  		http_minor += (ch - 0x30);  		if (http_minor > 999)  			settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  		break;  	case State.res_first_status_code:  		if (!isDigit (ch)) {  			if (SPACE == ch)  				break;  			settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  		}  		status_code = (int)ch - 0x30;  		state = State.res_status_code;  		break;  	case State.res_status_code:  		if (!isDigit (ch)) {  			switch (ch) {  			case SPACE:  				state = State.res_status;  				break;  			case CR:  				state = State.res_line_almost_done;  				break;  			case LF:  				state = State.header_field_start;  				break;  			default:  				settings.RaiseOnError (this' "not a valid status code"' data' p_err);  				break;  			}  			break;  		}  		status_code *= 10;  		status_code += (int)ch - 0x30;  		if (status_code > 999)  			settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  		break;  	case State.res_status:  		/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  			state = State.res_line_almost_done;  			break;  		}  		if (LF == ch) {  			state = State.header_field_start;  			break;  		}  		break;  	case State.res_line_almost_done:  		if (strict && LF != ch)  			settings.RaiseOnError (this' "not LF"' data' p_err);  		state = State.header_field_start;  		break;  	case State.start_req:  		if (CR == ch || LF == LF)  			break;  		flags = 0;  		content_length = -1;  		settings.RaiseOnMessageBegin (this);  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  		break;  	case State.req_method:  		if (0 == ch)  			settings.RaiseOnError (this' "NULL in method"' data' p_err);  		byte[] arr = HttpMethodBytes.GetBytes (method);  		if (SPACE == ch && index == arr.Length)  			state = State.req_spaces_before_url;  		else if (arr [index] == ch) {  			// wuhu!	  		} else if (HttpMethod.HTTP_CONNECT == method) {  			if (1 == index && H == ch) {  				method = HttpMethod.HTTP_CHECKOUT;  			} else if (2 == index && P == ch) {  				method = HttpMethod.HTTP_COPY;  			}  		} else if (HttpMethod.HTTP_MKCOL == method) {  			if (1 == index && O == ch) {  				method = HttpMethod.HTTP_MOVE;  			} else if (1 == index && E == ch) {  				method = HttpMethod.HTTP_MERGE;  			} else if (2 == index && A == ch) {  				method = HttpMethod.HTTP_MKACTIVITY;  			}  		} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  			method = HttpMethod.HTTP_PROPFIND;  		} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  			method = HttpMethod.HTTP_PUT;  		} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  			method = HttpMethod.HTTP_PROPPATCH;  		} else {  			settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  		}  		++index;  		break;  	/*__________________URL__________________*/case State.req_spaces_before_url:  		if (SPACE == ch)  			break;  		if (SLASH == ch) {  			url_mark = p;  			path_mark = p;  			state = State.req_path;  			break;  		}  		if (isAtoZ (ch)) {  			url_mark = p;  			state = State.req_schema;  			break;  		}  		settings.RaiseOnError (this' "Invalid something"' data' p_err);  		break;  	case State.req_schema:  		if (isAtoZ (ch))  			break;  		if (COLON == ch) {  			state = State.req_schema_slash;  			break;  		} else if (DOT == ch) {  			state = State.req_host;  			break;  		}  		settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  		break;  	case State.req_schema_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_schema_slash_slash;  		break;  	case State.req_schema_slash_slash:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  		state = State.req_host;  		break;  	case State.req_host:  		if (isAtoZ (ch))  			break;  		if (isDigit (ch) || DOT == ch || DASH == ch)  			break;  		switch (ch) {  		case COLON:  			state = State.req_port;  			break;  		case SLASH:  			path_mark = p;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "host error in method line"' data' p_err);  			break;  		}  		break;  	case State.req_port:  		if (isDigit (ch))  			break;  		switch (ch) {  		case SLASH:  			path_mark = p;  			state = State.req_path;  			break;  		case SPACE:  			/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		default:  			settings.RaiseOnError (this' "invalid port"' data' p_err);  			break;  		}  		break;  	case State.req_path:  		if (usual (ch))  			break;  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_query_string_start;  			break;  		case HASH:  			settings.RaiseOnPath (this' data' path_mark' p - path_mark);  			path_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string_start:  		if (usual (ch)) {  			query_string_mark = p;  			state = State.req_query_string;  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_query_string:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case QMARK:  			break;  		// allow extra '?' in query string  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case HASH:  			settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  			query_string_mark = -1;  			state = State.req_fragment_start;  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment_start:  		if (usual (ch)) {  			fragment_mark = p;  			state = State.req_fragment;  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  			fragment_mark = p;  			state = State.req_fragment;  			break;  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	case State.req_fragment:  		if (usual (ch)) {  			break;  		}  		switch (ch) {  		case SPACE:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  			fragment_mark = -1;  			state = State.req_http_start;  			break;  		case CR:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.res_line_almost_done;  			break;  		case LF:  			settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  			url_mark = -1;  			settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  			fragment_mark = -1;  			http_minor = 9;  			state = State.header_field_start;  			break;  		case QMARK:  		case HASH:  			break;  		default:  			settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  			break;  		}  		break;  	/******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  		switch (ch) {  		case H:  			state = State.req_http_H;  			break;  		case SPACE:  			break;  		default:  			settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  			break;  		}  		break;  	case State.req_http_H:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HT;  		break;  	case State.req_http_HT:  		if (strict && T != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTT;  		break;  	case State.req_http_HTT:  		if (strict && P != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_http_HTTP;  		break;  	case State.req_http_HTTP:  		if (strict && SLASH != ch)  			settings.RaiseOnError (this' "unexpected char"' data' p_err);  		state = State.req_first_http_major;  		break;  	/* first digit of major HTTP version */case State.req_first_http_major:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major = (int)ch - 0x30;  		state = State.req_http_major;  		break;  	/* major HTTP version or dot */case State.req_http_major:  		if (DOT == ch) {  			state = State.req_first_http_minor;  			break;  		}  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http major"' data' p_err);  		http_major *= 10;  		http_major += (int)ch - 0x30;  		if (http_major > 999)  			settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  		break;  	/* first digit of minor HTTP version */case State.req_first_http_minor:  		if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor = (int)ch - 0x30;  		state = State.req_http_minor;  		break;  	case State.req_http_minor:  		if (ch == CR) {  			state = State.req_line_almost_done;  			break;  		}  		if (ch == LF) {  			state = State.header_field_start;  			break;  		}  		/* XXX allow spaces after digit? */if (!isDigit (ch))  			settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  		http_minor *= 10;  		http_minor += (int)ch - 0x30;  		if (http_minor > 999)  			settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  		break;  	/* end of request line */case State.req_line_almost_done: {  		if (ch != LF)  			settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  		state = State.header_field_start;  		break;  	}  	/******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  		if (ch == CR) {  			state = State.headers_almost_done;  			break;  		}  		if (ch == LF) {  			/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  			if (!headers_almost_done (ch' settings' data' p_err))  				return;  			break;  		}  		c = upper (ch);  		if (c == 0) {  			settings.RaiseOnError (this' "invalid char in header"' data' p_err);  		}  		;  		header_field_mark = p;  		index = 0;  		state = State.header_field;  		switch (c) {  		case C:  			header_state = HState.C;  			break;  		case P:  			header_state = HState.matching_proxy_connection;  			break;  		case T:  			header_state = HState.matching_transfer_encoding;  			break;  		case U:  			header_state = HState.matching_upgrade;  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	case State.header_field: {  		c = UPCASE [ch];  		if (0 != c) {  			switch (header_state) {  			case HState.general:  				break;  			case HState.C:  				index++;  				header_state = (O == c ? HState.CO : HState.general);  				break;  			case HState.CO:  				index++;  				header_state = (N == c ? HState.CON : HState.general);  				break;  			case HState.CON:  				index++;  				switch (c) {  				case N:  					header_state = HState.matching_connection;  					break;  				case T:  					header_state = HState.matching_content_length;  					break;  				default:  					header_state = HState.general;  					break;  				}  				break;  			/* connection */case HState.matching_connection:  				index++;  				if (index > CONNECTION.Length || c != CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* proxy-connection */case HState.matching_proxy_connection:  				index++;  				if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  					header_state = HState.general;  				} else if (index == PROXY_CONNECTION.Length - 1) {  					header_state = HState.connection;  				}  				break;  			/* content-length */case HState.matching_content_length:  				index++;  				if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  					header_state = HState.general;  				} else if (index == CONTENT_LENGTH.Length - 1) {  					header_state = HState.content_length;  				}  				break;  			/* transfer-encoding */case HState.matching_transfer_encoding:  				index++;  				if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  					header_state = HState.general;  				} else if (index == TRANSFER_ENCODING.Length - 1) {  					header_state = HState.transfer_encoding;  				}  				break;  			/* upgrade */case HState.matching_upgrade:  				index++;  				if (index > UPGRADE.Length || c != UPGRADE [index]) {  					header_state = HState.general;  				} else if (index == UPGRADE.Length - 1) {  					header_state = HState.upgrade;  				}  				break;  			case HState.connection:  			case HState.content_length:  			case HState.transfer_encoding:  			case HState.upgrade:  				if (SPACE != ch)  					header_state = HState.general;  				break;  			default:  				settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  				break;  			}  			// switch: header_state  			break;  		}  		// 0 != c  		if (COLON == ch) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_value_start;  			break;  		}  		if (CR == ch) {  			state = State.header_almost_done;  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			break;  		}  		if (ch == LF) {  			settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  			header_field_mark = -1;  			state = State.header_field_start;  			break;  		}  		settings.RaiseOnError (this' "invalid header field"' data' p_err);  		break;  	}  	case State.header_value_start: {  		if (SPACE == ch)  			break;  		header_value_mark = p;  		state = State.header_value;  		index = 0;  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				header_state = HState.general;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_field_start;  				break;  			}  			header_state = HState.general;  			break;  		}  		switch (header_state) {  		case HState.upgrade:  			flags |= F_UPGRADE;  			header_state = HState.general;  			break;  		case HState.transfer_encoding:  			/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  				header_state = HState.matching_transfer_encoding_chunked;  			} else {  				header_state = HState.general;  			}  			break;  		case HState.content_length:  			if (!isDigit (ch)) {  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			}  			content_length = (int)ch - 0x30;  			break;  		case HState.connection:  			/* looking for 'Connection: keep-alive' */if (K == c) {  				header_state = HState.matching_connection_keep_alive;  				/* looking for 'Connection: close' */} else if (C == c) {  				header_state = HState.matching_connection_close;  			} else {  				header_state = HState.general;  			}  			break;  		default:  			header_state = HState.general;  			break;  		}  		break;  	}  	// header value start  	case State.header_value: {  		c = UPCASE [ch];  		if (c == 0) {  			if (CR == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				state = State.header_almost_done;  				break;  			}  			if (LF == ch) {  				settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  				header_value_mark = -1;  				if (!header_almost_done (ch)) {  					settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  				}  				break;  			}  			break;  		}  		switch (header_state) {  		case HState.general:  			break;  		case HState.connection:  		case HState.transfer_encoding:  			settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  			break;  		case HState.content_length:  			if (ch == ' ')  				break;  			if (!isDigit (ch))  				settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  			content_length *= 10;  			content_length += (int)ch - 0x30;  			break;  		/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  			index++;  			if (index > CHUNKED.Length || c != CHUNKED [index]) {  				header_state = HState.general;  			} else if (index == CHUNKED.Length - 1) {  				header_state = HState.transfer_encoding_chunked;  			}  			break;  		/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  			index++;  			if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  				header_state = HState.general;  			} else if (index == KEEP_ALIVE.Length - 1) {  				header_state = HState.connection_keep_alive;  			}  			break;  		/* looking for 'Connection: close' */case HState.matching_connection_close:  			index++;  			if (index > CLOSE.Length || c != CLOSE [index]) {  				header_state = HState.general;  			} else if (index == CLOSE.Length - 1) {  				header_state = HState.connection_close;  			}  			break;  		case HState.transfer_encoding_chunked:  		case HState.connection_keep_alive:  		case HState.connection_close:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			state = State.header_value;  			header_state = HState.general;  			break;  		}  		break;  	}  	// header_value  	case State.header_almost_done:  		if (!header_almost_done (ch))  			settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  		break;  	case State.headers_almost_done:  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	/******************* Header *******************//******************* Body *******************/case State.body_identity:  		to_read = min (pe' content_length);  		//TODO change to use buffer?   		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  			content_length -= to_read;  			if (content_length == 0) {  				settings.RaiseOnMessageComplete (this);  				state = new_message ();  			}  		}  		break;  	case State.body_identity_eof:  		to_read = pe;  		// TODO change to use buffer ?  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		break;  	/******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		c = UNHEX [ch];  		if (c == -1) {  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length = c;  		state = State.chunk_size;  		break;  	case State.chunk_size:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		c = UNHEX [ch];  		if (c == -1) {  			if (SEMI == ch || SPACE == ch) {  				state = State.chunk_parameters;  				break;  			}  			settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  		}  		content_length *= 16;  		content_length += c;  		break;  	case State.chunk_parameters:  		if (0 == (flags & F_CHUNKED))  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		/* just ignore this shit. TODO check for overflow */if (CR == ch) {  			state = State.chunk_size_almost_done;  			break;  		}  		break;  	case State.chunk_size_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  		}  		if (0 == content_length) {  			flags |= F_TRAILING;  			state = State.header_field_start;  		} else {  			state = State.chunk_data;  		}  		break;  	case State.chunk_data: {  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		to_read = min (pe' content_length);  		if (to_read > 0) {  			settings.RaiseOnBody (this' data' p' to_read);  			data.Skip (to_read);  		}  		if (to_read == content_length) {  			state = State.chunk_data_almost_done;  		}  		content_length -= to_read;  		break;  	}  	case State.chunk_data_almost_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && CR != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  		}  		state = State.chunk_data_done;  		break;  	case State.chunk_data_done:  		if (0 == (flags & F_CHUNKED)) {  			settings.RaiseOnError (this' "not chunked"' data' p_err);  		}  		if (strict && LF != ch) {  			settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  		}  		state = State.chunk_size_start;  		break;  	/******************* Chunk *******************/default:  		settings.RaiseOnError (this' "unhandled state"' data' p_err);  		break;  	}  	// switch  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (state) {  /* 					 * this state is used after a 'Connection: close' message 					 * the parser will error out if it reads another message 					 */case State.dead:  	settings.RaiseOnError (this' "Connection already closed"' data' p_err);  	// JACKSON: Added this break  	break;  case State.start_res_or_res:  	if (CR == ch || LF == ch) {  		break;  	}  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	if (H == ch)  		state = State.res_or_resp_H;  	else {  		type = ParserType.HTTP_REQUEST;  		method = start_req_method_assign (ch);  		if (HttpMethod.ERROR == method)  			settings.RaiseOnError (this' "invalid method"' data' p_err);  		index = 1;  		state = State.req_method;  	}  	break;  case State.res_or_resp_H:  	if (T == ch) {  		type = ParserType.HTTP_RESPONSE;  		state = State.res_HT;  	} else {  		if (E != ch)  			settings.RaiseOnError (this' "not E"' data' p_err);  		type = ParserType.HTTP_REQUEST;  		method = HttpMethod.HTTP_HEAD;  		index = 2;  		state = State.req_method;  	}  	break;  case State.start_res:  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	switch (ch) {  	case H:  		state = State.res_H;  		break;  	case CR:  	case LF:  		break;  	default:  		settings.RaiseOnError (this' "Not H or CR/LF"' data' p_err);  		break;  	}  	break;  case State.res_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T"' data' p_err);  	state = State.res_HT;  	break;  case State.res_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "Not T2"' data' p_err);  	state = State.res_HTT;  	break;  case State.res_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "Not P"' data' p_err);  	state = State.res_HTTP;  	break;  case State.res_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "Not '/'"' data' p_err);  	state = State.res_first_http_major;  	break;  case State.res_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.res_http_major;  	break;  /* major HTTP version or dot */case State.res_http_major:  	if (DOT == ch) {  		state = State.res_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_major *= 10;  	http_major += (ch - 0x30);  	if (http_major > 999)  		settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  	break;  /* first digit of minor HTTP version */case State.res_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.res_http_minor;  	break;  /* minor HTTP version or end of request line */case State.res_http_minor:  	if (SPACE == ch) {  		state = State.res_first_status_code;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Not a digit"' data' p_err);  	http_minor *= 10;  	http_minor += (ch - 0x30);  	if (http_minor > 999)  		settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  	break;  case State.res_first_status_code:  	if (!isDigit (ch)) {  		if (SPACE == ch)  			break;  		settings.RaiseOnError (this' "Not a digit (status code)"' data' p_err);  	}  	status_code = (int)ch - 0x30;  	state = State.res_status_code;  	break;  case State.res_status_code:  	if (!isDigit (ch)) {  		switch (ch) {  		case SPACE:  			state = State.res_status;  			break;  		case CR:  			state = State.res_line_almost_done;  			break;  		case LF:  			state = State.header_field_start;  			break;  		default:  			settings.RaiseOnError (this' "not a valid status code"' data' p_err);  			break;  		}  		break;  	}  	status_code *= 10;  	status_code += (int)ch - 0x30;  	if (status_code > 999)  		settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  	break;  case State.res_status:  	/* the human readable status. e.g. "NOT FOUND" 					 * we are not humans so just ignore this 					 * we are not men' we are devo. */if (CR == ch) {  		state = State.res_line_almost_done;  		break;  	}  	if (LF == ch) {  		state = State.header_field_start;  		break;  	}  	break;  case State.res_line_almost_done:  	if (strict && LF != ch)  		settings.RaiseOnError (this' "not LF"' data' p_err);  	state = State.header_field_start;  	break;  case State.start_req:  	if (CR == ch || LF == LF)  		break;  	flags = 0;  	content_length = -1;  	settings.RaiseOnMessageBegin (this);  	method = start_req_method_assign (ch);  	if (HttpMethod.ERROR == method)  		settings.RaiseOnError (this' "invalid method"' data' p_err);  	index = 1;  	state = State.req_method;  	break;  case State.req_method:  	if (0 == ch)  		settings.RaiseOnError (this' "NULL in method"' data' p_err);  	byte[] arr = HttpMethodBytes.GetBytes (method);  	if (SPACE == ch && index == arr.Length)  		state = State.req_spaces_before_url;  	else if (arr [index] == ch) {  		// wuhu!	  	} else if (HttpMethod.HTTP_CONNECT == method) {  		if (1 == index && H == ch) {  			method = HttpMethod.HTTP_CHECKOUT;  		} else if (2 == index && P == ch) {  			method = HttpMethod.HTTP_COPY;  		}  	} else if (HttpMethod.HTTP_MKCOL == method) {  		if (1 == index && O == ch) {  			method = HttpMethod.HTTP_MOVE;  		} else if (1 == index && E == ch) {  			method = HttpMethod.HTTP_MERGE;  		} else if (2 == index && A == ch) {  			method = HttpMethod.HTTP_MKACTIVITY;  		}  	} else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  		method = HttpMethod.HTTP_PROPFIND;  	} else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  		method = HttpMethod.HTTP_PUT;  	} else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  		method = HttpMethod.HTTP_PROPPATCH;  	} else {  		settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  	}  	++index;  	break;  /*__________________URL__________________*/case State.req_spaces_before_url:  	if (SPACE == ch)  		break;  	if (SLASH == ch) {  		url_mark = p;  		path_mark = p;  		state = State.req_path;  		break;  	}  	if (isAtoZ (ch)) {  		url_mark = p;  		state = State.req_schema;  		break;  	}  	settings.RaiseOnError (this' "Invalid something"' data' p_err);  	break;  case State.req_schema:  	if (isAtoZ (ch))  		break;  	if (COLON == ch) {  		state = State.req_schema_slash;  		break;  	} else if (DOT == ch) {  		state = State.req_host;  		break;  	}  	settings.RaiseOnError (this' "invalid char in schema: " + ch' data' p_err);  	break;  case State.req_schema_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_schema_slash_slash;  	break;  case State.req_schema_slash_slash:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "invalid char in schema' not /"' data' p_err);  	state = State.req_host;  	break;  case State.req_host:  	if (isAtoZ (ch))  		break;  	if (isDigit (ch) || DOT == ch || DASH == ch)  		break;  	switch (ch) {  	case COLON:  		state = State.req_port;  		break;  	case SLASH:  		path_mark = p;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com HTTP/1.1"	 						 * That is' there is no path.	 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "host error in method line"' data' p_err);  		break;  	}  	break;  case State.req_port:  	if (isDigit (ch))  		break;  	switch (ch) {  	case SLASH:  		path_mark = p;  		state = State.req_path;  		break;  	case SPACE:  		/* The request line looks like: 						 *   "GET http://foo.bar.com:1234 HTTP/1.1" 						 * That is' there is no path. 						 */settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	default:  		settings.RaiseOnError (this' "invalid port"' data' p_err);  		break;  	}  	break;  case State.req_path:  	if (usual (ch))  		break;  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_query_string_start;  		break;  	case HASH:  		settings.RaiseOnPath (this' data' path_mark' p - path_mark);  		path_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string_start:  	if (usual (ch)) {  		query_string_mark = p;  		state = State.req_query_string;  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_query_string:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case QMARK:  		break;  	// allow extra '?' in query string  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case HASH:  		settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  		query_string_mark = -1;  		state = State.req_fragment_start;  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment_start:  	if (usual (ch)) {  		fragment_mark = p;  		state = State.req_fragment;  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  		fragment_mark = p;  		state = State.req_fragment;  		break;  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  case State.req_fragment:  	if (usual (ch)) {  		break;  	}  	switch (ch) {  	case SPACE:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  		fragment_mark = -1;  		state = State.req_http_start;  		break;  	case CR:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.res_line_almost_done;  		break;  	case LF:  		settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  		url_mark = -1;  		settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  		fragment_mark = -1;  		http_minor = 9;  		state = State.header_field_start;  		break;  	case QMARK:  	case HASH:  		break;  	default:  		settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  		break;  	}  	break;  /******************* URL *******************//******************* HTTP 1.1 *******************/case State.req_http_start:  	switch (ch) {  	case H:  		state = State.req_http_H;  		break;  	case SPACE:  		break;  	default:  		settings.RaiseOnError (this' "error in req_http_H"' data' p_err);  		break;  	}  	break;  case State.req_http_H:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HT;  	break;  case State.req_http_HT:  	if (strict && T != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTT;  	break;  case State.req_http_HTT:  	if (strict && P != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_http_HTTP;  	break;  case State.req_http_HTTP:  	if (strict && SLASH != ch)  		settings.RaiseOnError (this' "unexpected char"' data' p_err);  	state = State.req_first_http_major;  	break;  /* first digit of major HTTP version */case State.req_first_http_major:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major = (int)ch - 0x30;  	state = State.req_http_major;  	break;  /* major HTTP version or dot */case State.req_http_major:  	if (DOT == ch) {  		state = State.req_first_http_minor;  		break;  	}  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http major"' data' p_err);  	http_major *= 10;  	http_major += (int)ch - 0x30;  	if (http_major > 999)  		settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  	break;  /* first digit of minor HTTP version */case State.req_first_http_minor:  	if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor = (int)ch - 0x30;  	state = State.req_http_minor;  	break;  case State.req_http_minor:  	if (ch == CR) {  		state = State.req_line_almost_done;  		break;  	}  	if (ch == LF) {  		state = State.header_field_start;  		break;  	}  	/* XXX allow spaces after digit? */if (!isDigit (ch))  		settings.RaiseOnError (this' "non digit in http minor"' data' p_err);  	http_minor *= 10;  	http_minor += (int)ch - 0x30;  	if (http_minor > 999)  		settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  	break;  /* end of request line */case State.req_line_almost_done: {  	if (ch != LF)  		settings.RaiseOnError (this' "missing LF after request line"' data' p_err);  	state = State.header_field_start;  	break;  }  /******************* HTTP 1.1 *******************//******************* Header *******************/case State.header_field_start: {  	if (ch == CR) {  		state = State.headers_almost_done;  		break;  	}  	if (ch == LF) {  		/* they might be just sending \n instead of \r\n so this would be 						 * the second \n to denote the end of headers*/state = State.headers_almost_done;  		if (!headers_almost_done (ch' settings' data' p_err))  			return;  		break;  	}  	c = upper (ch);  	if (c == 0) {  		settings.RaiseOnError (this' "invalid char in header"' data' p_err);  	}  	;  	header_field_mark = p;  	index = 0;  	state = State.header_field;  	switch (c) {  	case C:  		header_state = HState.C;  		break;  	case P:  		header_state = HState.matching_proxy_connection;  		break;  	case T:  		header_state = HState.matching_transfer_encoding;  		break;  	case U:  		header_state = HState.matching_upgrade;  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  case State.header_field: {  	c = UPCASE [ch];  	if (0 != c) {  		switch (header_state) {  		case HState.general:  			break;  		case HState.C:  			index++;  			header_state = (O == c ? HState.CO : HState.general);  			break;  		case HState.CO:  			index++;  			header_state = (N == c ? HState.CON : HState.general);  			break;  		case HState.CON:  			index++;  			switch (c) {  			case N:  				header_state = HState.matching_connection;  				break;  			case T:  				header_state = HState.matching_content_length;  				break;  			default:  				header_state = HState.general;  				break;  			}  			break;  		/* connection */case HState.matching_connection:  			index++;  			if (index > CONNECTION.Length || c != CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* proxy-connection */case HState.matching_proxy_connection:  			index++;  			if (index > PROXY_CONNECTION.Length || c != PROXY_CONNECTION [index]) {  				header_state = HState.general;  			} else if (index == PROXY_CONNECTION.Length - 1) {  				header_state = HState.connection;  			}  			break;  		/* content-length */case HState.matching_content_length:  			index++;  			if (index > CONTENT_LENGTH.Length || c != CONTENT_LENGTH [index]) {  				header_state = HState.general;  			} else if (index == CONTENT_LENGTH.Length - 1) {  				header_state = HState.content_length;  			}  			break;  		/* transfer-encoding */case HState.matching_transfer_encoding:  			index++;  			if (index > TRANSFER_ENCODING.Length || c != TRANSFER_ENCODING [index]) {  				header_state = HState.general;  			} else if (index == TRANSFER_ENCODING.Length - 1) {  				header_state = HState.transfer_encoding;  			}  			break;  		/* upgrade */case HState.matching_upgrade:  			index++;  			if (index > UPGRADE.Length || c != UPGRADE [index]) {  				header_state = HState.general;  			} else if (index == UPGRADE.Length - 1) {  				header_state = HState.upgrade;  			}  			break;  		case HState.connection:  		case HState.content_length:  		case HState.transfer_encoding:  		case HState.upgrade:  			if (SPACE != ch)  				header_state = HState.general;  			break;  		default:  			settings.RaiseOnError (this' "Unknown Header State"' data' p_err);  			break;  		}  		// switch: header_state  		break;  	}  	// 0 != c  	if (COLON == ch) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_value_start;  		break;  	}  	if (CR == ch) {  		state = State.header_almost_done;  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		break;  	}  	if (ch == LF) {  		settings.RaiseOnHeaderField (this' data' header_field_mark' p - header_field_mark);  		header_field_mark = -1;  		state = State.header_field_start;  		break;  	}  	settings.RaiseOnError (this' "invalid header field"' data' p_err);  	break;  }  case State.header_value_start: {  	if (SPACE == ch)  		break;  	header_value_mark = p;  	state = State.header_value;  	index = 0;  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			header_state = HState.general;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_field_start;  			break;  		}  		header_state = HState.general;  		break;  	}  	switch (header_state) {  	case HState.upgrade:  		flags |= F_UPGRADE;  		header_state = HState.general;  		break;  	case HState.transfer_encoding:  		/* looking for 'Transfer-Encoding: chunked' */if (C == c) {  			header_state = HState.matching_transfer_encoding_chunked;  		} else {  			header_state = HState.general;  		}  		break;  	case HState.content_length:  		if (!isDigit (ch)) {  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		}  		content_length = (int)ch - 0x30;  		break;  	case HState.connection:  		/* looking for 'Connection: keep-alive' */if (K == c) {  			header_state = HState.matching_connection_keep_alive;  			/* looking for 'Connection: close' */} else if (C == c) {  			header_state = HState.matching_connection_close;  		} else {  			header_state = HState.general;  		}  		break;  	default:  		header_state = HState.general;  		break;  	}  	break;  }  // header value start  case State.header_value: {  	c = UPCASE [ch];  	if (c == 0) {  		if (CR == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			state = State.header_almost_done;  			break;  		}  		if (LF == ch) {  			settings.RaiseOnHeaderValue (this' data' header_value_mark' p - header_value_mark);  			header_value_mark = -1;  			if (!header_almost_done (ch)) {  				settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  			}  			break;  		}  		break;  	}  	switch (header_state) {  	case HState.general:  		break;  	case HState.connection:  	case HState.transfer_encoding:  		settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  		break;  	case HState.content_length:  		if (ch == ' ')  			break;  		if (!isDigit (ch))  			settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  		content_length *= 10;  		content_length += (int)ch - 0x30;  		break;  	/* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  		index++;  		if (index > CHUNKED.Length || c != CHUNKED [index]) {  			header_state = HState.general;  		} else if (index == CHUNKED.Length - 1) {  			header_state = HState.transfer_encoding_chunked;  		}  		break;  	/* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  		index++;  		if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  			header_state = HState.general;  		} else if (index == KEEP_ALIVE.Length - 1) {  			header_state = HState.connection_keep_alive;  		}  		break;  	/* looking for 'Connection: close' */case HState.matching_connection_close:  		index++;  		if (index > CLOSE.Length || c != CLOSE [index]) {  			header_state = HState.general;  		} else if (index == CLOSE.Length - 1) {  			header_state = HState.connection_close;  		}  		break;  	case HState.transfer_encoding_chunked:  	case HState.connection_keep_alive:  	case HState.connection_close:  		if (SPACE != ch)  			header_state = HState.general;  		break;  	default:  		state = State.header_value;  		header_state = HState.general;  		break;  	}  	break;  }  // header_value  case State.header_almost_done:  	if (!header_almost_done (ch))  		settings.RaiseOnError (this' "incorrect header ending' expection LF"' data' p_err);  	break;  case State.headers_almost_done:  	if (!headers_almost_done (ch' settings' data' p_err))  		return;  	break;  /******************* Header *******************//******************* Body *******************/case State.body_identity:  	to_read = min (pe' content_length);  	//TODO change to use buffer?   	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  		content_length -= to_read;  		if (content_length == 0) {  			settings.RaiseOnMessageComplete (this);  			state = new_message ();  		}  	}  	break;  case State.body_identity_eof:  	to_read = pe;  	// TODO change to use buffer ?  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	break;  /******************* Body *******************//******************* Chunk *******************/case State.chunk_size_start:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	c = UNHEX [ch];  	if (c == -1) {  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length = c;  	state = State.chunk_size;  	break;  case State.chunk_size:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	c = UNHEX [ch];  	if (c == -1) {  		if (SEMI == ch || SPACE == ch) {  			state = State.chunk_parameters;  			break;  		}  		settings.RaiseOnError (this' "invalid hex char in chunk content length"' data' p_err);  	}  	content_length *= 16;  	content_length += c;  	break;  case State.chunk_parameters:  	if (0 == (flags & F_CHUNKED))  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	/* just ignore this shit. TODO check for overflow */if (CR == ch) {  		state = State.chunk_size_almost_done;  		break;  	}  	break;  case State.chunk_size_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "expected LF at end of chunk size"' data' p_err);  	}  	if (0 == content_length) {  		flags |= F_TRAILING;  		state = State.header_field_start;  	} else {  		state = State.chunk_data;  	}  	break;  case State.chunk_data: {  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	to_read = min (pe' content_length);  	if (to_read > 0) {  		settings.RaiseOnBody (this' data' p' to_read);  		data.Skip (to_read);  	}  	if (to_read == content_length) {  		state = State.chunk_data_almost_done;  	}  	content_length -= to_read;  	break;  }  case State.chunk_data_almost_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && CR != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected CR"' data' p_err);  	}  	state = State.chunk_data_done;  	break;  case State.chunk_data_done:  	if (0 == (flags & F_CHUNKED)) {  		settings.RaiseOnError (this' "not chunked"' data' p_err);  	}  	if (strict && LF != ch) {  		settings.RaiseOnError (this' "chunk data terminated incorrectly' expected LF"' data' p_err);  	}  	state = State.chunk_size_start;  	break;  /******************* Chunk *******************/default:  	settings.RaiseOnError (this' "unhandled state"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (T == ch) {  	type = ParserType.HTTP_RESPONSE;  	state = State.res_HT;  } else {  	if (E != ch)  		settings.RaiseOnError (this' "not E"' data' p_err);  	type = ParserType.HTTP_REQUEST;  	method = HttpMethod.HTTP_HEAD;  	index = 2;  	state = State.req_method;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: index = 2;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_major *= 10;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (http_major > 999)  	settings.RaiseOnError (this' "invalid http major version: " + http_major' data' p_err);  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor *= 10;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (http_minor > 999)  	settings.RaiseOnError (this' "invalid http minor version: " + http_minor' data' p_err);  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: status_code *= 10;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (status_code > 999)  	settings.RaiseOnError (this' "ridiculous status code:" + status_code' data' p_err);  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (SPACE == ch && index == arr.Length)  	state = State.req_spaces_before_url;  else if (arr [index] == ch) {  	// wuhu!	  } else if (HttpMethod.HTTP_CONNECT == method) {  	if (1 == index && H == ch) {  		method = HttpMethod.HTTP_CHECKOUT;  	} else if (2 == index && P == ch) {  		method = HttpMethod.HTTP_COPY;  	}  } else if (HttpMethod.HTTP_MKCOL == method) {  	if (1 == index && O == ch) {  		method = HttpMethod.HTTP_MOVE;  	} else if (1 == index && E == ch) {  		method = HttpMethod.HTTP_MERGE;  	} else if (2 == index && A == ch) {  		method = HttpMethod.HTTP_MKACTIVITY;  	}  } else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (SPACE == ch && index == arr.Length)  	state = State.req_spaces_before_url;  else if (arr [index] == ch) {  	// wuhu!	  } else if (HttpMethod.HTTP_CONNECT == method) {  	if (1 == index && H == ch) {  		method = HttpMethod.HTTP_CHECKOUT;  	} else if (2 == index && P == ch) {  		method = HttpMethod.HTTP_COPY;  	}  } else if (HttpMethod.HTTP_MKCOL == method) {  	if (1 == index && O == ch) {  		method = HttpMethod.HTTP_MOVE;  	} else if (1 == index && E == ch) {  		method = HttpMethod.HTTP_MERGE;  	} else if (2 == index && A == ch) {  		method = HttpMethod.HTTP_MKACTIVITY;  	}  } else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (SPACE == ch && index == arr.Length)  	state = State.req_spaces_before_url;  else if (arr [index] == ch) {  	// wuhu!	  } else if (HttpMethod.HTTP_CONNECT == method) {  	if (1 == index && H == ch) {  		method = HttpMethod.HTTP_CHECKOUT;  	} else if (2 == index && P == ch) {  		method = HttpMethod.HTTP_COPY;  	}  } else if (HttpMethod.HTTP_MKCOL == method) {  	if (1 == index && O == ch) {  		method = HttpMethod.HTTP_MOVE;  	} else if (1 == index && E == ch) {  		method = HttpMethod.HTTP_MERGE;  	} else if (2 == index && A == ch) {  		method = HttpMethod.HTTP_MKACTIVITY;  	}  } else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (arr [index] == ch) {  	// wuhu!	  } else if (HttpMethod.HTTP_CONNECT == method) {  	if (1 == index && H == ch) {  		method = HttpMethod.HTTP_CHECKOUT;  	} else if (2 == index && P == ch) {  		method = HttpMethod.HTTP_COPY;  	}  } else if (HttpMethod.HTTP_MKCOL == method) {  	if (1 == index && O == ch) {  		method = HttpMethod.HTTP_MOVE;  	} else if (1 == index && E == ch) {  		method = HttpMethod.HTTP_MERGE;  	} else if (2 == index && A == ch) {  		method = HttpMethod.HTTP_MKACTIVITY;  	}  } else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (arr [index] == ch) {  	// wuhu!	  } else if (HttpMethod.HTTP_CONNECT == method) {  	if (1 == index && H == ch) {  		method = HttpMethod.HTTP_CHECKOUT;  	} else if (2 == index && P == ch) {  		method = HttpMethod.HTTP_COPY;  	}  } else if (HttpMethod.HTTP_MKCOL == method) {  	if (1 == index && O == ch) {  		method = HttpMethod.HTTP_MOVE;  	} else if (1 == index && E == ch) {  		method = HttpMethod.HTTP_MERGE;  	} else if (2 == index && A == ch) {  		method = HttpMethod.HTTP_MKACTIVITY;  	}  } else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (arr [index] == ch) {  	// wuhu!	  } else if (HttpMethod.HTTP_CONNECT == method) {  	if (1 == index && H == ch) {  		method = HttpMethod.HTTP_CHECKOUT;  	} else if (2 == index && P == ch) {  		method = HttpMethod.HTTP_COPY;  	}  } else if (HttpMethod.HTTP_MKCOL == method) {  	if (1 == index && O == ch) {  		method = HttpMethod.HTTP_MOVE;  	} else if (1 == index && E == ch) {  		method = HttpMethod.HTTP_MERGE;  	} else if (2 == index && A == ch) {  		method = HttpMethod.HTTP_MKACTIVITY;  	}  } else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (HttpMethod.HTTP_CONNECT == method) {  	if (1 == index && H == ch) {  		method = HttpMethod.HTTP_CHECKOUT;  	} else if (2 == index && P == ch) {  		method = HttpMethod.HTTP_COPY;  	}  } else if (HttpMethod.HTTP_MKCOL == method) {  	if (1 == index && O == ch) {  		method = HttpMethod.HTTP_MOVE;  	} else if (1 == index && E == ch) {  		method = HttpMethod.HTTP_MERGE;  	} else if (2 == index && A == ch) {  		method = HttpMethod.HTTP_MKACTIVITY;  	}  } else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (HttpMethod.HTTP_CONNECT == method) {  	if (1 == index && H == ch) {  		method = HttpMethod.HTTP_CHECKOUT;  	} else if (2 == index && P == ch) {  		method = HttpMethod.HTTP_COPY;  	}  } else if (HttpMethod.HTTP_MKCOL == method) {  	if (1 == index && O == ch) {  		method = HttpMethod.HTTP_MOVE;  	} else if (1 == index && E == ch) {  		method = HttpMethod.HTTP_MERGE;  	} else if (2 == index && A == ch) {  		method = HttpMethod.HTTP_MKACTIVITY;  	}  } else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (HttpMethod.HTTP_CONNECT == method) {  	if (1 == index && H == ch) {  		method = HttpMethod.HTTP_CHECKOUT;  	} else if (2 == index && P == ch) {  		method = HttpMethod.HTTP_COPY;  	}  } else if (HttpMethod.HTTP_MKCOL == method) {  	if (1 == index && O == ch) {  		method = HttpMethod.HTTP_MOVE;  	} else if (1 == index && E == ch) {  		method = HttpMethod.HTTP_MERGE;  	} else if (2 == index && A == ch) {  		method = HttpMethod.HTTP_MKACTIVITY;  	}  } else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (1 == index && H == ch) {  	method = HttpMethod.HTTP_CHECKOUT;  } else if (2 == index && P == ch) {  	method = HttpMethod.HTTP_COPY;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (2 == index && P == ch) {  	method = HttpMethod.HTTP_COPY;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (HttpMethod.HTTP_MKCOL == method) {  	if (1 == index && O == ch) {  		method = HttpMethod.HTTP_MOVE;  	} else if (1 == index && E == ch) {  		method = HttpMethod.HTTP_MERGE;  	} else if (2 == index && A == ch) {  		method = HttpMethod.HTTP_MKACTIVITY;  	}  } else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (HttpMethod.HTTP_MKCOL == method) {  	if (1 == index && O == ch) {  		method = HttpMethod.HTTP_MOVE;  	} else if (1 == index && E == ch) {  		method = HttpMethod.HTTP_MERGE;  	} else if (2 == index && A == ch) {  		method = HttpMethod.HTTP_MKACTIVITY;  	}  } else if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (1 == index && O == ch) {  	method = HttpMethod.HTTP_MOVE;  } else if (1 == index && E == ch) {  	method = HttpMethod.HTTP_MERGE;  } else if (2 == index && A == ch) {  	method = HttpMethod.HTTP_MKACTIVITY;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (1 == index && E == ch) {  	method = HttpMethod.HTTP_MERGE;  } else if (2 == index && A == ch) {  	method = HttpMethod.HTTP_MKACTIVITY;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (2 == index && A == ch) {  	method = HttpMethod.HTTP_MKACTIVITY;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (1 == index && HttpMethod.HTTP_POST == method && R == ch) {  	method = HttpMethod.HTTP_PROPFIND;  } else if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (1 == index && HttpMethod.HTTP_POST == method && U == ch) {  	method = HttpMethod.HTTP_PUT;  } else if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (4 == index && HttpMethod.HTTP_PROPFIND == method && P == ch) {  	method = HttpMethod.HTTP_PROPPATCH;  } else {  	settings.RaiseOnError (this' "Invalid HTTP method"' data' p_err);  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (ch) {  case SPACE:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnPath (this' data' path_mark' p - path_mark);  	path_mark = -1;  	state = State.req_http_start;  	break;  case CR:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnPath (this' data' path_mark' p - path_mark);  	path_mark = -1;  	http_minor = 9;  	state = State.res_line_almost_done;  	break;  case LF:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnPath (this' data' path_mark' p - path_mark);  	path_mark = -1;  	http_minor = 9;  	state = State.header_field_start;  	break;  case QMARK:  	settings.RaiseOnPath (this' data' path_mark' p - path_mark);  	path_mark = -1;  	state = State.req_query_string_start;  	break;  case HASH:  	settings.RaiseOnPath (this' data' path_mark' p - path_mark);  	path_mark = -1;  	state = State.req_fragment_start;  	break;  default:  	settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (ch) {  case SPACE:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnPath (this' data' path_mark' p - path_mark);  	path_mark = -1;  	state = State.req_http_start;  	break;  case CR:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnPath (this' data' path_mark' p - path_mark);  	path_mark = -1;  	http_minor = 9;  	state = State.res_line_almost_done;  	break;  case LF:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnPath (this' data' path_mark' p - path_mark);  	path_mark = -1;  	http_minor = 9;  	state = State.header_field_start;  	break;  case QMARK:  	settings.RaiseOnPath (this' data' path_mark' p - path_mark);  	path_mark = -1;  	state = State.req_query_string_start;  	break;  case HASH:  	settings.RaiseOnPath (this' data' path_mark' p - path_mark);  	path_mark = -1;  	state = State.req_fragment_start;  	break;  default:  	settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor = 9;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor = 9;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (ch) {  case QMARK:  	break;  case SPACE:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	state = State.req_http_start;  	break;  case CR:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	http_minor = 9;  	state = State.res_line_almost_done;  	break;  case LF:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	http_minor = 9;  	state = State.header_field_start;  	break;  case HASH:  	state = State.req_fragment_start;  	break;  default:  	settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (ch) {  case QMARK:  	break;  case SPACE:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	state = State.req_http_start;  	break;  case CR:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	http_minor = 9;  	state = State.res_line_almost_done;  	break;  case LF:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	http_minor = 9;  	state = State.header_field_start;  	break;  case HASH:  	state = State.req_fragment_start;  	break;  default:  	settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor = 9;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor = 9;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (ch) {  case QMARK:  	break;  // allow extra '?' in query string  case SPACE:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  	query_string_mark = -1;  	state = State.req_http_start;  	break;  case CR:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  	query_string_mark = -1;  	http_minor = 9;  	state = State.res_line_almost_done;  	break;  case LF:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  	query_string_mark = -1;  	http_minor = 9;  	state = State.header_field_start;  	break;  case HASH:  	settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  	query_string_mark = -1;  	state = State.req_fragment_start;  	break;  default:  	settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (ch) {  case QMARK:  	break;  // allow extra '?' in query string  case SPACE:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  	query_string_mark = -1;  	state = State.req_http_start;  	break;  case CR:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  	query_string_mark = -1;  	http_minor = 9;  	state = State.res_line_almost_done;  	break;  case LF:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  	query_string_mark = -1;  	http_minor = 9;  	state = State.header_field_start;  	break;  case HASH:  	settings.RaiseOnQueryString (this' data' query_string_mark' p - query_string_mark);  	query_string_mark = -1;  	state = State.req_fragment_start;  	break;  default:  	settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor = 9;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor = 9;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (ch) {  case SPACE:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	state = State.req_http_start;  	break;  case CR:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	http_minor = 9;  	state = State.res_line_almost_done;  	break;  case LF:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	http_minor = 9;  	state = State.header_field_start;  	break;  case QMARK:  	fragment_mark = p;  	state = State.req_fragment;  	break;  case HASH:  	break;  default:  	settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (ch) {  case SPACE:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	state = State.req_http_start;  	break;  case CR:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	http_minor = 9;  	state = State.res_line_almost_done;  	break;  case LF:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	http_minor = 9;  	state = State.header_field_start;  	break;  case QMARK:  	fragment_mark = p;  	state = State.req_fragment;  	break;  case HASH:  	break;  default:  	settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor = 9;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor = 9;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (ch) {  case SPACE:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  	fragment_mark = -1;  	state = State.req_http_start;  	break;  case CR:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  	fragment_mark = -1;  	http_minor = 9;  	state = State.res_line_almost_done;  	break;  case LF:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  	fragment_mark = -1;  	http_minor = 9;  	state = State.header_field_start;  	break;  case QMARK:  case HASH:  	break;  default:  	settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (ch) {  case SPACE:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnFragment (this' data' fragment_mark' p - fragment_mark);  	fragment_mark = -1;  	state = State.req_http_start;  	break;  case CR:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  	fragment_mark = -1;  	http_minor = 9;  	state = State.res_line_almost_done;  	break;  case LF:  	settings.RaiseOnUrl (this' data' url_mark' p - url_mark);  	url_mark = -1;  	settings.RaiseOnFragment (this' data' query_string_mark' p - query_string_mark);  	fragment_mark = -1;  	http_minor = 9;  	state = State.header_field_start;  	break;  case QMARK:  case HASH:  	break;  default:  	settings.RaiseOnError (this' "unexpected char in path"' data' p_err);  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor = 9;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor = 9;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_major *= 10;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (http_major > 999)  	settings.RaiseOnError (this' "ridiculous http major"' data' p_err);  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: http_minor *= 10;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: if (http_minor > 999)  	settings.RaiseOnError (this' "ridiculous http minor"' data' p_err);  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: switch (header_state) {  case HState.general:  	break;  case HState.connection:  case HState.transfer_encoding:  	settings.RaiseOnError (this' "Shouldn't be here"' data' p_err);  	break;  case HState.content_length:  	if (ch == ' ')  		break;  	if (!isDigit (ch))  		settings.RaiseOnError (this' "Content-Length not numeric"' data' p_err);  	content_length *= 10;  	content_length += (int)ch - 0x30;  	break;  /* Transfer-Encoding: chunked */case HState.matching_transfer_encoding_chunked:  	index++;  	if (index > CHUNKED.Length || c != CHUNKED [index]) {  		header_state = HState.general;  	} else if (index == CHUNKED.Length - 1) {  		header_state = HState.transfer_encoding_chunked;  	}  	break;  /* looking for 'Connection: keep-alive' */case HState.matching_connection_keep_alive:  	index++;  	if (index > KEEP_ALIVE.Length || c != KEEP_ALIVE [index]) {  		header_state = HState.general;  	} else if (index == KEEP_ALIVE.Length - 1) {  		header_state = HState.connection_keep_alive;  	}  	break;  /* looking for 'Connection: close' */case HState.matching_connection_close:  	index++;  	if (index > CLOSE.Length || c != CLOSE [index]) {  		header_state = HState.general;  	} else if (index == CLOSE.Length - 1) {  		header_state = HState.connection_close;  	}  	break;  case HState.transfer_encoding_chunked:  case HState.connection_keep_alive:  case HState.connection_close:  	if (SPACE != ch)  		header_state = HState.general;  	break;  default:  	state = State.header_value;  	header_state = HState.general;  	break;  }  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: content_length *= 10;  
Magic Number,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following statement contains a magic number: content_length *= 16;  
Magic Number,Manos.Http,HttpStream,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpStream.cs,SendFileData,The following statement contains a magic number: if (SocketStream is ISendfileCapable) {  	((ISendfileCapable)SocketStream).SendFile (fileName);  } else {  	SocketStream.PauseWriting ();  	var fs = HttpEntity.Context.OpenFile (fileName' OpenMode.Read' 64 * 1024);  	SocketStream.Write (new StreamCopySequencer (fs' SocketStream' true));  }  
Magic Number,Manos.Http,HttpStream,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpStream.cs,SendFileData,The following statement contains a magic number: if (SocketStream is ISendfileCapable) {  	((ISendfileCapable)SocketStream).SendFile (fileName);  } else {  	SocketStream.PauseWriting ();  	var fs = HttpEntity.Context.OpenFile (fileName' OpenMode.Read' 64 * 1024);  	SocketStream.Write (new StreamCopySequencer (fs' SocketStream' true));  }  
Magic Number,Manos.Http,HttpStream,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpStream.cs,SendChunk,The following statement contains a magic number: chunk_buffer [i++] = 13;  
Magic Number,Manos.Http,HttpStream,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpStream.cs,SendChunk,The following statement contains a magic number: chunk_buffer [i++] = 10;  
Magic Number,Manos.Http,HttpStream,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpStream.cs,SendChunk,The following statement contains a magic number: if (last) {  	chunk_buffer [i++] = 13;  	chunk_buffer [i++] = 10;  }  
Magic Number,Manos.Http,HttpStream,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpStream.cs,SendChunk,The following statement contains a magic number: if (last) {  	chunk_buffer [i++] = 13;  	chunk_buffer [i++] = 10;  }  
Magic Number,Manos.Http,HttpStream,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpStream.cs,SendChunk,The following statement contains a magic number: chunk_buffer [i++] = 13;  
Magic Number,Manos.Http,HttpStream,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpStream.cs,SendChunk,The following statement contains a magic number: chunk_buffer [i++] = 10;  
Magic Number,Manos.Http,HttpHeaders,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpHeaders.cs,EncodeHeaderString,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	ch = input [i];  	if ((ch < 32 && ch != 9) || ch == 127)  		StringBuilderAppend (String.Format ("%{0:x2}"' (int)ch)' ref sb);  }  
Magic Number,Manos.Http,HttpHeaders,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpHeaders.cs,EncodeHeaderString,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	ch = input [i];  	if ((ch < 32 && ch != 9) || ch == 127)  		StringBuilderAppend (String.Format ("%{0:x2}"' (int)ch)' ref sb);  }  
Magic Number,Manos.Http,HttpHeaders,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpHeaders.cs,EncodeHeaderString,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	ch = input [i];  	if ((ch < 32 && ch != 9) || ch == 127)  		StringBuilderAppend (String.Format ("%{0:x2}"' (int)ch)' ref sb);  }  
Magic Number,Manos.Http,HttpHeaders,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpHeaders.cs,EncodeHeaderString,The following statement contains a magic number: if ((ch < 32 && ch != 9) || ch == 127)  	StringBuilderAppend (String.Format ("%{0:x2}"' (int)ch)' ref sb);  
Magic Number,Manos.Http,HttpHeaders,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpHeaders.cs,EncodeHeaderString,The following statement contains a magic number: if ((ch < 32 && ch != 9) || ch == 127)  	StringBuilderAppend (String.Format ("%{0:x2}"' (int)ch)' ref sb);  
Magic Number,Manos.Http,HttpHeaders,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpHeaders.cs,EncodeHeaderString,The following statement contains a magic number: if ((ch < 32 && ch != 9) || ch == 127)  	StringBuilderAppend (String.Format ("%{0:x2}"' (int)ch)' ref sb);  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,HttpResponse,The following statement contains a magic number: StatusCode = 200;  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,Redirect,The following statement contains a magic number: StatusCode = 302;  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following statement contains a magic number: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Magic Number,Manos.Http,HttpServer,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpServer.cs,Listen,The following statement contains a magic number: socket.Listen (128' ConnectionAccepted);  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	ch = s [i];  	if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  		if (s [i + 1] == 'u' && i + 5 < len) {  			// unicode hex sequence  			xchar = GetChar (s' i + 2' 4);  			if (xchar != -1) {  				WriteCharBytes (bytes' (char)xchar' e);  				i += 5;  			} else  				WriteCharBytes (bytes' '%'' e);  		} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 2;  		} else {  			WriteCharBytes (bytes' '%'' e);  		}  		continue;  	}  	if (ch == '+')  		WriteCharBytes (bytes' ' '' e);  	else  		WriteCharBytes (bytes' ch' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	ch = s [i];  	if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  		if (s [i + 1] == 'u' && i + 5 < len) {  			// unicode hex sequence  			xchar = GetChar (s' i + 2' 4);  			if (xchar != -1) {  				WriteCharBytes (bytes' (char)xchar' e);  				i += 5;  			} else  				WriteCharBytes (bytes' '%'' e);  		} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 2;  		} else {  			WriteCharBytes (bytes' '%'' e);  		}  		continue;  	}  	if (ch == '+')  		WriteCharBytes (bytes' ' '' e);  	else  		WriteCharBytes (bytes' ch' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	ch = s [i];  	if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  		if (s [i + 1] == 'u' && i + 5 < len) {  			// unicode hex sequence  			xchar = GetChar (s' i + 2' 4);  			if (xchar != -1) {  				WriteCharBytes (bytes' (char)xchar' e);  				i += 5;  			} else  				WriteCharBytes (bytes' '%'' e);  		} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 2;  		} else {  			WriteCharBytes (bytes' '%'' e);  		}  		continue;  	}  	if (ch == '+')  		WriteCharBytes (bytes' ' '' e);  	else  		WriteCharBytes (bytes' ch' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	ch = s [i];  	if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  		if (s [i + 1] == 'u' && i + 5 < len) {  			// unicode hex sequence  			xchar = GetChar (s' i + 2' 4);  			if (xchar != -1) {  				WriteCharBytes (bytes' (char)xchar' e);  				i += 5;  			} else  				WriteCharBytes (bytes' '%'' e);  		} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 2;  		} else {  			WriteCharBytes (bytes' '%'' e);  		}  		continue;  	}  	if (ch == '+')  		WriteCharBytes (bytes' ' '' e);  	else  		WriteCharBytes (bytes' ch' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	ch = s [i];  	if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  		if (s [i + 1] == 'u' && i + 5 < len) {  			// unicode hex sequence  			xchar = GetChar (s' i + 2' 4);  			if (xchar != -1) {  				WriteCharBytes (bytes' (char)xchar' e);  				i += 5;  			} else  				WriteCharBytes (bytes' '%'' e);  		} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 2;  		} else {  			WriteCharBytes (bytes' '%'' e);  		}  		continue;  	}  	if (ch == '+')  		WriteCharBytes (bytes' ' '' e);  	else  		WriteCharBytes (bytes' ch' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	ch = s [i];  	if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  		if (s [i + 1] == 'u' && i + 5 < len) {  			// unicode hex sequence  			xchar = GetChar (s' i + 2' 4);  			if (xchar != -1) {  				WriteCharBytes (bytes' (char)xchar' e);  				i += 5;  			} else  				WriteCharBytes (bytes' '%'' e);  		} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 2;  		} else {  			WriteCharBytes (bytes' '%'' e);  		}  		continue;  	}  	if (ch == '+')  		WriteCharBytes (bytes' ' '' e);  	else  		WriteCharBytes (bytes' ch' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	ch = s [i];  	if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  		if (s [i + 1] == 'u' && i + 5 < len) {  			// unicode hex sequence  			xchar = GetChar (s' i + 2' 4);  			if (xchar != -1) {  				WriteCharBytes (bytes' (char)xchar' e);  				i += 5;  			} else  				WriteCharBytes (bytes' '%'' e);  		} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 2;  		} else {  			WriteCharBytes (bytes' '%'' e);  		}  		continue;  	}  	if (ch == '+')  		WriteCharBytes (bytes' ' '' e);  	else  		WriteCharBytes (bytes' ch' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  	if (s [i + 1] == 'u' && i + 5 < len) {  		// unicode hex sequence  		xchar = GetChar (s' i + 2' 4);  		if (xchar != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 5;  		} else  			WriteCharBytes (bytes' '%'' e);  	} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 2;  	} else {  		WriteCharBytes (bytes' '%'' e);  	}  	continue;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  	if (s [i + 1] == 'u' && i + 5 < len) {  		// unicode hex sequence  		xchar = GetChar (s' i + 2' 4);  		if (xchar != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 5;  		} else  			WriteCharBytes (bytes' '%'' e);  	} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 2;  	} else {  		WriteCharBytes (bytes' '%'' e);  	}  	continue;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  	if (s [i + 1] == 'u' && i + 5 < len) {  		// unicode hex sequence  		xchar = GetChar (s' i + 2' 4);  		if (xchar != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 5;  		} else  			WriteCharBytes (bytes' '%'' e);  	} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 2;  	} else {  		WriteCharBytes (bytes' '%'' e);  	}  	continue;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  	if (s [i + 1] == 'u' && i + 5 < len) {  		// unicode hex sequence  		xchar = GetChar (s' i + 2' 4);  		if (xchar != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 5;  		} else  			WriteCharBytes (bytes' '%'' e);  	} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 2;  	} else {  		WriteCharBytes (bytes' '%'' e);  	}  	continue;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  	if (s [i + 1] == 'u' && i + 5 < len) {  		// unicode hex sequence  		xchar = GetChar (s' i + 2' 4);  		if (xchar != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 5;  		} else  			WriteCharBytes (bytes' '%'' e);  	} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 2;  	} else {  		WriteCharBytes (bytes' '%'' e);  	}  	continue;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  	if (s [i + 1] == 'u' && i + 5 < len) {  		// unicode hex sequence  		xchar = GetChar (s' i + 2' 4);  		if (xchar != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 5;  		} else  			WriteCharBytes (bytes' '%'' e);  	} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 2;  	} else {  		WriteCharBytes (bytes' '%'' e);  	}  	continue;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i + 2 < len && s [i + 1] != '%') {  	if (s [i + 1] == 'u' && i + 5 < len) {  		// unicode hex sequence  		xchar = GetChar (s' i + 2' 4);  		if (xchar != -1) {  			WriteCharBytes (bytes' (char)xchar' e);  			i += 5;  		} else  			WriteCharBytes (bytes' '%'' e);  	} else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 2;  	} else {  		WriteCharBytes (bytes' '%'' e);  	}  	continue;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (s [i + 1] == 'u' && i + 5 < len) {  	// unicode hex sequence  	xchar = GetChar (s' i + 2' 4);  	if (xchar != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 5;  	} else  		WriteCharBytes (bytes' '%'' e);  } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  	WriteCharBytes (bytes' (char)xchar' e);  	i += 2;  } else {  	WriteCharBytes (bytes' '%'' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (s [i + 1] == 'u' && i + 5 < len) {  	// unicode hex sequence  	xchar = GetChar (s' i + 2' 4);  	if (xchar != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 5;  	} else  		WriteCharBytes (bytes' '%'' e);  } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  	WriteCharBytes (bytes' (char)xchar' e);  	i += 2;  } else {  	WriteCharBytes (bytes' '%'' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (s [i + 1] == 'u' && i + 5 < len) {  	// unicode hex sequence  	xchar = GetChar (s' i + 2' 4);  	if (xchar != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 5;  	} else  		WriteCharBytes (bytes' '%'' e);  } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  	WriteCharBytes (bytes' (char)xchar' e);  	i += 2;  } else {  	WriteCharBytes (bytes' '%'' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (s [i + 1] == 'u' && i + 5 < len) {  	// unicode hex sequence  	xchar = GetChar (s' i + 2' 4);  	if (xchar != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 5;  	} else  		WriteCharBytes (bytes' '%'' e);  } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  	WriteCharBytes (bytes' (char)xchar' e);  	i += 2;  } else {  	WriteCharBytes (bytes' '%'' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (s [i + 1] == 'u' && i + 5 < len) {  	// unicode hex sequence  	xchar = GetChar (s' i + 2' 4);  	if (xchar != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 5;  	} else  		WriteCharBytes (bytes' '%'' e);  } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  	WriteCharBytes (bytes' (char)xchar' e);  	i += 2;  } else {  	WriteCharBytes (bytes' '%'' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (s [i + 1] == 'u' && i + 5 < len) {  	// unicode hex sequence  	xchar = GetChar (s' i + 2' 4);  	if (xchar != -1) {  		WriteCharBytes (bytes' (char)xchar' e);  		i += 5;  	} else  		WriteCharBytes (bytes' '%'' e);  } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {  	WriteCharBytes (bytes' (char)xchar' e);  	i += 2;  } else {  	WriteCharBytes (bytes' '%'' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: xchar = GetChar (s' i + 2' 4);  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: xchar = GetChar (s' i + 2' 4);  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if (xchar != -1) {  	WriteCharBytes (bytes' (char)xchar' e);  	i += 5;  } else  	WriteCharBytes (bytes' '%'' e);  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: i += 5;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if ((xchar = GetChar (s' i + 1' 2)) != -1) {  	WriteCharBytes (bytes' (char)xchar' e);  	i += 2;  } else {  	WriteCharBytes (bytes' '%'' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: if ((xchar = GetChar (s' i + 1' 2)) != -1) {  	WriteCharBytes (bytes' (char)xchar' e);  	i += 2;  } else {  	WriteCharBytes (bytes' '%'' e);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,UrlDecode,The following statement contains a magic number: i += 2;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,GetInt,The following statement contains a magic number: if (c >= 'a' && c <= 'f')  	return c - 'a' + 10;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,GetInt,The following statement contains a magic number: return c - 'a' + 10;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,GetInt,The following statement contains a magic number: if (c >= 'A' && c <= 'F')  	return c - 'A' + 10;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,GetInt,The following statement contains a magic number: return c - 'A' + 10;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,WriteCharBytes,The following statement contains a magic number: if (ch > 255) {  	foreach (byte b in e.GetBytes (new char[] {  		ch  	}))  		buf.Add (b);  } else  	buf.Add ((byte)ch);  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,GetChar,The following statement contains a magic number: for (int i = offset; i < end; i++) {  	int current = GetInt (bytes [i]);  	if (current == -1)  		return -1;  	value = (value << 4) + current;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,GetChar,The following statement contains a magic number: value = (value << 4) + current;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,GetChar,The following statement contains a magic number: for (int i = offset; i < end; i++) {  	char c = str [i];  	if (c > 127)  		return -1;  	int current = GetInt ((byte)c);  	if (current == -1)  		return -1;  	val = (val << 4) + current;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,GetChar,The following statement contains a magic number: for (int i = offset; i < end; i++) {  	char c = str [i];  	if (c > 127)  		return -1;  	int current = GetInt ((byte)c);  	if (current == -1)  		return -1;  	val = (val << 4) + current;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,GetChar,The following statement contains a magic number: if (c > 127)  	return -1;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,GetChar,The following statement contains a magic number: val = (val << 4) + current;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	char c = s [i];  	if (state == 0) {  		if (c == '&') {  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  			state = 1;  		} else {  			output.Append (c);  		}  		continue;  	}  	if (c == '&') {  		state = 1;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		output.Append (entity.ToString ());  		entity.Length = 0;  		entity.Append ('&');  		continue;  	}  	if (state == 1) {  		if (c == ';') {  			state = 0;  			output.Append (entity.ToString ());  			output.Append (c);  			entity.Length = 0;  		} else {  			number = 0;  			is_hex_value = false;  			if (c != '#') {  				state = 2;  			} else {  				state = 3;  			}  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  		}  	} else if (state == 2) {  		entity.Append (c);  		if (c == ';') {  			string key = entity.ToString ();  			if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  				key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  			output.Append (key);  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  		}  	} else if (state == 3) {  		if (c == ';') {  			#if NET_4_0  									if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  			if (number > 65535) {  				output.Append ("&#");  				output.Append (number.ToString (CultureInfo.InvariantCulture));  				output.Append (";");  			} else {  				output.Append ((char)number);  			}  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  			have_trailing_digits = false;  		} else if (is_hex_value && Uri.IsHexDigit (c)) {  			number = number * 16 + Uri.FromHex (c);  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (Char.IsDigit (c)) {  			number = number * 10 + ((int)c - '0');  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (number == 0 && (c == 'x' || c == 'X')) {  			is_hex_value = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else {  			state = 2;  			if (have_trailing_digits) {  				entity.Append (number.ToString (CultureInfo.InvariantCulture));  				have_trailing_digits = false;  			}  			entity.Append (c);  		}  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	char c = s [i];  	if (state == 0) {  		if (c == '&') {  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  			state = 1;  		} else {  			output.Append (c);  		}  		continue;  	}  	if (c == '&') {  		state = 1;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		output.Append (entity.ToString ());  		entity.Length = 0;  		entity.Append ('&');  		continue;  	}  	if (state == 1) {  		if (c == ';') {  			state = 0;  			output.Append (entity.ToString ());  			output.Append (c);  			entity.Length = 0;  		} else {  			number = 0;  			is_hex_value = false;  			if (c != '#') {  				state = 2;  			} else {  				state = 3;  			}  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  		}  	} else if (state == 2) {  		entity.Append (c);  		if (c == ';') {  			string key = entity.ToString ();  			if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  				key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  			output.Append (key);  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  		}  	} else if (state == 3) {  		if (c == ';') {  			#if NET_4_0  									if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  			if (number > 65535) {  				output.Append ("&#");  				output.Append (number.ToString (CultureInfo.InvariantCulture));  				output.Append (";");  			} else {  				output.Append ((char)number);  			}  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  			have_trailing_digits = false;  		} else if (is_hex_value && Uri.IsHexDigit (c)) {  			number = number * 16 + Uri.FromHex (c);  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (Char.IsDigit (c)) {  			number = number * 10 + ((int)c - '0');  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (number == 0 && (c == 'x' || c == 'X')) {  			is_hex_value = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else {  			state = 2;  			if (have_trailing_digits) {  				entity.Append (number.ToString (CultureInfo.InvariantCulture));  				have_trailing_digits = false;  			}  			entity.Append (c);  		}  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	char c = s [i];  	if (state == 0) {  		if (c == '&') {  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  			state = 1;  		} else {  			output.Append (c);  		}  		continue;  	}  	if (c == '&') {  		state = 1;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		output.Append (entity.ToString ());  		entity.Length = 0;  		entity.Append ('&');  		continue;  	}  	if (state == 1) {  		if (c == ';') {  			state = 0;  			output.Append (entity.ToString ());  			output.Append (c);  			entity.Length = 0;  		} else {  			number = 0;  			is_hex_value = false;  			if (c != '#') {  				state = 2;  			} else {  				state = 3;  			}  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  		}  	} else if (state == 2) {  		entity.Append (c);  		if (c == ';') {  			string key = entity.ToString ();  			if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  				key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  			output.Append (key);  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  		}  	} else if (state == 3) {  		if (c == ';') {  			#if NET_4_0  									if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  			if (number > 65535) {  				output.Append ("&#");  				output.Append (number.ToString (CultureInfo.InvariantCulture));  				output.Append (";");  			} else {  				output.Append ((char)number);  			}  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  			have_trailing_digits = false;  		} else if (is_hex_value && Uri.IsHexDigit (c)) {  			number = number * 16 + Uri.FromHex (c);  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (Char.IsDigit (c)) {  			number = number * 10 + ((int)c - '0');  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (number == 0 && (c == 'x' || c == 'X')) {  			is_hex_value = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else {  			state = 2;  			if (have_trailing_digits) {  				entity.Append (number.ToString (CultureInfo.InvariantCulture));  				have_trailing_digits = false;  			}  			entity.Append (c);  		}  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	char c = s [i];  	if (state == 0) {  		if (c == '&') {  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  			state = 1;  		} else {  			output.Append (c);  		}  		continue;  	}  	if (c == '&') {  		state = 1;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		output.Append (entity.ToString ());  		entity.Length = 0;  		entity.Append ('&');  		continue;  	}  	if (state == 1) {  		if (c == ';') {  			state = 0;  			output.Append (entity.ToString ());  			output.Append (c);  			entity.Length = 0;  		} else {  			number = 0;  			is_hex_value = false;  			if (c != '#') {  				state = 2;  			} else {  				state = 3;  			}  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  		}  	} else if (state == 2) {  		entity.Append (c);  		if (c == ';') {  			string key = entity.ToString ();  			if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  				key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  			output.Append (key);  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  		}  	} else if (state == 3) {  		if (c == ';') {  			#if NET_4_0  									if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  			if (number > 65535) {  				output.Append ("&#");  				output.Append (number.ToString (CultureInfo.InvariantCulture));  				output.Append (";");  			} else {  				output.Append ((char)number);  			}  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  			have_trailing_digits = false;  		} else if (is_hex_value && Uri.IsHexDigit (c)) {  			number = number * 16 + Uri.FromHex (c);  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (Char.IsDigit (c)) {  			number = number * 10 + ((int)c - '0');  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (number == 0 && (c == 'x' || c == 'X')) {  			is_hex_value = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else {  			state = 2;  			if (have_trailing_digits) {  				entity.Append (number.ToString (CultureInfo.InvariantCulture));  				have_trailing_digits = false;  			}  			entity.Append (c);  		}  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	char c = s [i];  	if (state == 0) {  		if (c == '&') {  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  			state = 1;  		} else {  			output.Append (c);  		}  		continue;  	}  	if (c == '&') {  		state = 1;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		output.Append (entity.ToString ());  		entity.Length = 0;  		entity.Append ('&');  		continue;  	}  	if (state == 1) {  		if (c == ';') {  			state = 0;  			output.Append (entity.ToString ());  			output.Append (c);  			entity.Length = 0;  		} else {  			number = 0;  			is_hex_value = false;  			if (c != '#') {  				state = 2;  			} else {  				state = 3;  			}  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  		}  	} else if (state == 2) {  		entity.Append (c);  		if (c == ';') {  			string key = entity.ToString ();  			if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  				key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  			output.Append (key);  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  		}  	} else if (state == 3) {  		if (c == ';') {  			#if NET_4_0  									if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  			if (number > 65535) {  				output.Append ("&#");  				output.Append (number.ToString (CultureInfo.InvariantCulture));  				output.Append (";");  			} else {  				output.Append ((char)number);  			}  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  			have_trailing_digits = false;  		} else if (is_hex_value && Uri.IsHexDigit (c)) {  			number = number * 16 + Uri.FromHex (c);  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (Char.IsDigit (c)) {  			number = number * 10 + ((int)c - '0');  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (number == 0 && (c == 'x' || c == 'X')) {  			is_hex_value = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else {  			state = 2;  			if (have_trailing_digits) {  				entity.Append (number.ToString (CultureInfo.InvariantCulture));  				have_trailing_digits = false;  			}  			entity.Append (c);  		}  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	char c = s [i];  	if (state == 0) {  		if (c == '&') {  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  			state = 1;  		} else {  			output.Append (c);  		}  		continue;  	}  	if (c == '&') {  		state = 1;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		output.Append (entity.ToString ());  		entity.Length = 0;  		entity.Append ('&');  		continue;  	}  	if (state == 1) {  		if (c == ';') {  			state = 0;  			output.Append (entity.ToString ());  			output.Append (c);  			entity.Length = 0;  		} else {  			number = 0;  			is_hex_value = false;  			if (c != '#') {  				state = 2;  			} else {  				state = 3;  			}  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  		}  	} else if (state == 2) {  		entity.Append (c);  		if (c == ';') {  			string key = entity.ToString ();  			if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  				key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  			output.Append (key);  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  		}  	} else if (state == 3) {  		if (c == ';') {  			#if NET_4_0  									if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  			if (number > 65535) {  				output.Append ("&#");  				output.Append (number.ToString (CultureInfo.InvariantCulture));  				output.Append (";");  			} else {  				output.Append ((char)number);  			}  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  			have_trailing_digits = false;  		} else if (is_hex_value && Uri.IsHexDigit (c)) {  			number = number * 16 + Uri.FromHex (c);  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (Char.IsDigit (c)) {  			number = number * 10 + ((int)c - '0');  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (number == 0 && (c == 'x' || c == 'X')) {  			is_hex_value = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else {  			state = 2;  			if (have_trailing_digits) {  				entity.Append (number.ToString (CultureInfo.InvariantCulture));  				have_trailing_digits = false;  			}  			entity.Append (c);  		}  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	char c = s [i];  	if (state == 0) {  		if (c == '&') {  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  			state = 1;  		} else {  			output.Append (c);  		}  		continue;  	}  	if (c == '&') {  		state = 1;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		output.Append (entity.ToString ());  		entity.Length = 0;  		entity.Append ('&');  		continue;  	}  	if (state == 1) {  		if (c == ';') {  			state = 0;  			output.Append (entity.ToString ());  			output.Append (c);  			entity.Length = 0;  		} else {  			number = 0;  			is_hex_value = false;  			if (c != '#') {  				state = 2;  			} else {  				state = 3;  			}  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  		}  	} else if (state == 2) {  		entity.Append (c);  		if (c == ';') {  			string key = entity.ToString ();  			if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  				key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  			output.Append (key);  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  		}  	} else if (state == 3) {  		if (c == ';') {  			#if NET_4_0  									if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  			if (number > 65535) {  				output.Append ("&#");  				output.Append (number.ToString (CultureInfo.InvariantCulture));  				output.Append (";");  			} else {  				output.Append ((char)number);  			}  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  			have_trailing_digits = false;  		} else if (is_hex_value && Uri.IsHexDigit (c)) {  			number = number * 16 + Uri.FromHex (c);  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (Char.IsDigit (c)) {  			number = number * 10 + ((int)c - '0');  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (number == 0 && (c == 'x' || c == 'X')) {  			is_hex_value = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else {  			state = 2;  			if (have_trailing_digits) {  				entity.Append (number.ToString (CultureInfo.InvariantCulture));  				have_trailing_digits = false;  			}  			entity.Append (c);  		}  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	char c = s [i];  	if (state == 0) {  		if (c == '&') {  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  			state = 1;  		} else {  			output.Append (c);  		}  		continue;  	}  	if (c == '&') {  		state = 1;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		output.Append (entity.ToString ());  		entity.Length = 0;  		entity.Append ('&');  		continue;  	}  	if (state == 1) {  		if (c == ';') {  			state = 0;  			output.Append (entity.ToString ());  			output.Append (c);  			entity.Length = 0;  		} else {  			number = 0;  			is_hex_value = false;  			if (c != '#') {  				state = 2;  			} else {  				state = 3;  			}  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  		}  	} else if (state == 2) {  		entity.Append (c);  		if (c == ';') {  			string key = entity.ToString ();  			if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  				key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  			output.Append (key);  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  		}  	} else if (state == 3) {  		if (c == ';') {  			#if NET_4_0  									if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  			if (number > 65535) {  				output.Append ("&#");  				output.Append (number.ToString (CultureInfo.InvariantCulture));  				output.Append (";");  			} else {  				output.Append ((char)number);  			}  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  			have_trailing_digits = false;  		} else if (is_hex_value && Uri.IsHexDigit (c)) {  			number = number * 16 + Uri.FromHex (c);  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (Char.IsDigit (c)) {  			number = number * 10 + ((int)c - '0');  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (number == 0 && (c == 'x' || c == 'X')) {  			is_hex_value = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else {  			state = 2;  			if (have_trailing_digits) {  				entity.Append (number.ToString (CultureInfo.InvariantCulture));  				have_trailing_digits = false;  			}  			entity.Append (c);  		}  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	char c = s [i];  	if (state == 0) {  		if (c == '&') {  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  			state = 1;  		} else {  			output.Append (c);  		}  		continue;  	}  	if (c == '&') {  		state = 1;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		output.Append (entity.ToString ());  		entity.Length = 0;  		entity.Append ('&');  		continue;  	}  	if (state == 1) {  		if (c == ';') {  			state = 0;  			output.Append (entity.ToString ());  			output.Append (c);  			entity.Length = 0;  		} else {  			number = 0;  			is_hex_value = false;  			if (c != '#') {  				state = 2;  			} else {  				state = 3;  			}  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  		}  	} else if (state == 2) {  		entity.Append (c);  		if (c == ';') {  			string key = entity.ToString ();  			if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  				key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  			output.Append (key);  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  		}  	} else if (state == 3) {  		if (c == ';') {  			#if NET_4_0  									if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  			if (number > 65535) {  				output.Append ("&#");  				output.Append (number.ToString (CultureInfo.InvariantCulture));  				output.Append (";");  			} else {  				output.Append ((char)number);  			}  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  			have_trailing_digits = false;  		} else if (is_hex_value && Uri.IsHexDigit (c)) {  			number = number * 16 + Uri.FromHex (c);  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (Char.IsDigit (c)) {  			number = number * 10 + ((int)c - '0');  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (number == 0 && (c == 'x' || c == 'X')) {  			is_hex_value = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else {  			state = 2;  			if (have_trailing_digits) {  				entity.Append (number.ToString (CultureInfo.InvariantCulture));  				have_trailing_digits = false;  			}  			entity.Append (c);  		}  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	char c = s [i];  	if (state == 0) {  		if (c == '&') {  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  			state = 1;  		} else {  			output.Append (c);  		}  		continue;  	}  	if (c == '&') {  		state = 1;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		output.Append (entity.ToString ());  		entity.Length = 0;  		entity.Append ('&');  		continue;  	}  	if (state == 1) {  		if (c == ';') {  			state = 0;  			output.Append (entity.ToString ());  			output.Append (c);  			entity.Length = 0;  		} else {  			number = 0;  			is_hex_value = false;  			if (c != '#') {  				state = 2;  			} else {  				state = 3;  			}  			entity.Append (c);  			#if NET_4_0  									rawEntity.Append (c); #endif  		}  	} else if (state == 2) {  		entity.Append (c);  		if (c == ';') {  			string key = entity.ToString ();  			if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  				key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  			output.Append (key);  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  		}  	} else if (state == 3) {  		if (c == ';') {  			#if NET_4_0  									if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  			if (number > 65535) {  				output.Append ("&#");  				output.Append (number.ToString (CultureInfo.InvariantCulture));  				output.Append (";");  			} else {  				output.Append ((char)number);  			}  			state = 0;  			entity.Length = 0;  			#if NET_4_0  									rawEntity.Length = 0; #endif  			have_trailing_digits = false;  		} else if (is_hex_value && Uri.IsHexDigit (c)) {  			number = number * 16 + Uri.FromHex (c);  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (Char.IsDigit (c)) {  			number = number * 10 + ((int)c - '0');  			have_trailing_digits = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else if (number == 0 && (c == 'x' || c == 'X')) {  			is_hex_value = true;  			#if NET_4_0  									rawEntity.Append (c); #endif  		} else {  			state = 2;  			if (have_trailing_digits) {  				entity.Append (number.ToString (CultureInfo.InvariantCulture));  				have_trailing_digits = false;  			}  			entity.Append (c);  		}  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 1) {  	if (c == ';') {  		state = 0;  		output.Append (entity.ToString ());  		output.Append (c);  		entity.Length = 0;  	} else {  		number = 0;  		is_hex_value = false;  		if (c != '#') {  			state = 2;  		} else {  			state = 3;  		}  		entity.Append (c);  		#if NET_4_0  								rawEntity.Append (c); #endif  	}  } else if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 1) {  	if (c == ';') {  		state = 0;  		output.Append (entity.ToString ());  		output.Append (c);  		entity.Length = 0;  	} else {  		number = 0;  		is_hex_value = false;  		if (c != '#') {  			state = 2;  		} else {  			state = 3;  		}  		entity.Append (c);  		#if NET_4_0  								rawEntity.Append (c); #endif  	}  } else if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 1) {  	if (c == ';') {  		state = 0;  		output.Append (entity.ToString ());  		output.Append (c);  		entity.Length = 0;  	} else {  		number = 0;  		is_hex_value = false;  		if (c != '#') {  			state = 2;  		} else {  			state = 3;  		}  		entity.Append (c);  		#if NET_4_0  								rawEntity.Append (c); #endif  	}  } else if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 1) {  	if (c == ';') {  		state = 0;  		output.Append (entity.ToString ());  		output.Append (c);  		entity.Length = 0;  	} else {  		number = 0;  		is_hex_value = false;  		if (c != '#') {  			state = 2;  		} else {  			state = 3;  		}  		entity.Append (c);  		#if NET_4_0  								rawEntity.Append (c); #endif  	}  } else if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 1) {  	if (c == ';') {  		state = 0;  		output.Append (entity.ToString ());  		output.Append (c);  		entity.Length = 0;  	} else {  		number = 0;  		is_hex_value = false;  		if (c != '#') {  			state = 2;  		} else {  			state = 3;  		}  		entity.Append (c);  		#if NET_4_0  								rawEntity.Append (c); #endif  	}  } else if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 1) {  	if (c == ';') {  		state = 0;  		output.Append (entity.ToString ());  		output.Append (c);  		entity.Length = 0;  	} else {  		number = 0;  		is_hex_value = false;  		if (c != '#') {  			state = 2;  		} else {  			state = 3;  		}  		entity.Append (c);  		#if NET_4_0  								rawEntity.Append (c); #endif  	}  } else if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 1) {  	if (c == ';') {  		state = 0;  		output.Append (entity.ToString ());  		output.Append (c);  		entity.Length = 0;  	} else {  		number = 0;  		is_hex_value = false;  		if (c != '#') {  			state = 2;  		} else {  			state = 3;  		}  		entity.Append (c);  		#if NET_4_0  								rawEntity.Append (c); #endif  	}  } else if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 1) {  	if (c == ';') {  		state = 0;  		output.Append (entity.ToString ());  		output.Append (c);  		entity.Length = 0;  	} else {  		number = 0;  		is_hex_value = false;  		if (c != '#') {  			state = 2;  		} else {  			state = 3;  		}  		entity.Append (c);  		#if NET_4_0  								rawEntity.Append (c); #endif  	}  } else if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 1) {  	if (c == ';') {  		state = 0;  		output.Append (entity.ToString ());  		output.Append (c);  		entity.Length = 0;  	} else {  		number = 0;  		is_hex_value = false;  		if (c != '#') {  			state = 2;  		} else {  			state = 3;  		}  		entity.Append (c);  		#if NET_4_0  								rawEntity.Append (c); #endif  	}  } else if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 1) {  	if (c == ';') {  		state = 0;  		output.Append (entity.ToString ());  		output.Append (c);  		entity.Length = 0;  	} else {  		number = 0;  		is_hex_value = false;  		if (c != '#') {  			state = 2;  		} else {  			state = 3;  		}  		entity.Append (c);  		#if NET_4_0  								rawEntity.Append (c); #endif  	}  } else if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (c == ';') {  	state = 0;  	output.Append (entity.ToString ());  	output.Append (c);  	entity.Length = 0;  } else {  	number = 0;  	is_hex_value = false;  	if (c != '#') {  		state = 2;  	} else {  		state = 3;  	}  	entity.Append (c);  	#if NET_4_0  							rawEntity.Append (c); #endif  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (c == ';') {  	state = 0;  	output.Append (entity.ToString ());  	output.Append (c);  	entity.Length = 0;  } else {  	number = 0;  	is_hex_value = false;  	if (c != '#') {  		state = 2;  	} else {  		state = 3;  	}  	entity.Append (c);  	#if NET_4_0  							rawEntity.Append (c); #endif  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (c != '#') {  	state = 2;  } else {  	state = 3;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (c != '#') {  	state = 2;  } else {  	state = 3;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: state = 2;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: state = 3;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 2) {  	entity.Append (c);  	if (c == ';') {  		string key = entity.ToString ();  		if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  			key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  		output.Append (key);  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  	}  } else if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (c == ';') {  	string key = entity.ToString ();  	if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  		key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  	output.Append (key);  	state = 0;  	entity.Length = 0;  	#if NET_4_0  							rawEntity.Length = 0; #endif  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (c == ';') {  	string key = entity.ToString ();  	if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  		key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  	output.Append (key);  	state = 0;  	entity.Length = 0;  	#if NET_4_0  							rawEntity.Length = 0; #endif  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  	key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (key.Length > 1 && HtmlEntities.ContainsKey (key.Substring (1' key.Length - 2)))  	key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: key = HtmlEntities [key.Substring (1' key.Length - 2)].ToString ();  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (state == 3) {  	if (c == ';') {  		#if NET_4_0  								if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  		if (number > 65535) {  			output.Append ("&#");  			output.Append (number.ToString (CultureInfo.InvariantCulture));  			output.Append (";");  		} else {  			output.Append ((char)number);  		}  		state = 0;  		entity.Length = 0;  		#if NET_4_0  								rawEntity.Length = 0; #endif  		have_trailing_digits = false;  	} else if (is_hex_value && Uri.IsHexDigit (c)) {  		number = number * 16 + Uri.FromHex (c);  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (Char.IsDigit (c)) {  		number = number * 10 + ((int)c - '0');  		have_trailing_digits = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else if (number == 0 && (c == 'x' || c == 'X')) {  		is_hex_value = true;  		#if NET_4_0  								rawEntity.Append (c); #endif  	} else {  		state = 2;  		if (have_trailing_digits) {  			entity.Append (number.ToString (CultureInfo.InvariantCulture));  			have_trailing_digits = false;  		}  		entity.Append (c);  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (c == ';') {  	#if NET_4_0  							if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  	if (number > 65535) {  		output.Append ("&#");  		output.Append (number.ToString (CultureInfo.InvariantCulture));  		output.Append (";");  	} else {  		output.Append ((char)number);  	}  	state = 0;  	entity.Length = 0;  	#if NET_4_0  							rawEntity.Length = 0; #endif  	have_trailing_digits = false;  } else if (is_hex_value && Uri.IsHexDigit (c)) {  	number = number * 16 + Uri.FromHex (c);  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (Char.IsDigit (c)) {  	number = number * 10 + ((int)c - '0');  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (number == 0 && (c == 'x' || c == 'X')) {  	is_hex_value = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else {  	state = 2;  	if (have_trailing_digits) {  		entity.Append (number.ToString (CultureInfo.InvariantCulture));  		have_trailing_digits = false;  	}  	entity.Append (c);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (c == ';') {  	#if NET_4_0  							if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  	if (number > 65535) {  		output.Append ("&#");  		output.Append (number.ToString (CultureInfo.InvariantCulture));  		output.Append (";");  	} else {  		output.Append ((char)number);  	}  	state = 0;  	entity.Length = 0;  	#if NET_4_0  							rawEntity.Length = 0; #endif  	have_trailing_digits = false;  } else if (is_hex_value && Uri.IsHexDigit (c)) {  	number = number * 16 + Uri.FromHex (c);  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (Char.IsDigit (c)) {  	number = number * 10 + ((int)c - '0');  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (number == 0 && (c == 'x' || c == 'X')) {  	is_hex_value = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else {  	state = 2;  	if (have_trailing_digits) {  		entity.Append (number.ToString (CultureInfo.InvariantCulture));  		have_trailing_digits = false;  	}  	entity.Append (c);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (c == ';') {  	#if NET_4_0  							if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  	if (number > 65535) {  		output.Append ("&#");  		output.Append (number.ToString (CultureInfo.InvariantCulture));  		output.Append (";");  	} else {  		output.Append ((char)number);  	}  	state = 0;  	entity.Length = 0;  	#if NET_4_0  							rawEntity.Length = 0; #endif  	have_trailing_digits = false;  } else if (is_hex_value && Uri.IsHexDigit (c)) {  	number = number * 16 + Uri.FromHex (c);  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (Char.IsDigit (c)) {  	number = number * 10 + ((int)c - '0');  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (number == 0 && (c == 'x' || c == 'X')) {  	is_hex_value = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else {  	state = 2;  	if (have_trailing_digits) {  		entity.Append (number.ToString (CultureInfo.InvariantCulture));  		have_trailing_digits = false;  	}  	entity.Append (c);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (c == ';') {  	#if NET_4_0  							if (number == 0) 							output.Append (rawEntity.ToString () + ";"); 						else #endif  	if (number > 65535) {  		output.Append ("&#");  		output.Append (number.ToString (CultureInfo.InvariantCulture));  		output.Append (";");  	} else {  		output.Append ((char)number);  	}  	state = 0;  	entity.Length = 0;  	#if NET_4_0  							rawEntity.Length = 0; #endif  	have_trailing_digits = false;  } else if (is_hex_value && Uri.IsHexDigit (c)) {  	number = number * 16 + Uri.FromHex (c);  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (Char.IsDigit (c)) {  	number = number * 10 + ((int)c - '0');  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (number == 0 && (c == 'x' || c == 'X')) {  	is_hex_value = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else {  	state = 2;  	if (have_trailing_digits) {  		entity.Append (number.ToString (CultureInfo.InvariantCulture));  		have_trailing_digits = false;  	}  	entity.Append (c);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (number > 65535) {  	output.Append ("&#");  	output.Append (number.ToString (CultureInfo.InvariantCulture));  	output.Append (";");  } else {  	output.Append ((char)number);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (is_hex_value && Uri.IsHexDigit (c)) {  	number = number * 16 + Uri.FromHex (c);  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (Char.IsDigit (c)) {  	number = number * 10 + ((int)c - '0');  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (number == 0 && (c == 'x' || c == 'X')) {  	is_hex_value = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else {  	state = 2;  	if (have_trailing_digits) {  		entity.Append (number.ToString (CultureInfo.InvariantCulture));  		have_trailing_digits = false;  	}  	entity.Append (c);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (is_hex_value && Uri.IsHexDigit (c)) {  	number = number * 16 + Uri.FromHex (c);  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (Char.IsDigit (c)) {  	number = number * 10 + ((int)c - '0');  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (number == 0 && (c == 'x' || c == 'X')) {  	is_hex_value = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else {  	state = 2;  	if (have_trailing_digits) {  		entity.Append (number.ToString (CultureInfo.InvariantCulture));  		have_trailing_digits = false;  	}  	entity.Append (c);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (is_hex_value && Uri.IsHexDigit (c)) {  	number = number * 16 + Uri.FromHex (c);  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (Char.IsDigit (c)) {  	number = number * 10 + ((int)c - '0');  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (number == 0 && (c == 'x' || c == 'X')) {  	is_hex_value = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else {  	state = 2;  	if (have_trailing_digits) {  		entity.Append (number.ToString (CultureInfo.InvariantCulture));  		have_trailing_digits = false;  	}  	entity.Append (c);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: number = number * 16 + Uri.FromHex (c);  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (Char.IsDigit (c)) {  	number = number * 10 + ((int)c - '0');  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (number == 0 && (c == 'x' || c == 'X')) {  	is_hex_value = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else {  	state = 2;  	if (have_trailing_digits) {  		entity.Append (number.ToString (CultureInfo.InvariantCulture));  		have_trailing_digits = false;  	}  	entity.Append (c);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (Char.IsDigit (c)) {  	number = number * 10 + ((int)c - '0');  	have_trailing_digits = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else if (number == 0 && (c == 'x' || c == 'X')) {  	is_hex_value = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else {  	state = 2;  	if (have_trailing_digits) {  		entity.Append (number.ToString (CultureInfo.InvariantCulture));  		have_trailing_digits = false;  	}  	entity.Append (c);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: number = number * 10 + ((int)c - '0');  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (number == 0 && (c == 'x' || c == 'X')) {  	is_hex_value = true;  	#if NET_4_0  							rawEntity.Append (c); #endif  } else {  	state = 2;  	if (have_trailing_digits) {  		entity.Append (number.ToString (CultureInfo.InvariantCulture));  		have_trailing_digits = false;  	}  	entity.Append (c);  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: state = 2;  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlEncode,The following statement contains a magic number: for (int i = 0; i < s.Length; i++) {  	char c = s [i];  	if (c == '&' || c == '"' || c == '<' || c == '>' || c > 159 || c == '\'') {  		needEncode = true;  		break;  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlEncode,The following statement contains a magic number: if (c == '&' || c == '"' || c == '<' || c == '>' || c > 159 || c == '\'') {  	needEncode = true;  	break;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlEncode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	switch (s [i]) {  	case '&':  		output.Append ("&amp;");  		break;  	case '>':  		output.Append ("&gt;");  		break;  	case '<':  		output.Append ("&lt;");  		break;  	case '"':  		output.Append ("&quot;");  		break;  	case '\'':  		output.Append ("&#39;");  		break;  	case '\uff1c':  		output.Append ("&#65308;");  		break;  	case '\uff1e':  		output.Append ("&#65310;");  		break;  	default:  		ch = s [i];  		if (ch > 159 && ch < 256) {  			output.Append ("&#");  			output.Append (((int)ch).ToString (System.Globalization.CultureInfo.InvariantCulture));  			output.Append (";");  		} else  			output.Append (ch);  		break;  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlEncode,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	switch (s [i]) {  	case '&':  		output.Append ("&amp;");  		break;  	case '>':  		output.Append ("&gt;");  		break;  	case '<':  		output.Append ("&lt;");  		break;  	case '"':  		output.Append ("&quot;");  		break;  	case '\'':  		output.Append ("&#39;");  		break;  	case '\uff1c':  		output.Append ("&#65308;");  		break;  	case '\uff1e':  		output.Append ("&#65310;");  		break;  	default:  		ch = s [i];  		if (ch > 159 && ch < 256) {  			output.Append ("&#");  			output.Append (((int)ch).ToString (System.Globalization.CultureInfo.InvariantCulture));  			output.Append (";");  		} else  			output.Append (ch);  		break;  	}  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlEncode,The following statement contains a magic number: switch (s [i]) {  case '&':  	output.Append ("&amp;");  	break;  case '>':  	output.Append ("&gt;");  	break;  case '<':  	output.Append ("&lt;");  	break;  case '"':  	output.Append ("&quot;");  	break;  case '\'':  	output.Append ("&#39;");  	break;  case '\uff1c':  	output.Append ("&#65308;");  	break;  case '\uff1e':  	output.Append ("&#65310;");  	break;  default:  	ch = s [i];  	if (ch > 159 && ch < 256) {  		output.Append ("&#");  		output.Append (((int)ch).ToString (System.Globalization.CultureInfo.InvariantCulture));  		output.Append (";");  	} else  		output.Append (ch);  	break;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlEncode,The following statement contains a magic number: switch (s [i]) {  case '&':  	output.Append ("&amp;");  	break;  case '>':  	output.Append ("&gt;");  	break;  case '<':  	output.Append ("&lt;");  	break;  case '"':  	output.Append ("&quot;");  	break;  case '\'':  	output.Append ("&#39;");  	break;  case '\uff1c':  	output.Append ("&#65308;");  	break;  case '\uff1e':  	output.Append ("&#65310;");  	break;  default:  	ch = s [i];  	if (ch > 159 && ch < 256) {  		output.Append ("&#");  		output.Append (((int)ch).ToString (System.Globalization.CultureInfo.InvariantCulture));  		output.Append (";");  	} else  		output.Append (ch);  	break;  }  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlEncode,The following statement contains a magic number: if (ch > 159 && ch < 256) {  	output.Append ("&#");  	output.Append (((int)ch).ToString (System.Globalization.CultureInfo.InvariantCulture));  	output.Append (";");  } else  	output.Append (ch);  
Magic Number,Manos.Http,HttpUtility,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpUtility.cs,HtmlEncode,The following statement contains a magic number: if (ch > 159 && ch < 256) {  	output.Append ("&#");  	output.Append (((int)ch).ToString (System.Globalization.CultureInfo.InvariantCulture));  	output.Append (";");  } else  	output.Append (ch);  
Magic Number,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,EmitFastInt,The following statement contains a magic number: switch (value) {  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	return;  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	return;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	return;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	return;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	return;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	return;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	return;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	return;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	return;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	return;  }  
Magic Number,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,EmitFastInt,The following statement contains a magic number: switch (value) {  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	return;  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	return;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	return;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	return;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	return;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	return;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	return;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	return;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	return;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	return;  }  
Magic Number,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,EmitFastInt,The following statement contains a magic number: switch (value) {  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	return;  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	return;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	return;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	return;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	return;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	return;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	return;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	return;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	return;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	return;  }  
Magic Number,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,EmitFastInt,The following statement contains a magic number: switch (value) {  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	return;  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	return;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	return;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	return;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	return;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	return;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	return;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	return;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	return;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	return;  }  
Magic Number,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,EmitFastInt,The following statement contains a magic number: switch (value) {  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	return;  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	return;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	return;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	return;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	return;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	return;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	return;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	return;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	return;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	return;  }  
Magic Number,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,EmitFastInt,The following statement contains a magic number: switch (value) {  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	return;  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	return;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	return;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	return;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	return;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	return;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	return;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	return;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	return;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	return;  }  
Magic Number,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,EmitFastInt,The following statement contains a magic number: switch (value) {  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	return;  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	return;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	return;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	return;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	return;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	return;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	return;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	return;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	return;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	return;  }  
Magic Number,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,EmitFastInt,The following statement contains a magic number: if (value > -129 && value < 128)  	il.Emit (OpCodes.Ldc_I4_S' (SByte)value);  else  	il.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,EmitFastInt,The following statement contains a magic number: if (value > -129 && value < 128)  	il.Emit (OpCodes.Ldc_I4_S' (SByte)value);  else  	il.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Manos.Routing,ParameterizedActionTarget,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionTarget.cs,Invoke,The following statement contains a magic number: if (!TryGetDataForParamList (parameters' app' ctx' out data)) {  	// TODO: More graceful way of handling this?  	ctx.Transaction.Abort (400' "Can not convert parameters to match Action argument list.");  	return;  }  
Magic Number,Manos.Routing,ParameterizedActionTarget,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionTarget.cs,Invoke,The following statement contains a magic number: ctx.Transaction.Abort (400' "Can not convert parameters to match Action argument list.");  
Magic Number,Manos.Routing,ParameterizedActionTarget,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionTarget.cs,TryConvertType,The following statement contains a magic number: if (dest.GetInterface ("IDictionary") != null) {  	var dict = ctx.Request.Data.GetDict (name);  	if (dict != null) {  		Type eltype = typeof(UnsafeString);  		IDictionary dd = (IDictionary)Activator.CreateInstance (dest);  		if (dest.IsGenericType) {  			Type[] args = dest.GetGenericArguments ();  			if (args.Length != 2)  				throw new Exception ("Generic Dictionaries must contain two generic type arguments.");  			if (args [0] != typeof(string))  				throw new Exception ("Generic Dictionaries must use strings for their keys.");  			eltype = args [1];  			// ie the TValue in Dictionary<TKey'TValue>  		}  		foreach (string key in dict.Keys) {  			object elem_data;  			if (!TryConvertUnsafeString (ctx' eltype' param' dict [key]' out elem_data)) {  				data = null;  				return false;  			}  			dd.Add (key' elem_data);  		}  		data = dd;  		return true;  	}  }  
Magic Number,Manos.Routing,ParameterizedActionTarget,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionTarget.cs,TryConvertType,The following statement contains a magic number: if (dict != null) {  	Type eltype = typeof(UnsafeString);  	IDictionary dd = (IDictionary)Activator.CreateInstance (dest);  	if (dest.IsGenericType) {  		Type[] args = dest.GetGenericArguments ();  		if (args.Length != 2)  			throw new Exception ("Generic Dictionaries must contain two generic type arguments.");  		if (args [0] != typeof(string))  			throw new Exception ("Generic Dictionaries must use strings for their keys.");  		eltype = args [1];  		// ie the TValue in Dictionary<TKey'TValue>  	}  	foreach (string key in dict.Keys) {  		object elem_data;  		if (!TryConvertUnsafeString (ctx' eltype' param' dict [key]' out elem_data)) {  			data = null;  			return false;  		}  		dd.Add (key' elem_data);  	}  	data = dd;  	return true;  }  
Magic Number,Manos.Routing,ParameterizedActionTarget,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionTarget.cs,TryConvertType,The following statement contains a magic number: if (dest.IsGenericType) {  	Type[] args = dest.GetGenericArguments ();  	if (args.Length != 2)  		throw new Exception ("Generic Dictionaries must contain two generic type arguments.");  	if (args [0] != typeof(string))  		throw new Exception ("Generic Dictionaries must use strings for their keys.");  	eltype = args [1];  	// ie the TValue in Dictionary<TKey'TValue>  }  
Magic Number,Manos.Routing,ParameterizedActionTarget,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionTarget.cs,TryConvertType,The following statement contains a magic number: if (args.Length != 2)  	throw new Exception ("Generic Dictionaries must contain two generic type arguments.");  
Magic Number,Manos.Routing,SimpleMatchOperation,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\SimpleMatchOperation.cs,IsMatch,The following statement contains a magic number: foreach (Group g in groups) {  	// scan until start  	int g_start = start + g.Start;  	int len = g_start - pattern_pos;  	for (int i = start; i < len; i++) {  		if (input [input_pos] != pattern [pattern_pos])  			return false;  		input_pos++;  		pattern_pos++;  		if (input_pos > input.Length - 1)  			return false;  	}  	if (g.End == pattern.Length - 1) {  		// slurp until end  		data_str = input.Substring (input_pos);  		if (data == null)  			data = new DataDictionary ();  		data.Set (g.Name' data_str);  		end = input.Length;  		return true;  	}  	int input_start = input_pos;  	char end_marker = pattern [g.End + 1];  	while (input [input_pos] != end_marker) {  		input_pos++;  		if (input_pos >= input.Length)  			return false;  	}  	data_str = input.Substring (input_start' input_pos - input_start);  	if (data == null)  		data = new DataDictionary ();  	data.Set (g.Name' data_str);  	input_pos++;  	pattern_pos = g.End + 2;  }  
Magic Number,Manos.Routing,SimpleMatchOperation,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\SimpleMatchOperation.cs,IsMatch,The following statement contains a magic number: pattern_pos = g.End + 2;  
Magic Number,Manos.Routing,SimpleMatchOperation,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\SimpleMatchOperation.cs,UpdateGroups,The following statement contains a magic number: while (start >= 0) {  	if (start < pattern.Length - 1 && pattern [start + 1] == '{') {  		start += 2;  		continue;  	}  	bool not_closed = false;  	int end = pattern.IndexOf ('}'' start + 1);  	while (end < pattern.Length - 1 && pattern [end + 1] == '}') {  		end = pattern.IndexOf ('}'' start + 1);  		if (end < 0)  			not_closed = true;  	}  	if (not_closed) {  		Console.Error.WriteLine ("Unclosed matching group in '{0}'. All matches will be disabled."' pattern);  		groups = null;  		return;  	}  	Group group = new Group (start' end' pattern.Substring (start + 1' end - start - 1));  	groups.Add (group);  	start = pattern.IndexOf ('{'' end);  }  
Magic Number,Manos.Routing,SimpleMatchOperation,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\SimpleMatchOperation.cs,UpdateGroups,The following statement contains a magic number: if (start < pattern.Length - 1 && pattern [start + 1] == '{') {  	start += 2;  	continue;  }  
Magic Number,Manos.Routing,SimpleMatchOperation,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\SimpleMatchOperation.cs,UpdateGroups,The following statement contains a magic number: start += 2;  
Magic Number,Manos.Http.Testing,MockHttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http.Testing\MockHttpResponse.cs,Redirect,The following statement contains a magic number: StatusCode = 302;  
Missing Default,Manos,Pipeline,F:\newReposMay17\jacksonh_manos\src\Manos\Manos\Pipeline.cs,StepCompleted,The following switch statement is missing a default case: switch (step) {  case PipelineStep.Execute:  	Execute ();  	break;  case PipelineStep.PostProcess:  	PostProcess ();  	break;  case PipelineStep.Complete:  	Complete ();  	break;  }  
Missing Default,Manos.Http,HttpFormDataHandler,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpFormDataHandler.cs,HandleData,The following switch statement is missing a default case: switch (state) {  case State.InKey:  	key_buffer.Append (c);  	break;  case State.InValue:  	value_buffer.Append (c);  	break;  }  
Missing Default,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,Execute,The following switch statement is missing a default case: switch (state) {  case State.header_field:  	header_field_mark = p;  	break;  case State.header_value:  	header_value_mark = p;  	break;  case State.req_fragment:  	fragment_mark = p;  	url_mark = p;  	break;  case State.req_query_string:  	query_string_mark = p;  	url_mark = p;  	break;  case State.req_path:  	path_mark = p;  	// JACKSON ADDED' I assume java can fall through?  	url_mark = p;  	break;  case State.req_host:  case State.req_schema:  case State.req_schema_slash:  case State.req_schema_slash_slash:  case State.req_port:  case State.req_query_string_start:  case State.req_fragment_start:  	url_mark = p;  	break;  }  
Missing Default,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,usual,The following switch statement is missing a default case: switch (b) {  case NULL:  case CR:  case LF:  case SPACE:  case QMARK:  case HASH:  	return false;  }  
Missing Default,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,start_req_method_assign,The following switch statement is missing a default case: switch (c) {  case C:  	return HttpMethod.HTTP_CONNECT;  /* or COPY' CHECKOUT */case D:  	return HttpMethod.HTTP_DELETE;  case G:  	return HttpMethod.HTTP_GET;  case H:  	return HttpMethod.HTTP_HEAD;  case L:  	return HttpMethod.HTTP_LOCK;  case M:  	return HttpMethod.HTTP_MKCOL;  /* or MOVE' MKACTIVITY' MERGE */case O:  	return HttpMethod.HTTP_OPTIONS;  case P:  	return HttpMethod.HTTP_POST;  /* or PROPFIND' PROPPATH' PUT */case R:  	return HttpMethod.HTTP_REPORT;  case T:  	return HttpMethod.HTTP_TRACE;  case U:  	return HttpMethod.HTTP_UNLOCK;  }  
Missing Default,Manos.Http,HttpParser,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpParser.cs,parsing_header,The following switch statement is missing a default case: switch (state) {  case State.chunk_size_start:  case State.chunk_size:  case State.chunk_size_almost_done:  case State.chunk_parameters:  case State.chunk_data:  case State.chunk_data_almost_done:  case State.chunk_data_done:  case State.body_identity:  case State.body_identity_eof:  	return false;  }  
Missing Default,Manos.Http,HttpResponse,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Http\HttpResponse.cs,GetStatusDescription,The following switch statement is missing a default case: switch (code) {  case 100:  	return "Continue";  case 101:  	return "Switching Protocols";  case 102:  	return "Processing";  case 200:  	return "OK";  case 201:  	return "Created";  case 202:  	return "Accepted";  case 203:  	return "Non-Authoritative Information";  case 204:  	return "No Content";  case 205:  	return "Reset Content";  case 206:  	return "Partial Content";  case 207:  	return "Multi-Status";  case 300:  	return "Multiple Choices";  case 301:  	return "Moved Permanently";  case 302:  	return "Found";  case 303:  	return "See Other";  case 304:  	return "Not Modified";  case 305:  	return "Use Proxy";  case 307:  	return "Temporary Redirect";  case 400:  	return "Bad Request";  case 401:  	return "Unauthorized";  case 402:  	return "Payment Required";  case 403:  	return "Forbidden";  case 404:  	return "Not Found";  case 405:  	return "Method Not Allowed";  case 406:  	return "Not Acceptable";  case 407:  	return "Proxy Authentication Required";  case 408:  	return "Request Timeout";  case 409:  	return "Conflict";  case 410:  	return "Gone";  case 411:  	return "Length Required";  case 412:  	return "Precondition Failed";  case 413:  	return "Request Entity Too Large";  case 414:  	return "Request-Uri Too Long";  case 415:  	return "Unsupported Media Type";  case 416:  	return "Requested Range Not Satisfiable";  case 417:  	return "Expectation Failed";  case 422:  	return "Unprocessable Entity";  case 423:  	return "Locked";  case 424:  	return "Failed Dependency";  case 500:  	return "Internal Server Error";  case 501:  	return "Not Implemented";  case 502:  	return "Bad Gateway";  case 503:  	return "Service Unavailable";  case 504:  	return "Gateway Timeout";  case 505:  	return "Http Version Not Supported";  case 507:  	return "Insufficient Storage";  }  
Missing Default,Manos.Routing,ParameterizedActionFactory,F:\newReposMay17\jacksonh_manos\src\Manos\Manos.Routing\ParameterizedActionFactory.cs,EmitFastInt,The following switch statement is missing a default case: switch (value) {  case -1:  	il.Emit (OpCodes.Ldc_I4_M1);  	return;  case 0:  	il.Emit (OpCodes.Ldc_I4_0);  	return;  case 1:  	il.Emit (OpCodes.Ldc_I4_1);  	return;  case 2:  	il.Emit (OpCodes.Ldc_I4_2);  	return;  case 3:  	il.Emit (OpCodes.Ldc_I4_3);  	return;  case 4:  	il.Emit (OpCodes.Ldc_I4_4);  	return;  case 5:  	il.Emit (OpCodes.Ldc_I4_5);  	return;  case 6:  	il.Emit (OpCodes.Ldc_I4_6);  	return;  case 7:  	il.Emit (OpCodes.Ldc_I4_7);  	return;  case 8:  	il.Emit (OpCodes.Ldc_I4_8);  	return;  }  
