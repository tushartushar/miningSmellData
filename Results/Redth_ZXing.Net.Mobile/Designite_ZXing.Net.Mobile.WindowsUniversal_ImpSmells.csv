Implementation smell,Namespace,Class,File,Method,Description
Long Method,ZXing.Mobile,WriteableBitmapRenderer,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\WriteableBitmapRenderer.cs,Render,The method has 134 lines of code.
Long Method,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StartScanningAsync,The method has 172 lines of code.
Complex Method,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StartScanningAsync,Cyclomatic complexity of the method is 14
Long Statement,ZXing.Mobile,MobileBarcodeScanner,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\MobileBarcodeScanner.cs,ScanContinuously,The length of the statement  "            var rootFrame = RootFrame ?? Window.Current.Content as Frame ?? ((FrameworkElement) Window.Current.Content).GetFirstChildOfType<Frame>(); " is 137.
Long Statement,ZXing.Mobile,MobileBarcodeScanner,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\MobileBarcodeScanner.cs,Scan,The length of the statement  "            var rootFrame = RootFrame ?? Window.Current.Content as Frame ?? ((FrameworkElement) Window.Current.Content).GetFirstChildOfType<Frame>(); " is 137.
Long Statement,ZXing.Mobile,MobileBarcodeScanner,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\MobileBarcodeScanner.cs,Cancel,The length of the statement  "            var rootFrame = RootFrame ?? Window.Current.Content as Frame ?? ((FrameworkElement)Window.Current.Content).GetFirstChildOfType<Frame>(); " is 136.
Long Statement,ZXing.Mobile,WriteableBitmapRenderer,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\WriteableBitmapRenderer.cs,Render,The length of the statement  "         using (var stream = System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsStream(bmp.PixelBuffer)) " is 123.
Long Statement,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StartScanningAsync,The length of the statement  "            if (preferredCamera.EnclosureLocation == null || preferredCamera.EnclosureLocation.Panel == Windows.Devices.Enumeration.Panel.Unknown) " is 134.
Long Statement,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StartScanningAsync,The length of the statement  "            var availableProperties = mediaCapture.VideoDeviceController.GetAvailableMediaStreamProperties(MediaStreamType.VideoPreview); " is 125.
Long Statement,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StartScanningAsync,The length of the statement  "            var chosenProp = availableProperties.FirstOrDefault(ap => ((VideoEncodingProperties)ap).Width == previewResolution.Width && ((VideoEncodingProperties)ap).Height == previewResolution.Height); " is 190.
Long Statement,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StopScanningAsync,The length of the statement  "                //second execution from sample will crash if the object is not properly disposed (always on mobile' sometimes on desktop) " is 121.
Long Statement,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,SetPreviewRotationAsync,The length of the statement  "            // Add rotation metadata to the preview stream to make sure the aspect ratio / dimensions match when rendering and getting preview frames " is 137.
Long Statement,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,SetPreviewRotationAsync,The length of the statement  "            videoFrame = new VideoFrame(Windows.Graphics.Imaging.BitmapPixelFormat.Bgra8' (int)currentPreviewResolution.Width' (int)currentPreviewResolution.Height); " is 153.
Long Statement,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,GetPreviewStreamRectInControl,The length of the statement  "            // Start by assuming the preview display area in the control spans the entire width and height both (this is corrected in the next if for the necessary dimension) " is 162.
Complex Conditional,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StartScanningAsync,The conditional expression  "sps.Width >= 640 && sps.Width <= 1000 && sps.Height >= 360 && sps.Height <= 1000"  is complex.
Complex Conditional,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StartScanningAsync,The conditional expression  "stopping || processing || !isAnalyzing                  || (mediaCapture == null || mediaCapture.CameraStreamState != Windows.Media.Devices.CameraStreamState.Streaming)"  is complex.
Complex Conditional,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,GetPreviewStreamRectInControl,The conditional expression  "previewControl == null || previewControl.ActualHeight < 1 || previewControl.ActualWidth < 1 ||                  previewResolution.Height < 1 || previewResolution.Width < 1"  is complex.
Empty Catch Block,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StopScanningAsync,The method has an empty catch block.
Magic Number,ZXing.Mobile,SoftwareBitmapLuminanceSource,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\SoftwareBitmapLuminanceSource.cs,CalculateLuminance,The following statement contains a magic number: if (bitmap.BitmapPixelFormat == BitmapPixelFormat.Bgra8)              {                  // In BGRA8 format' each pixel is defined by 4 bytes                  const int BYTES_PER_PIXEL = 4;                    using (var buffer = bitmap.LockBuffer(BitmapBufferAccessMode.Read))                  using (var reference = buffer.CreateReference())                  {                        if (reference is IMemoryBufferByteAccess)                      {                              try                          {                              // Get a pointer to the pixel buffer                              byte* data;                              uint capacity;                              ((IMemoryBufferByteAccess)reference).GetBuffer(out data' out capacity);                                // Get information about the BitmapBuffer                              var desc = buffer.GetPlaneDescription(0);                              var luminanceIndex = 0;                                // Iterate over all pixels                              for (uint row = 0; row < desc.Height; row++)                              {                                  for (uint col = 0; col < desc.Width; col++)                                  {                                      // Index of the current pixel in the buffer (defined by the next 4 bytes' BGRA8)                                      var currPixel = desc.StartIndex + desc.Stride * row + BYTES_PER_PIXEL * col;                                        // Read the current pixel information into b'g'r channels (leave out alpha channel)                                      var b = data[currPixel + 0]; // Blue                                      var g = data[currPixel + 1]; // Green                                      var r = data[currPixel + 2]; // Red                                        var luminance = (byte)((RChannelWeight * r + GChannelWeight * g + BChannelWeight * b) >> ChannelWeight);                                      var alpha = data[currPixel + 3];                                      luminance = (byte)(((luminance * alpha) >> 8) + (255 * (255 - alpha) >> 8));                                      luminances[luminanceIndex] = luminance;                                      luminanceIndex++;                                  }                              }                          }                          catch (Exception ex)                          {                              System.Diagnostics.Debug.WriteLine("Luminance Source Failed: {0}"' ex);                          }                      }                  }              }
Magic Number,ZXing.Mobile,SoftwareBitmapLuminanceSource,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\SoftwareBitmapLuminanceSource.cs,CalculateLuminance,The following statement contains a magic number: if (bitmap.BitmapPixelFormat == BitmapPixelFormat.Bgra8)              {                  // In BGRA8 format' each pixel is defined by 4 bytes                  const int BYTES_PER_PIXEL = 4;                    using (var buffer = bitmap.LockBuffer(BitmapBufferAccessMode.Read))                  using (var reference = buffer.CreateReference())                  {                        if (reference is IMemoryBufferByteAccess)                      {                              try                          {                              // Get a pointer to the pixel buffer                              byte* data;                              uint capacity;                              ((IMemoryBufferByteAccess)reference).GetBuffer(out data' out capacity);                                // Get information about the BitmapBuffer                              var desc = buffer.GetPlaneDescription(0);                              var luminanceIndex = 0;                                // Iterate over all pixels                              for (uint row = 0; row < desc.Height; row++)                              {                                  for (uint col = 0; col < desc.Width; col++)                                  {                                      // Index of the current pixel in the buffer (defined by the next 4 bytes' BGRA8)                                      var currPixel = desc.StartIndex + desc.Stride * row + BYTES_PER_PIXEL * col;                                        // Read the current pixel information into b'g'r channels (leave out alpha channel)                                      var b = data[currPixel + 0]; // Blue                                      var g = data[currPixel + 1]; // Green                                      var r = data[currPixel + 2]; // Red                                        var luminance = (byte)((RChannelWeight * r + GChannelWeight * g + BChannelWeight * b) >> ChannelWeight);                                      var alpha = data[currPixel + 3];                                      luminance = (byte)(((luminance * alpha) >> 8) + (255 * (255 - alpha) >> 8));                                      luminances[luminanceIndex] = luminance;                                      luminanceIndex++;                                  }                              }                          }                          catch (Exception ex)                          {                              System.Diagnostics.Debug.WriteLine("Luminance Source Failed: {0}"' ex);                          }                      }                  }              }
Magic Number,ZXing.Mobile,SoftwareBitmapLuminanceSource,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\SoftwareBitmapLuminanceSource.cs,CalculateLuminance,The following statement contains a magic number: if (bitmap.BitmapPixelFormat == BitmapPixelFormat.Bgra8)              {                  // In BGRA8 format' each pixel is defined by 4 bytes                  const int BYTES_PER_PIXEL = 4;                    using (var buffer = bitmap.LockBuffer(BitmapBufferAccessMode.Read))                  using (var reference = buffer.CreateReference())                  {                        if (reference is IMemoryBufferByteAccess)                      {                              try                          {                              // Get a pointer to the pixel buffer                              byte* data;                              uint capacity;                              ((IMemoryBufferByteAccess)reference).GetBuffer(out data' out capacity);                                // Get information about the BitmapBuffer                              var desc = buffer.GetPlaneDescription(0);                              var luminanceIndex = 0;                                // Iterate over all pixels                              for (uint row = 0; row < desc.Height; row++)                              {                                  for (uint col = 0; col < desc.Width; col++)                                  {                                      // Index of the current pixel in the buffer (defined by the next 4 bytes' BGRA8)                                      var currPixel = desc.StartIndex + desc.Stride * row + BYTES_PER_PIXEL * col;                                        // Read the current pixel information into b'g'r channels (leave out alpha channel)                                      var b = data[currPixel + 0]; // Blue                                      var g = data[currPixel + 1]; // Green                                      var r = data[currPixel + 2]; // Red                                        var luminance = (byte)((RChannelWeight * r + GChannelWeight * g + BChannelWeight * b) >> ChannelWeight);                                      var alpha = data[currPixel + 3];                                      luminance = (byte)(((luminance * alpha) >> 8) + (255 * (255 - alpha) >> 8));                                      luminances[luminanceIndex] = luminance;                                      luminanceIndex++;                                  }                              }                          }                          catch (Exception ex)                          {                              System.Diagnostics.Debug.WriteLine("Luminance Source Failed: {0}"' ex);                          }                      }                  }              }
Magic Number,ZXing.Mobile,SoftwareBitmapLuminanceSource,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\SoftwareBitmapLuminanceSource.cs,CalculateLuminance,The following statement contains a magic number: if (bitmap.BitmapPixelFormat == BitmapPixelFormat.Bgra8)              {                  // In BGRA8 format' each pixel is defined by 4 bytes                  const int BYTES_PER_PIXEL = 4;                    using (var buffer = bitmap.LockBuffer(BitmapBufferAccessMode.Read))                  using (var reference = buffer.CreateReference())                  {                        if (reference is IMemoryBufferByteAccess)                      {                              try                          {                              // Get a pointer to the pixel buffer                              byte* data;                              uint capacity;                              ((IMemoryBufferByteAccess)reference).GetBuffer(out data' out capacity);                                // Get information about the BitmapBuffer                              var desc = buffer.GetPlaneDescription(0);                              var luminanceIndex = 0;                                // Iterate over all pixels                              for (uint row = 0; row < desc.Height; row++)                              {                                  for (uint col = 0; col < desc.Width; col++)                                  {                                      // Index of the current pixel in the buffer (defined by the next 4 bytes' BGRA8)                                      var currPixel = desc.StartIndex + desc.Stride * row + BYTES_PER_PIXEL * col;                                        // Read the current pixel information into b'g'r channels (leave out alpha channel)                                      var b = data[currPixel + 0]; // Blue                                      var g = data[currPixel + 1]; // Green                                      var r = data[currPixel + 2]; // Red                                        var luminance = (byte)((RChannelWeight * r + GChannelWeight * g + BChannelWeight * b) >> ChannelWeight);                                      var alpha = data[currPixel + 3];                                      luminance = (byte)(((luminance * alpha) >> 8) + (255 * (255 - alpha) >> 8));                                      luminances[luminanceIndex] = luminance;                                      luminanceIndex++;                                  }                              }                          }                          catch (Exception ex)                          {                              System.Diagnostics.Debug.WriteLine("Luminance Source Failed: {0}"' ex);                          }                      }                  }              }
Magic Number,ZXing.Mobile,SoftwareBitmapLuminanceSource,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\SoftwareBitmapLuminanceSource.cs,CalculateLuminance,The following statement contains a magic number: if (bitmap.BitmapPixelFormat == BitmapPixelFormat.Bgra8)              {                  // In BGRA8 format' each pixel is defined by 4 bytes                  const int BYTES_PER_PIXEL = 4;                    using (var buffer = bitmap.LockBuffer(BitmapBufferAccessMode.Read))                  using (var reference = buffer.CreateReference())                  {                        if (reference is IMemoryBufferByteAccess)                      {                              try                          {                              // Get a pointer to the pixel buffer                              byte* data;                              uint capacity;                              ((IMemoryBufferByteAccess)reference).GetBuffer(out data' out capacity);                                // Get information about the BitmapBuffer                              var desc = buffer.GetPlaneDescription(0);                              var luminanceIndex = 0;                                // Iterate over all pixels                              for (uint row = 0; row < desc.Height; row++)                              {                                  for (uint col = 0; col < desc.Width; col++)                                  {                                      // Index of the current pixel in the buffer (defined by the next 4 bytes' BGRA8)                                      var currPixel = desc.StartIndex + desc.Stride * row + BYTES_PER_PIXEL * col;                                        // Read the current pixel information into b'g'r channels (leave out alpha channel)                                      var b = data[currPixel + 0]; // Blue                                      var g = data[currPixel + 1]; // Green                                      var r = data[currPixel + 2]; // Red                                        var luminance = (byte)((RChannelWeight * r + GChannelWeight * g + BChannelWeight * b) >> ChannelWeight);                                      var alpha = data[currPixel + 3];                                      luminance = (byte)(((luminance * alpha) >> 8) + (255 * (255 - alpha) >> 8));                                      luminances[luminanceIndex] = luminance;                                      luminanceIndex++;                                  }                              }                          }                          catch (Exception ex)                          {                              System.Diagnostics.Debug.WriteLine("Luminance Source Failed: {0}"' ex);                          }                      }                  }              }
Magic Number,ZXing.Mobile,SoftwareBitmapLuminanceSource,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\SoftwareBitmapLuminanceSource.cs,CalculateLuminance,The following statement contains a magic number: if (bitmap.BitmapPixelFormat == BitmapPixelFormat.Bgra8)              {                  // In BGRA8 format' each pixel is defined by 4 bytes                  const int BYTES_PER_PIXEL = 4;                    using (var buffer = bitmap.LockBuffer(BitmapBufferAccessMode.Read))                  using (var reference = buffer.CreateReference())                  {                        if (reference is IMemoryBufferByteAccess)                      {                              try                          {                              // Get a pointer to the pixel buffer                              byte* data;                              uint capacity;                              ((IMemoryBufferByteAccess)reference).GetBuffer(out data' out capacity);                                // Get information about the BitmapBuffer                              var desc = buffer.GetPlaneDescription(0);                              var luminanceIndex = 0;                                // Iterate over all pixels                              for (uint row = 0; row < desc.Height; row++)                              {                                  for (uint col = 0; col < desc.Width; col++)                                  {                                      // Index of the current pixel in the buffer (defined by the next 4 bytes' BGRA8)                                      var currPixel = desc.StartIndex + desc.Stride * row + BYTES_PER_PIXEL * col;                                        // Read the current pixel information into b'g'r channels (leave out alpha channel)                                      var b = data[currPixel + 0]; // Blue                                      var g = data[currPixel + 1]; // Green                                      var r = data[currPixel + 2]; // Red                                        var luminance = (byte)((RChannelWeight * r + GChannelWeight * g + BChannelWeight * b) >> ChannelWeight);                                      var alpha = data[currPixel + 3];                                      luminance = (byte)(((luminance * alpha) >> 8) + (255 * (255 - alpha) >> 8));                                      luminances[luminanceIndex] = luminance;                                      luminanceIndex++;                                  }                              }                          }                          catch (Exception ex)                          {                              System.Diagnostics.Debug.WriteLine("Luminance Source Failed: {0}"' ex);                          }                      }                  }              }
Magic Number,ZXing.Mobile,SoftwareBitmapLuminanceSource,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\SoftwareBitmapLuminanceSource.cs,CalculateLuminance,The following statement contains a magic number: if (bitmap.BitmapPixelFormat == BitmapPixelFormat.Bgra8)              {                  // In BGRA8 format' each pixel is defined by 4 bytes                  const int BYTES_PER_PIXEL = 4;                    using (var buffer = bitmap.LockBuffer(BitmapBufferAccessMode.Read))                  using (var reference = buffer.CreateReference())                  {                        if (reference is IMemoryBufferByteAccess)                      {                              try                          {                              // Get a pointer to the pixel buffer                              byte* data;                              uint capacity;                              ((IMemoryBufferByteAccess)reference).GetBuffer(out data' out capacity);                                // Get information about the BitmapBuffer                              var desc = buffer.GetPlaneDescription(0);                              var luminanceIndex = 0;                                // Iterate over all pixels                              for (uint row = 0; row < desc.Height; row++)                              {                                  for (uint col = 0; col < desc.Width; col++)                                  {                                      // Index of the current pixel in the buffer (defined by the next 4 bytes' BGRA8)                                      var currPixel = desc.StartIndex + desc.Stride * row + BYTES_PER_PIXEL * col;                                        // Read the current pixel information into b'g'r channels (leave out alpha channel)                                      var b = data[currPixel + 0]; // Blue                                      var g = data[currPixel + 1]; // Green                                      var r = data[currPixel + 2]; // Red                                        var luminance = (byte)((RChannelWeight * r + GChannelWeight * g + BChannelWeight * b) >> ChannelWeight);                                      var alpha = data[currPixel + 3];                                      luminance = (byte)(((luminance * alpha) >> 8) + (255 * (255 - alpha) >> 8));                                      luminances[luminanceIndex] = luminance;                                      luminanceIndex++;                                  }                              }                          }                          catch (Exception ex)                          {                              System.Diagnostics.Debug.WriteLine("Luminance Source Failed: {0}"' ex);                          }                      }                  }              }
Magic Number,ZXing.Mobile,WriteableBitmapRenderer,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\WriteableBitmapRenderer.cs,WriteableBitmapRenderer,The following statement contains a magic number: FontSize = 10.0;
Magic Number,ZXing.Mobile,WriteableBitmapRenderer,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\WriteableBitmapRenderer.cs,Render,The following statement contains a magic number: int emptyArea = outputContent ? 16 : 0;
Magic Number,ZXing.Mobile,WriteableBitmapRenderer,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\WriteableBitmapRenderer.cs,Render,The following statement contains a magic number: using (var stream = System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsStream(bmp.PixelBuffer))           {              for (int y = 0; y < matrix.Height - emptyArea; y++)              {                 for (var pixelsizeHeight = 0; pixelsizeHeight < pixelsize; pixelsizeHeight++)                 {                    for (var x = 0; x < matrix.Width; x++)                    {                       var color = matrix[x' y] ? foreground : background;                       for (var pixelsizeWidth = 0; pixelsizeWidth < pixelsize; pixelsizeWidth++)                       {                          stream.Write(color' 0' 4);                       }                    }                    for (var x = pixelsize * matrix.Width; x < width; x++)                    {                       stream.Write(background' 0' 4);                    }                 }              }              for (int y = matrix.Height * pixelsize - emptyArea; y < height; y++)              {                 for (var x = 0; x < width; x++)                 {                    stream.Write(background' 0' 4);                 }              }           }
Magic Number,ZXing.Mobile,WriteableBitmapRenderer,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\WriteableBitmapRenderer.cs,Render,The following statement contains a magic number: using (var stream = System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsStream(bmp.PixelBuffer))           {              for (int y = 0; y < matrix.Height - emptyArea; y++)              {                 for (var pixelsizeHeight = 0; pixelsizeHeight < pixelsize; pixelsizeHeight++)                 {                    for (var x = 0; x < matrix.Width; x++)                    {                       var color = matrix[x' y] ? foreground : background;                       for (var pixelsizeWidth = 0; pixelsizeWidth < pixelsize; pixelsizeWidth++)                       {                          stream.Write(color' 0' 4);                       }                    }                    for (var x = pixelsize * matrix.Width; x < width; x++)                    {                       stream.Write(background' 0' 4);                    }                 }              }              for (int y = matrix.Height * pixelsize - emptyArea; y < height; y++)              {                 for (var x = 0; x < width; x++)                 {                    stream.Write(background' 0' 4);                 }              }           }
Magic Number,ZXing.Mobile,WriteableBitmapRenderer,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\WriteableBitmapRenderer.cs,Render,The following statement contains a magic number: using (var stream = System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsStream(bmp.PixelBuffer))           {              for (int y = 0; y < matrix.Height - emptyArea; y++)              {                 for (var pixelsizeHeight = 0; pixelsizeHeight < pixelsize; pixelsizeHeight++)                 {                    for (var x = 0; x < matrix.Width; x++)                    {                       var color = matrix[x' y] ? foreground : background;                       for (var pixelsizeWidth = 0; pixelsizeWidth < pixelsize; pixelsizeWidth++)                       {                          stream.Write(color' 0' 4);                       }                    }                    for (var x = pixelsize * matrix.Width; x < width; x++)                    {                       stream.Write(background' 0' 4);                    }                 }              }              for (int y = matrix.Height * pixelsize - emptyArea; y < height; y++)              {                 for (var x = 0; x < width; x++)                 {                    stream.Write(background' 0' 4);                 }              }           }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StartScanningAsync,The following statement contains a magic number: if (previewResolution == null)              {                  // Loop through all supported sizes                  foreach (var sps in availableResolutions)                  {                      // Find one that's >= 640x360 but <= 1000x1000                      // This will likely pick the *smallest* size in that range' which should be fine                      if (sps.Width >= 640 && sps.Width <= 1000 && sps.Height >= 360 && sps.Height <= 1000)                      {                          previewResolution = new CameraResolution                          {                              Width = sps.Width'                              Height = sps.Height                          };                          break;                      }                  }              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StartScanningAsync,The following statement contains a magic number: if (previewResolution == null)              {                  // Loop through all supported sizes                  foreach (var sps in availableResolutions)                  {                      // Find one that's >= 640x360 but <= 1000x1000                      // This will likely pick the *smallest* size in that range' which should be fine                      if (sps.Width >= 640 && sps.Width <= 1000 && sps.Height >= 360 && sps.Height <= 1000)                      {                          previewResolution = new CameraResolution                          {                              Width = sps.Width'                              Height = sps.Height                          };                          break;                      }                  }              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StartScanningAsync,The following statement contains a magic number: if (previewResolution == null)              {                  // Loop through all supported sizes                  foreach (var sps in availableResolutions)                  {                      // Find one that's >= 640x360 but <= 1000x1000                      // This will likely pick the *smallest* size in that range' which should be fine                      if (sps.Width >= 640 && sps.Width <= 1000 && sps.Height >= 360 && sps.Height <= 1000)                      {                          previewResolution = new CameraResolution                          {                              Width = sps.Width'                              Height = sps.Height                          };                          break;                      }                  }              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,StartScanningAsync,The following statement contains a magic number: if (previewResolution == null)              {                  // Loop through all supported sizes                  foreach (var sps in availableResolutions)                  {                      // Find one that's >= 640x360 but <= 1000x1000                      // This will likely pick the *smallest* size in that range' which should be fine                      if (sps.Width >= 640 && sps.Width <= 1000 && sps.Height >= 360 && sps.Height <= 1000)                      {                          previewResolution = new CameraResolution                          {                              Width = sps.Width'                              Height = sps.Height                          };                          break;                      }                  }              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,AutoFocusAsync,The following statement contains a magic number: if (IsFocusSupported)              {                  var focusControl = mediaCapture.VideoDeviceController.FocusControl;                  var roiControl = mediaCapture.VideoDeviceController.RegionsOfInterestControl;                  try                  {                      if (roiControl.AutoFocusSupported && roiControl.MaxRegions > 0)                      {                          if (useCoordinates)                          {                              var props = mediaCapture.VideoDeviceController.GetMediaStreamProperties(MediaStreamType.VideoPreview);                                var previewEncodingProperties = GetPreviewResolution(props);                              var previewRect = GetPreviewStreamRectInControl(previewEncodingProperties' captureElement);                              var focusPreview = ConvertUiTapToPreviewRect(new Point(x' y)' new Size(20' 20)' previewRect);                              var regionOfInterest = new RegionOfInterest                              {                                  AutoFocusEnabled = true'                                  BoundsNormalized = true'                                  Bounds = focusPreview'                                  Type = RegionOfInterestType.Unknown'                                  Weight = 100                              };                              await roiControl.SetRegionsAsync(new[] { regionOfInterest }' true);                                var focusRange = focusControl.SupportedFocusRanges.Contains(AutoFocusRange.FullRange)                                  ? AutoFocusRange.FullRange                                  : focusControl.SupportedFocusRanges.FirstOrDefault();                                var focusMode = focusControl.SupportedFocusModes.Contains(FocusMode.Single)                                  ? FocusMode.Single                                  : focusControl.SupportedFocusModes.FirstOrDefault();                                var settings = new FocusSettings                              {                                  Mode = focusMode'                                  AutoFocusRange = focusRange'                              };                                focusControl.Configure(settings);                          }                          else                          {                              // If no region provided' clear any regions and reset focus                              await roiControl.ClearRegionsAsync();                          }                      }                        await focusControl.FocusAsync();                  }                  catch (Exception ex)                  {                      System.Diagnostics.Debug.WriteLine("AutoFocusAsync Error: {0}"' ex);                  }              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,AutoFocusAsync,The following statement contains a magic number: if (IsFocusSupported)              {                  var focusControl = mediaCapture.VideoDeviceController.FocusControl;                  var roiControl = mediaCapture.VideoDeviceController.RegionsOfInterestControl;                  try                  {                      if (roiControl.AutoFocusSupported && roiControl.MaxRegions > 0)                      {                          if (useCoordinates)                          {                              var props = mediaCapture.VideoDeviceController.GetMediaStreamProperties(MediaStreamType.VideoPreview);                                var previewEncodingProperties = GetPreviewResolution(props);                              var previewRect = GetPreviewStreamRectInControl(previewEncodingProperties' captureElement);                              var focusPreview = ConvertUiTapToPreviewRect(new Point(x' y)' new Size(20' 20)' previewRect);                              var regionOfInterest = new RegionOfInterest                              {                                  AutoFocusEnabled = true'                                  BoundsNormalized = true'                                  Bounds = focusPreview'                                  Type = RegionOfInterestType.Unknown'                                  Weight = 100                              };                              await roiControl.SetRegionsAsync(new[] { regionOfInterest }' true);                                var focusRange = focusControl.SupportedFocusRanges.Contains(AutoFocusRange.FullRange)                                  ? AutoFocusRange.FullRange                                  : focusControl.SupportedFocusRanges.FirstOrDefault();                                var focusMode = focusControl.SupportedFocusModes.Contains(FocusMode.Single)                                  ? FocusMode.Single                                  : focusControl.SupportedFocusModes.FirstOrDefault();                                var settings = new FocusSettings                              {                                  Mode = focusMode'                                  AutoFocusRange = focusRange'                              };                                focusControl.Configure(settings);                          }                          else                          {                              // If no region provided' clear any regions and reset focus                              await roiControl.ClearRegionsAsync();                          }                      }                        await focusControl.FocusAsync();                  }                  catch (Exception ex)                  {                      System.Diagnostics.Debug.WriteLine("AutoFocusAsync Error: {0}"' ex);                  }              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,AutoFocusAsync,The following statement contains a magic number: if (IsFocusSupported)              {                  var focusControl = mediaCapture.VideoDeviceController.FocusControl;                  var roiControl = mediaCapture.VideoDeviceController.RegionsOfInterestControl;                  try                  {                      if (roiControl.AutoFocusSupported && roiControl.MaxRegions > 0)                      {                          if (useCoordinates)                          {                              var props = mediaCapture.VideoDeviceController.GetMediaStreamProperties(MediaStreamType.VideoPreview);                                var previewEncodingProperties = GetPreviewResolution(props);                              var previewRect = GetPreviewStreamRectInControl(previewEncodingProperties' captureElement);                              var focusPreview = ConvertUiTapToPreviewRect(new Point(x' y)' new Size(20' 20)' previewRect);                              var regionOfInterest = new RegionOfInterest                              {                                  AutoFocusEnabled = true'                                  BoundsNormalized = true'                                  Bounds = focusPreview'                                  Type = RegionOfInterestType.Unknown'                                  Weight = 100                              };                              await roiControl.SetRegionsAsync(new[] { regionOfInterest }' true);                                var focusRange = focusControl.SupportedFocusRanges.Contains(AutoFocusRange.FullRange)                                  ? AutoFocusRange.FullRange                                  : focusControl.SupportedFocusRanges.FirstOrDefault();                                var focusMode = focusControl.SupportedFocusModes.Contains(FocusMode.Single)                                  ? FocusMode.Single                                  : focusControl.SupportedFocusModes.FirstOrDefault();                                var settings = new FocusSettings                              {                                  Mode = focusMode'                                  AutoFocusRange = focusRange'                              };                                focusControl.Configure(settings);                          }                          else                          {                              // If no region provided' clear any regions and reset focus                              await roiControl.ClearRegionsAsync();                          }                      }                        await focusControl.FocusAsync();                  }                  catch (Exception ex)                  {                      System.Diagnostics.Debug.WriteLine("AutoFocusAsync Error: {0}"' ex);                  }              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,CalculatePreviewRotation,The following statement contains a magic number: switch (displayInformation.CurrentOrientation)              {                  case DisplayOrientations.Portrait:                      if (mirroringPreview)                      {                          rotationDegrees = 270;                          sourceRotation = VideoRotation.Clockwise270Degrees;                      }                      else                      {                          rotationDegrees = 90;                          sourceRotation = VideoRotation.Clockwise90Degrees;                      }                      break;                    case DisplayOrientations.LandscapeFlipped:                      // No need to invert this rotation' as rotating 180 degrees is the same either way.                      rotationDegrees = 180;                      sourceRotation = VideoRotation.Clockwise180Degrees;                      break;                    case DisplayOrientations.PortraitFlipped:                      if (mirroringPreview)                      {                          rotationDegrees = 90;                          sourceRotation = VideoRotation.Clockwise90Degrees;                      }                      else                      {                          rotationDegrees = 270;                          sourceRotation = VideoRotation.Clockwise270Degrees;                      }                      break;                    case DisplayOrientations.Landscape:                  default:                      rotationDegrees = 0;                      sourceRotation = VideoRotation.None;                      break;              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,CalculatePreviewRotation,The following statement contains a magic number: switch (displayInformation.CurrentOrientation)              {                  case DisplayOrientations.Portrait:                      if (mirroringPreview)                      {                          rotationDegrees = 270;                          sourceRotation = VideoRotation.Clockwise270Degrees;                      }                      else                      {                          rotationDegrees = 90;                          sourceRotation = VideoRotation.Clockwise90Degrees;                      }                      break;                    case DisplayOrientations.LandscapeFlipped:                      // No need to invert this rotation' as rotating 180 degrees is the same either way.                      rotationDegrees = 180;                      sourceRotation = VideoRotation.Clockwise180Degrees;                      break;                    case DisplayOrientations.PortraitFlipped:                      if (mirroringPreview)                      {                          rotationDegrees = 90;                          sourceRotation = VideoRotation.Clockwise90Degrees;                      }                      else                      {                          rotationDegrees = 270;                          sourceRotation = VideoRotation.Clockwise270Degrees;                      }                      break;                    case DisplayOrientations.Landscape:                  default:                      rotationDegrees = 0;                      sourceRotation = VideoRotation.None;                      break;              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,CalculatePreviewRotation,The following statement contains a magic number: switch (displayInformation.CurrentOrientation)              {                  case DisplayOrientations.Portrait:                      if (mirroringPreview)                      {                          rotationDegrees = 270;                          sourceRotation = VideoRotation.Clockwise270Degrees;                      }                      else                      {                          rotationDegrees = 90;                          sourceRotation = VideoRotation.Clockwise90Degrees;                      }                      break;                    case DisplayOrientations.LandscapeFlipped:                      // No need to invert this rotation' as rotating 180 degrees is the same either way.                      rotationDegrees = 180;                      sourceRotation = VideoRotation.Clockwise180Degrees;                      break;                    case DisplayOrientations.PortraitFlipped:                      if (mirroringPreview)                      {                          rotationDegrees = 90;                          sourceRotation = VideoRotation.Clockwise90Degrees;                      }                      else                      {                          rotationDegrees = 270;                          sourceRotation = VideoRotation.Clockwise270Degrees;                      }                      break;                    case DisplayOrientations.Landscape:                  default:                      rotationDegrees = 0;                      sourceRotation = VideoRotation.None;                      break;              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,CalculatePreviewRotation,The following statement contains a magic number: switch (displayInformation.CurrentOrientation)              {                  case DisplayOrientations.Portrait:                      if (mirroringPreview)                      {                          rotationDegrees = 270;                          sourceRotation = VideoRotation.Clockwise270Degrees;                      }                      else                      {                          rotationDegrees = 90;                          sourceRotation = VideoRotation.Clockwise90Degrees;                      }                      break;                    case DisplayOrientations.LandscapeFlipped:                      // No need to invert this rotation' as rotating 180 degrees is the same either way.                      rotationDegrees = 180;                      sourceRotation = VideoRotation.Clockwise180Degrees;                      break;                    case DisplayOrientations.PortraitFlipped:                      if (mirroringPreview)                      {                          rotationDegrees = 90;                          sourceRotation = VideoRotation.Clockwise90Degrees;                      }                      else                      {                          rotationDegrees = 270;                          sourceRotation = VideoRotation.Clockwise270Degrees;                      }                      break;                    case DisplayOrientations.Landscape:                  default:                      rotationDegrees = 0;                      sourceRotation = VideoRotation.None;                      break;              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,CalculatePreviewRotation,The following statement contains a magic number: switch (displayInformation.CurrentOrientation)              {                  case DisplayOrientations.Portrait:                      if (mirroringPreview)                      {                          rotationDegrees = 270;                          sourceRotation = VideoRotation.Clockwise270Degrees;                      }                      else                      {                          rotationDegrees = 90;                          sourceRotation = VideoRotation.Clockwise90Degrees;                      }                      break;                    case DisplayOrientations.LandscapeFlipped:                      // No need to invert this rotation' as rotating 180 degrees is the same either way.                      rotationDegrees = 180;                      sourceRotation = VideoRotation.Clockwise180Degrees;                      break;                    case DisplayOrientations.PortraitFlipped:                      if (mirroringPreview)                      {                          rotationDegrees = 90;                          sourceRotation = VideoRotation.Clockwise90Degrees;                      }                      else                      {                          rotationDegrees = 270;                          sourceRotation = VideoRotation.Clockwise270Degrees;                      }                      break;                    case DisplayOrientations.Landscape:                  default:                      rotationDegrees = 0;                      sourceRotation = VideoRotation.None;                      break;              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,ConvertUiTapToPreviewRect,The following statement contains a magic number: double left = tap.X - size.Width / 2' top = tap.Y - size.Height / 2;
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,ConvertUiTapToPreviewRect,The following statement contains a magic number: double left = tap.X - size.Width / 2' top = tap.Y - size.Height / 2;
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,GetPreviewStreamRectInControl,The following statement contains a magic number: if ((previewControl.ActualWidth / previewControl.ActualHeight > streamWidth / (double)streamHeight))              {                  var scale = previewControl.ActualHeight / streamHeight;                  var scaledWidth = streamWidth * scale;                    result.X = (previewControl.ActualWidth - scaledWidth) / 2.0;                  result.Width = scaledWidth;              }              else // Preview stream is "wider" than UI' so letterboxing will be on the top+bottom              {                  var scale = previewControl.ActualWidth / streamWidth;                  var scaledHeight = streamHeight * scale;                    result.Y = (previewControl.ActualHeight - scaledHeight) / 2.0;                  result.Height = scaledHeight;              }
Magic Number,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,GetPreviewStreamRectInControl,The following statement contains a magic number: if ((previewControl.ActualWidth / previewControl.ActualHeight > streamWidth / (double)streamHeight))              {                  var scale = previewControl.ActualHeight / streamHeight;                  var scaledWidth = streamWidth * scale;                    result.X = (previewControl.ActualWidth - scaledWidth) / 2.0;                  result.Width = scaledWidth;              }              else // Preview stream is "wider" than UI' so letterboxing will be on the top+bottom              {                  var scale = previewControl.ActualWidth / streamWidth;                  var scaledHeight = streamHeight * scale;                    result.Y = (previewControl.ActualHeight - scaledHeight) / 2.0;                  result.Height = scaledHeight;              }
Missing Default,ZXing.Mobile,ZXingScannerControl,C:\repos\Redth_ZXing.Net.Mobile\Source\ZXing.Net.Mobile.WindowsUniversal\ZXingScannerControl.xaml.cs,ConvertUiTapToPreviewRect,The following switch statement is missing a default case: switch (displayOrientation)              {                  case DisplayOrientations.Portrait:                      var tempLeft = left;                        left = top;                      top = previewRect.Width - tempLeft;                      break;                  case DisplayOrientations.LandscapeFlipped:                      left = previewRect.Width - left;                      top = previewRect.Height - top;                      break;                  case DisplayOrientations.PortraitFlipped:                      var tempTop = top;                        top = left;                      left = previewRect.Width - tempTop;                      break;              }
