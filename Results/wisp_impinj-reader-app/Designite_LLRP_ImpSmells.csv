Implementation smell,Namespace,Class,File,Method,Description
Long Method,LLRP,LLRPEndPoint,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPEndPoint.cs,TransactMessage,The method has 122 lines of code.
Long Method,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has 65 lines of code.
Long Method,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The method has 66 lines of code.
Long Method,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The method has 74 lines of code.
Long Method,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The method has 80 lines of code.
Long Method,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has 133 lines of code.
Long Method,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The method has 75 lines of code.
Long Method,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The method has 83 lines of code.
Long Method,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has 111 lines of code.
Long Method,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 95 lines of code.
Long Method,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The method has 97 lines of code.
Long Method,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 121 lines of code.
Long Method,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The method has 90 lines of code.
Long Method,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The method has 64 lines of code.
Long Method,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 65 lines of code.
Long Method,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 79 lines of code.
Long Method,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The method has 64 lines of code.
Long Method,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The method has 77 lines of code.
Long Method,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has 79 lines of code.
Long Method,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 108 lines of code.
Long Method,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The method has 86 lines of code.
Long Method,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 74 lines of code.
Long Method,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The method has 107 lines of code.
Long Method,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,The method has 62 lines of code.
Long Method,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has 202 lines of code.
Long Method,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The method has 61 lines of code.
Long Method,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 65 lines of code.
Long Method,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has 126 lines of code.
Long Method,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has 67 lines of code.
Long Method,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 113 lines of code.
Long Method,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The method has 85 lines of code.
Long Method,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 73 lines of code.
Long Method,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 65 lines of code.
Long Method,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 69 lines of code.
Long Method,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 65 lines of code.
Long Method,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has 69 lines of code.
Long Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,ProcesssMessage,The method has 266 lines of code.
Long Method,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The method has 92 lines of code.
Long Method,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The method has 78 lines of code.
Long Method,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The method has 66 lines of code.
Long Method,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The method has 118 lines of code.
Complex Method,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,LLRPEndPoint,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPEndPoint.cs,TransactMessage,Cyclomatic complexity of the method is 36
Complex Method,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,Cyclomatic complexity of the method is 7
Complex Method,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,Cyclomatic complexity of the method is 11
Complex Method,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,Cyclomatic complexity of the method is 23
Complex Method,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,Cyclomatic complexity of the method is 10
Complex Method,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,Cyclomatic complexity of the method is 10
Complex Method,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,Cyclomatic complexity of the method is 12
Complex Method,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,Cyclomatic complexity of the method is 7
Complex Method,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,Cyclomatic complexity of the method is 24
Complex Method,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,Cyclomatic complexity of the method is 29
Complex Method,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,Cyclomatic complexity of the method is 24
Complex Method,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,Cyclomatic complexity of the method is 51
Complex Method,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,Cyclomatic complexity of the method is 23
Complex Method,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,Cyclomatic complexity of the method is 30
Complex Method,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,Cyclomatic complexity of the method is 22
Complex Method,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,Cyclomatic complexity of the method is 42
Complex Method,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,Cyclomatic complexity of the method is 17
Complex Method,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,Cyclomatic complexity of the method is 17
Complex Method,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 25
Complex Method,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 29
Complex Method,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 17
Complex Method,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 19
Complex Method,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 27
Complex Method,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 17
Complex Method,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 14
Complex Method,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 15
Complex Method,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 12
Complex Method,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 17
Complex Method,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 21
Complex Method,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 12
Complex Method,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 15
Complex Method,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 14
Complex Method,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 16
Complex Method,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 19
Complex Method,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 15
Complex Method,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 29
Complex Method,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 38
Complex Method,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 25
Complex Method,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 18
Complex Method,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 14
Complex Method,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 24
Complex Method,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 38
Complex Method,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 25
Complex Method,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 88
Complex Method,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 14
Complex Method,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 17
Complex Method,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 15
Complex Method,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 19
Complex Method,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 14
Complex Method,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 18
Complex Method,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 49
Complex Method,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 14
Complex Method,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 24
Complex Method,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 25
Complex Method,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 16
Complex Method,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 15
Complex Method,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 17
Complex Method,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 11
Complex Method,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 13
Complex Method,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 10
Complex Method,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 7
Complex Method,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,Cyclomatic complexity of the method is 9
Complex Method,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,Cyclomatic complexity of the method is 8
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,ProcesssMessage,Cyclomatic complexity of the method is 237
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,CUSTOM_MESSAGE,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,GET_READER_CAPABILITIES,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,ADD_ROSPEC,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,DELETE_ROSPEC,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,START_ROSPEC,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,STOP_ROSPEC,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,ENABLE_ROSPEC,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,DISABLE_ROSPEC,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,GET_ROSPECS,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,ADD_ACCESSSPEC,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,DELETE_ACCESSSPEC,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,ENABLE_ACCESSSPEC,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,DISABLE_ACCESSSPEC,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,GET_ACCESSSPECS,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,GET_READER_CONFIG,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,SET_READER_CONFIG,Cyclomatic complexity of the method is 10
Complex Method,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,CLOSE_CONNECTION,Cyclomatic complexity of the method is 10
Complex Method,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,Cyclomatic complexity of the method is 10
Complex Method,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,Cyclomatic complexity of the method is 28
Complex Method,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,Cyclomatic complexity of the method is 51
Complex Method,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,CharToBinaryString,Cyclomatic complexity of the method is 24
Long Parameter List,LLRP,CommunicationInterface,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CommunicationInterface.cs,TriggerMessageEvent,The method has 4 parameters.
Long Parameter List,LLRP,RAW_Message,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPEndPoint.cs,RAW_Message,The method has 4 parameters.
Long Parameter List,LLRP,LLRPEndPoint,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPEndPoint.cs,triggerMessageReceived,The method has 4 parameters.
Long Parameter List,LLRP,LLRPEndPoint,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPEndPoint.cs,cI_OnMessageReceived,The method has 4 parameters.
Long Parameter List,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,ProcesssMessage,The method has 4 parameters.
Long Parameter List,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The method has 5 parameters.
Long Identifier,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the parameter _param_ReceiveSensitivityTableEntry is 35.
Long Identifier,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the parameter _param_PerAntennaReceiveSensitivityRange is 40.
Long Identifier,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the parameter _param_TransmitPowerLevelTableEntry is 35.
Long Identifier,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the parameter _param_C1G2BlockEraseOpSpecResult is 33.
Long Identifier,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the parameter _param_C1G2BlockWriteOpSpecResult is 33.
Long Identifier,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the parameter _param_FrequencyRSSILevelEntry is 30.
Long Identifier,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the parameter _param_C1G2UHFRFModeTableEntry is 30.
Long Statement,LLRP,LLRPEndPoint,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPEndPoint.cs,TransactMessage,The length of the statement  "				MSG_GET_READER_CAPABILITIES_RESPONSE r_msg = MSG_GET_READER_CAPABILITIES_RESPONSE.FromBitArray (ref bArr' ref cursor' length); " is 126.
Long Statement,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<CUSTOM_MESSAGE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 127.
Long Statement,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "	Util.ConvertBitArrayToObj (ref bit_array' ref cursor' out obj_val' typeof(ENUM_GetReaderCapabilitiesRequestedData)' field_len); " is 127.
Long Statement,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<GET_READER_CAPABILITIES" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 136.
Long Statement,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The length of the statement  "	msg.RequestedData = (ENUM_GetReaderCapabilitiesRequestedData)Enum.Parse (typeof(ENUM_GetReaderCapabilitiesRequestedData)' val); " is 127.
Long Statement,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "	PARAM_C1G2LLRPCapabilities _param_C1G2LLRPCapabilities = PARAM_C1G2LLRPCapabilities.FromBitArray (ref bit_array' ref cursor' length); " is 133.
Long Statement,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "	while ((_param_C1G2LLRPCapabilities = PARAM_C1G2LLRPCapabilities.FromBitArray (ref bit_array' ref cursor' length)) != null) { " is 125.
Long Statement,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<GET_READER_CAPABILITIES_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 145.
Long Statement,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<ADD_ROSPEC" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 123.
Long Statement,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<ADD_ROSPEC_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 132.
Long Statement,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<DELETE_ROSPEC" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 126.
Long Statement,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<DELETE_ROSPEC_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 135.
Long Statement,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<START_ROSPEC" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 125.
Long Statement,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<START_ROSPEC_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 134.
Long Statement,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<STOP_ROSPEC" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 124.
Long Statement,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<STOP_ROSPEC_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 133.
Long Statement,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<ENABLE_ROSPEC" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 126.
Long Statement,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<ENABLE_ROSPEC_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 135.
Long Statement,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<DISABLE_ROSPEC" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 127.
Long Statement,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<DISABLE_ROSPEC_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 136.
Long Statement,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<GET_ROSPECS" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 124.
Long Statement,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<GET_ROSPECS_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 133.
Long Statement,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<ADD_ACCESSSPEC" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 127.
Long Statement,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<ADD_ACCESSSPEC_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 136.
Long Statement,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<DELETE_ACCESSSPEC" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 130.
Long Statement,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<DELETE_ACCESSSPEC_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 139.
Long Statement,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<ENABLE_ACCESSSPEC" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 130.
Long Statement,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<ENABLE_ACCESSSPEC_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 139.
Long Statement,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<DISABLE_ACCESSSPEC" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 131.
Long Statement,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<DISABLE_ACCESSSPEC_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 140.
Long Statement,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<GET_ACCESSSPECS" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 128.
Long Statement,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<GET_ACCESSSPECS_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 137.
Long Statement,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "	Util.ConvertBitArrayToObj (ref bit_array' ref cursor' out obj_val' typeof(ENUM_GetReaderConfigRequestedData)' field_len); " is 121.
Long Statement,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<GET_READER_CONFIG" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 130.
Long Statement,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "	PARAM_AntennaProperties _param_AntennaProperties = PARAM_AntennaProperties.FromBitArray (ref bit_array' ref cursor' length); " is 124.
Long Statement,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "	PARAM_AntennaConfiguration _param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray (ref bit_array' ref cursor' length); " is 133.
Long Statement,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "		while ((_param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 123.
Long Statement,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "	PARAM_GPIPortCurrentState _param_GPIPortCurrentState = PARAM_GPIPortCurrentState.FromBitArray (ref bit_array' ref cursor' length); " is 130.
Long Statement,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "		while ((_param_GPIPortCurrentState = PARAM_GPIPortCurrentState.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 121.
Long Statement,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<GET_READER_CONFIG_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 139.
Long Statement,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "	PARAM_AntennaProperties _param_AntennaProperties = PARAM_AntennaProperties.FromBitArray (ref bit_array' ref cursor' length); " is 124.
Long Statement,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "	PARAM_AntennaConfiguration _param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray (ref bit_array' ref cursor' length); " is 133.
Long Statement,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "		while ((_param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 123.
Long Statement,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "	PARAM_GPIPortCurrentState _param_GPIPortCurrentState = PARAM_GPIPortCurrentState.FromBitArray (ref bit_array' ref cursor' length); " is 130.
Long Statement,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "		while ((_param_GPIPortCurrentState = PARAM_GPIPortCurrentState.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 121.
Long Statement,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<SET_READER_CONFIG" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 130.
Long Statement,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<SET_READER_CONFIG_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 139.
Long Statement,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<CLOSE_CONNECTION" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 129.
Long Statement,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<CLOSE_CONNECTION_RESPONSE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 138.
Long Statement,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<GET_REPORT" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 123.
Long Statement,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The length of the statement  "	PARAM_RFSurveyReportData _param_RFSurveyReportData = PARAM_RFSurveyReportData.FromBitArray (ref bit_array' ref cursor' length); " is 127.
Long Statement,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<RO_ACCESS_REPORT" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 129.
Long Statement,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<KEEPALIVE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 122.
Long Statement,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<KEEPALIVE_ACK" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 126.
Long Statement,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<READER_EVENT_NOTIFICATION" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 138.
Long Statement,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<ENABLE_EVENTS_AND_REPORTS" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 138.
Long Statement,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToString,The length of the statement  "	string xml_str = "<ERROR_MESSAGE" + " Version=\"" + version.ToString () + "\" MessageID=\"" + MSG_ID.ToString () + "\"" + ">"; " is 126.
Long Statement,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_ReceiveSensitivityTableEntry _param_ReceiveSensitivityTableEntry = PARAM_ReceiveSensitivityTableEntry.FromBitArray (ref bit_array' ref cursor' length); " is 157.
Long Statement,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_ReceiveSensitivityTableEntry = PARAM_ReceiveSensitivityTableEntry.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 139.
Long Statement,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_PerAntennaReceiveSensitivityRange _param_PerAntennaReceiveSensitivityRange = PARAM_PerAntennaReceiveSensitivityRange.FromBitArray (ref bit_array' ref cursor' length); " is 172.
Long Statement,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_PerAntennaReceiveSensitivityRange = PARAM_PerAntennaReceiveSensitivityRange.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 149.
Long Statement,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_PerAntennaAirProtocol _param_PerAntennaAirProtocol = PARAM_PerAntennaAirProtocol.FromBitArray (ref bit_array' ref cursor' length); " is 136.
Long Statement,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_PerAntennaAirProtocol = PARAM_PerAntennaAirProtocol.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 125.
Long Statement,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,The length of the statement  "		xml_str += "<MaxNumberOfAntennaSupported>" + MaxNumberOfAntennaSupported.ToString () + "</MaxNumberOfAntennaSupported>"; " is 120.
Long Statement,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The length of the statement  "			BitArray tempBitArr = Util.ConvertObjToBitArray (CanDoTagInventoryStateAwareSingulation' CanDoTagInventoryStateAwareSingulation_len); " is 133.
Long Statement,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The length of the statement  "			BitArray tempBitArr = Util.ConvertObjToBitArray (MaxNumInventoryParameterSpecsPerAISpec' MaxNumInventoryParameterSpecsPerAISpec_len); " is 133.
Long Statement,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,The length of the statement  "		xml_str += "<SupportsClientRequestOpSpec>" + SupportsClientRequestOpSpec.ToString () + "</SupportsClientRequestOpSpec>"; " is 120.
Long Statement,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,The length of the statement  "		xml_str += "<CanDoTagInventoryStateAwareSingulation>" + CanDoTagInventoryStateAwareSingulation.ToString () + "</CanDoTagInventoryStateAwareSingulation>"; " is 153.
Long Statement,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,The length of the statement  "		xml_str += "<SupportsEventAndReportHolding>" + SupportsEventAndReportHolding.ToString () + "</SupportsEventAndReportHolding>"; " is 126.
Long Statement,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,The length of the statement  "		xml_str += "<MaxNumPriorityLevelsSupported>" + MaxNumPriorityLevelsSupported.ToString () + "</MaxNumPriorityLevelsSupported>"; " is 126.
Long Statement,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,The length of the statement  "		xml_str += "<MaxNumInventoryParameterSpecsPerAISpec>" + MaxNumInventoryParameterSpecsPerAISpec.ToString () + "</MaxNumInventoryParameterSpecsPerAISpec>"; " is 153.
Long Statement,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_TransmitPowerLevelTableEntry _param_TransmitPowerLevelTableEntry = PARAM_TransmitPowerLevelTableEntry.FromBitArray (ref bit_array' ref cursor' length); " is 157.
Long Statement,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_TransmitPowerLevelTableEntry = PARAM_TransmitPowerLevelTableEntry.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 139.
Long Statement,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_C1G2UHFRFModeTable _param_C1G2UHFRFModeTable = PARAM_C1G2UHFRFModeTable.FromBitArray (ref bit_array' ref cursor' length); " is 127.
Long Statement,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_FrequencyHopTable _param_FrequencyHopTable = PARAM_FrequencyHopTable.FromBitArray (ref bit_array' ref cursor' length); " is 124.
Long Statement,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_InventoryParameterSpec _param_InventoryParameterSpec = PARAM_InventoryParameterSpec.FromBitArray (ref bit_array' ref cursor' length); " is 139.
Long Statement,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_InventoryParameterSpec = PARAM_InventoryParameterSpec.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 127.
Long Statement,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_AntennaConfiguration _param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray (ref bit_array' ref cursor' length); " is 133.
Long Statement,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 123.
Long Statement,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,The length of the statement  "		xml_str += "<LLRPConfigurationStateValue>" + LLRPConfigurationStateValue.ToString () + "</LLRPConfigurationStateValue>"; " is 120.
Long Statement,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_C1G2InventoryCommand _param_C1G2InventoryCommand = PARAM_C1G2InventoryCommand.FromBitArray (ref bit_array' ref cursor' length); " is 133.
Long Statement,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_C1G2InventoryCommand = PARAM_C1G2InventoryCommand.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 123.
Long Statement,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The length of the statement  "			BitArray tempBitArr = Util.ConvertObjToBitArray (HoldEventsAndReportsUponReconnect' HoldEventsAndReportsUponReconnect_len); " is 123.
Long Statement,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,The length of the statement  "		xml_str += "<HoldEventsAndReportsUponReconnect>" + HoldEventsAndReportsUponReconnect.ToString () + "</HoldEventsAndReportsUponReconnect>"; " is 138.
Long Statement,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_C1G2EPCMemorySelector _param_C1G2EPCMemorySelector = PARAM_C1G2EPCMemorySelector.FromBitArray (ref bit_array' ref cursor' length); " is 136.
Long Statement,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_C1G2EPCMemorySelector = PARAM_C1G2EPCMemorySelector.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 125.
Long Statement,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,The length of the statement  "		xml_str += "<EnableInventoryParameterSpecID>" + EnableInventoryParameterSpecID.ToString () + "</EnableInventoryParameterSpecID>"; " is 129.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_C1G2ReadOpSpecResult _param_C1G2ReadOpSpecResult = PARAM_C1G2ReadOpSpecResult.FromBitArray (ref bit_array' ref cursor' length); " is 133.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_C1G2ReadOpSpecResult = PARAM_C1G2ReadOpSpecResult.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 123.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_C1G2WriteOpSpecResult _param_C1G2WriteOpSpecResult = PARAM_C1G2WriteOpSpecResult.FromBitArray (ref bit_array' ref cursor' length); " is 136.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_C1G2WriteOpSpecResult = PARAM_C1G2WriteOpSpecResult.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 125.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_C1G2KillOpSpecResult _param_C1G2KillOpSpecResult = PARAM_C1G2KillOpSpecResult.FromBitArray (ref bit_array' ref cursor' length); " is 133.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_C1G2KillOpSpecResult = PARAM_C1G2KillOpSpecResult.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 123.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_C1G2LockOpSpecResult _param_C1G2LockOpSpecResult = PARAM_C1G2LockOpSpecResult.FromBitArray (ref bit_array' ref cursor' length); " is 133.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_C1G2LockOpSpecResult = PARAM_C1G2LockOpSpecResult.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 123.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_C1G2BlockEraseOpSpecResult _param_C1G2BlockEraseOpSpecResult = PARAM_C1G2BlockEraseOpSpecResult.FromBitArray (ref bit_array' ref cursor' length); " is 151.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_C1G2BlockEraseOpSpecResult = PARAM_C1G2BlockEraseOpSpecResult.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 135.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_C1G2BlockWriteOpSpecResult _param_C1G2BlockWriteOpSpecResult = PARAM_C1G2BlockWriteOpSpecResult.FromBitArray (ref bit_array' ref cursor' length); " is 151.
Long Statement,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_C1G2BlockWriteOpSpecResult = PARAM_C1G2BlockWriteOpSpecResult.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 135.
Long Statement,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_FrequencyRSSILevelEntry _param_FrequencyRSSILevelEntry = PARAM_FrequencyRSSILevelEntry.FromBitArray (ref bit_array' ref cursor' length); " is 142.
Long Statement,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_FrequencyRSSILevelEntry = PARAM_FrequencyRSSILevelEntry.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 129.
Long Statement,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_EventNotificationState _param_EventNotificationState = PARAM_EventNotificationState.FromBitArray (ref bit_array' ref cursor' length); " is 139.
Long Statement,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_EventNotificationState = PARAM_EventNotificationState.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 127.
Long Statement,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	param.ReportBufferLevelWarningEvent = PARAM_ReportBufferLevelWarningEvent.FromBitArray (ref bit_array' ref cursor' length); " is 123.
Long Statement,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	param.ReportBufferOverflowErrorEvent = PARAM_ReportBufferOverflowErrorEvent.FromBitArray (ref bit_array' ref cursor' length); " is 125.
Long Statement,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_C1G2SingulationDetails _param_C1G2SingulationDetails = PARAM_C1G2SingulationDetails.FromBitArray (ref bit_array' ref cursor' length); " is 139.
Long Statement,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_C1G2SingulationDetails = PARAM_C1G2SingulationDetails.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 127.
Long Statement,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToString,The length of the statement  "		xml_str += "<MaxNumSelectFiltersPerQuery>" + MaxNumSelectFiltersPerQuery.ToString () + "</MaxNumSelectFiltersPerQuery>"; " is 120.
Long Statement,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	PARAM_C1G2UHFRFModeTableEntry _param_C1G2UHFRFModeTableEntry = PARAM_C1G2UHFRFModeTableEntry.FromBitArray (ref bit_array' ref cursor' length); " is 142.
Long Statement,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "		while ((_param_C1G2UHFRFModeTableEntry = PARAM_C1G2UHFRFModeTableEntry.FromBitArray (ref bit_array' ref cursor' length)) != null) " is 129.
Long Statement,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	param.C1G2TagInventoryStateAwareFilterAction = PARAM_C1G2TagInventoryStateAwareFilterAction.FromBitArray (ref bit_array' ref cursor' length); " is 141.
Long Statement,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	param.C1G2TagInventoryStateUnawareFilterAction = PARAM_C1G2TagInventoryStateUnawareFilterAction.FromBitArray (ref bit_array' ref cursor' length); " is 145.
Long Statement,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The length of the statement  "	param.C1G2TagInventoryStateAwareSingulationAction = PARAM_C1G2TagInventoryStateAwareSingulationAction.FromBitArray (ref bit_array' ref cursor' length); " is 151.
Long Statement,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The length of the statement  "				param.C1G2TagInventoryStateAwareSingulationAction = PARAM_C1G2TagInventoryStateAwareSingulationAction.FromXmlNode (xnl [0]); " is 124.
Long Statement,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,GET_READER_CAPABILITIES,The length of the statement  "			MSG_GET_READER_CAPABILITIES_RESPONSE msg_rsp = MSG_GET_READER_CAPABILITIES_RESPONSE.FromBitArray (ref bArr' ref cursor' length); " is 128.
Long Statement,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The length of the statement  "						msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5]; " is 123.
Long Statement,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The length of the statement  "						msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9]; " is 122.
Long Statement,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The length of the statement  "			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5]; " is 123.
Long Statement,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The length of the statement  "			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9]; " is 122.
Long Statement,LLRP.DataType,U96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,ToString,The length of the statement  "	return string.Format ("{0:4X}{1:4X}{2:4X}{3:4X}{4:4X}{5:4X}"' data [0]' data [1]' data [2]' data [3]' data [4]' data [5]); " is 122.
Empty Catch Block,LLRP,CommunicationInterface,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CommunicationInterface.cs,TriggerMessageEvent,The method has an empty catch block.
Empty Catch Block,LLRP,CommunicationInterface,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CommunicationInterface.cs,TriggerOnClientConnect,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromXmlNode,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The method has an empty catch block.
Empty Catch Block,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,TriggerReaderEventNotification,The method has an empty catch block.
Empty Catch Block,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,TriggerRoAccessReport,The method has an empty catch block.
Empty Catch Block,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,TriggerKeepAlive,The method has an empty catch block.
Empty Catch Block,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,Open,The method has an empty catch block.
Empty Catch Block,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,ProcesssMessage,The method has an empty catch block.
Empty Catch Block,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,ProcesssMessage,The method has an empty catch block.
Empty Catch Block,LLRP,LLRPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPClient.cs,ProcesssMessage,The method has an empty catch block.
Empty Catch Block,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The method has an empty catch block.
Empty Catch Block,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The method has an empty catch block.
Empty Catch Block,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The method has an empty catch block.
Empty Catch Block,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,DoAcceptTCPClientCallBack,The method has an empty catch block.
Empty Catch Block,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The method has an empty catch block.
Empty Catch Block,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The method has an empty catch block.
Empty Catch Block,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The method has an empty catch block.
Empty Catch Block,LLRP.DataType,UInt16Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP.DataType,UInt32Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,FromString,The method has an empty catch block.
Empty Catch Block,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,SplitString,The method has an empty catch block.
Empty Catch Block,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The method has an empty catch block.
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,PARAM_Custom,The following statement contains a magic number: typeID = 1023;  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Data.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (Data' Data_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Data.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (Data' Data_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: if (obj.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != obj.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != obj.TypeID) {  		cursor -= 16;  		return null;  	}  	obj.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: if (obj.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != obj.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != obj.TypeID) {  		cursor -= 16;  		return null;  	}  	obj.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: if (obj.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != obj.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != obj.TypeID) {  		cursor -= 16;  		return null;  	}  	obj.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: if (obj.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != obj.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != obj.TypeID) {  		cursor -= 16;  		return null;  	}  	obj.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: if (obj.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != obj.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != obj.TypeID) {  		cursor -= 16;  		return null;  	}  	obj.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: if (param_type != obj.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: if (param_type != obj.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_Custom,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,FromBitArray,The following statement contains a magic number: field_len = (bit_array.Length - cursor) / 8;  
Magic Number,LLRP,CustomParamDecodeFactory,D:\newReposJune17\wisp_impinj-reader-app\LLRP\CustomParameter.cs,DecodeXmlNodeToCustomParameter,The following statement contains a magic number: if (temp.Length == 2)  	typeName = temp [1];  else  	typeName = temp [0];  
Magic Number,LLRP,LLRPEndPoint,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPEndPoint.cs,cI_OnMessageReceived,The following statement contains a magic number: if ((msg_type == 100) || (msg_type == this.msg_type && msg_id == this.msg_id)) {  	Array.Copy (msg_data' this.data' msg_data.Length);  	this.msg_type = msg_type;  	this.msg_id = msg_id;  	this.version = ver;  	transactEvt.Set ();  }  
Magic Number,LLRP,LLRPEndPoint,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPEndPoint.cs,TransactMessage,The following statement contains a magic number: try {  	transactEvt = new ManualResetEvent (false);  	Transaction.Send (cI' data);  	msg_id = (int)msg.MSG_ID;  	if (msg.MSG_TYPE != (uint)ENUM_LLRP_MSG_TYPE.CUSTOM_MESSAGE)  		msg_type = (short)(msg.MSG_TYPE + 10);  	else  		msg_type = (short)msg.MSG_TYPE;  	if (transactEvt.WaitOne (time_out' false)) {  		BitArray bArr;  		int length;  		int cursor = 0;  		switch ((ENUM_LLRP_MSG_TYPE)msg_type) {  		case ENUM_LLRP_MSG_TYPE.GET_READER_CAPABILITIES_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_GET_READER_CAPABILITIES_RESPONSE r_msg = MSG_GET_READER_CAPABILITIES_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.ADD_ROSPEC_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_ADD_ROSPEC_RESPONSE r_msg = MSG_ADD_ROSPEC_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.DELETE_ROSPEC_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_DELETE_ROSPEC_RESPONSE r_msg = MSG_DELETE_ROSPEC_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.START_ROSPEC_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_START_ROSPEC_RESPONSE r_msg = MSG_START_ROSPEC_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.STOP_ROSPEC_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_STOP_ROSPEC_RESPONSE r_msg = MSG_STOP_ROSPEC_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.ENABLE_ROSPEC_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_ENABLE_ROSPEC_RESPONSE r_msg = MSG_ENABLE_ROSPEC_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.DISABLE_ROSPEC_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_DISABLE_ROSPEC_RESPONSE r_msg = MSG_DISABLE_ROSPEC_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.GET_ROSPECS_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_GET_ROSPECS_RESPONSE r_msg = MSG_GET_ROSPECS_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.ADD_ACCESSSPEC_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_ADD_ACCESSSPEC_RESPONSE r_msg = MSG_ADD_ACCESSSPEC_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.DELETE_ACCESSSPEC_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_DELETE_ACCESSSPEC_RESPONSE r_msg = MSG_DELETE_ACCESSSPEC_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.ENABLE_ACCESSSPEC_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_ENABLE_ACCESSSPEC_RESPONSE r_msg = MSG_ENABLE_ACCESSSPEC_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.DISABLE_ACCESSSPEC_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_DISABLE_ACCESSSPEC_RESPONSE r_msg = MSG_DISABLE_ACCESSSPEC_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.GET_ACCESSSPECS_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_GET_ACCESSSPECS_RESPONSE r_msg = MSG_GET_ACCESSSPECS_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.GET_READER_CONFIG_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_GET_READER_CONFIG_RESPONSE r_msg = MSG_GET_READER_CONFIG_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.SET_READER_CONFIG_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_SET_READER_CONFIG_RESPONSE r_msg = MSG_SET_READER_CONFIG_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		case ENUM_LLRP_MSG_TYPE.CLOSE_CONNECTION_RESPONSE: {  			bArr = Util.ConvertByteArrayToBitArray (data);  			length = bArr.Count;  			MSG_CLOSE_CONNECTION_RESPONSE r_msg = MSG_CLOSE_CONNECTION_RESPONSE.FromBitArray (ref bArr' ref cursor' length);  			return r_msg;  		}  		default:  			return null;  		}  	} else {  		return null;  	}  } catch {  	throw new Exception ("Transaction Failed");  }  
Magic Number,LLRP,LLRPEndPoint,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPEndPoint.cs,TransactMessage,The following statement contains a magic number: if (msg.MSG_TYPE != (uint)ENUM_LLRP_MSG_TYPE.CUSTOM_MESSAGE)  	msg_type = (short)(msg.MSG_TYPE + 10);  else  	msg_type = (short)msg.MSG_TYPE;  
Magic Number,LLRP,LLRPEndPoint,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPEndPoint.cs,TransactMessage,The following statement contains a magic number: msg_type = (short)(msg.MSG_TYPE + 10);  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_CUSTOM_MESSAGE,The following statement contains a magic number: msgType = 1023;  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,MSG_CUSTOM_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = (bit_array.Length - cursor) / 8;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_GET_READER_CAPABILITIES_RESPONSE,The following statement contains a magic number: msgType = 11;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_READER_CAPABILITIES_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_ADD_ROSPEC,The following statement contains a magic number: msgType = 20;  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ADD_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_ADD_ROSPEC_RESPONSE,The following statement contains a magic number: msgType = 30;  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ADD_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_DELETE_ROSPEC,The following statement contains a magic number: msgType = 21;  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DELETE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_DELETE_ROSPEC_RESPONSE,The following statement contains a magic number: msgType = 31;  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DELETE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_START_ROSPEC,The following statement contains a magic number: msgType = 22;  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_START_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_START_ROSPEC_RESPONSE,The following statement contains a magic number: msgType = 32;  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_START_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_STOP_ROSPEC,The following statement contains a magic number: msgType = 23;  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_STOP_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_STOP_ROSPEC_RESPONSE,The following statement contains a magic number: msgType = 33;  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_STOP_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_ENABLE_ROSPEC,The following statement contains a magic number: msgType = 24;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_ENABLE_ROSPEC_RESPONSE,The following statement contains a magic number: msgType = 34;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ENABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_DISABLE_ROSPEC,The following statement contains a magic number: msgType = 25;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_DISABLE_ROSPEC_RESPONSE,The following statement contains a magic number: msgType = 35;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DISABLE_ROSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_GET_ROSPECS,The following statement contains a magic number: msgType = 26;  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_ROSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_GET_ROSPECS_RESPONSE,The following statement contains a magic number: msgType = 36;  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_ROSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_ADD_ACCESSSPEC,The following statement contains a magic number: msgType = 40;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_ADD_ACCESSSPEC_RESPONSE,The following statement contains a magic number: msgType = 50;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ADD_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_DELETE_ACCESSSPEC,The following statement contains a magic number: msgType = 41;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_DELETE_ACCESSSPEC_RESPONSE,The following statement contains a magic number: msgType = 51;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DELETE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_ENABLE_ACCESSSPEC,The following statement contains a magic number: msgType = 42;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_ENABLE_ACCESSSPEC_RESPONSE,The following statement contains a magic number: msgType = 52;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ENABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_DISABLE_ACCESSSPEC,The following statement contains a magic number: msgType = 43;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_DISABLE_ACCESSSPEC_RESPONSE,The following statement contains a magic number: msgType = 53;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_DISABLE_ACCESSSPEC_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_GET_ACCESSSPECS,The following statement contains a magic number: msgType = 44;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_GET_ACCESSSPECS_RESPONSE,The following statement contains a magic number: msgType = 54;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_ACCESSSPECS_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_GET_READER_CONFIG,The following statement contains a magic number: msgType = 2;  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,MSG_GET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_GET_READER_CONFIG_RESPONSE,The following statement contains a magic number: msgType = 12;  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_SET_READER_CONFIG,The following statement contains a magic number: msgType = 3;  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_SET_READER_CONFIG,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_SET_READER_CONFIG_RESPONSE,The following statement contains a magic number: msgType = 13;  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_SET_READER_CONFIG_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_CLOSE_CONNECTION,The following statement contains a magic number: msgType = 14;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_CLOSE_CONNECTION_RESPONSE,The following statement contains a magic number: msgType = 4;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_CLOSE_CONNECTION_RESPONSE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_GET_REPORT,The following statement contains a magic number: msgType = 60;  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_GET_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_RO_ACCESS_REPORT,The following statement contains a magic number: msgType = 61;  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_RO_ACCESS_REPORT,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_KEEPALIVE,The following statement contains a magic number: msgType = 62;  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_KEEPALIVE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_KEEPALIVE_ACK,The following statement contains a magic number: msgType = 72;  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_KEEPALIVE_ACK,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_READER_EVENT_NOTIFICATION,The following statement contains a magic number: msgType = 63;  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_READER_EVENT_NOTIFICATION,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_ENABLE_EVENTS_AND_REPORTS,The following statement contains a magic number: msgType = 64;  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ENABLE_EVENTS_AND_REPORTS,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,MSG_ERROR_MESSAGE,The following statement contains a magic number: msgType = 100;  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 3;  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgType' 10);  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgLen' 32);  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msgID' 32);  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: cursor += 32;  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (msg_len' 32);  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' 16);  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: msg_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: if (msg_type != obj.msgType) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgLen = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,MSG_ERROR_MESSAGE,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPMsg.cs,FromBitArray,The following statement contains a magic number: obj.msgID = (UInt32)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_UTCTimestamp,The following statement contains a magic number: typeID = 128;  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_UTCTimestamp,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 64;  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_Uptime,The following statement contains a magic number: typeID = 129;  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_Uptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 64;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_GeneralDeviceCapabilities,The following statement contains a magic number: typeID = 137;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (ReaderFirmwareVersion != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReaderFirmwareVersion.Length)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (ReaderFirmwareVersion' ReaderFirmwareVersion_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (ReaderFirmwareVersion != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReaderFirmwareVersion.Length)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (ReaderFirmwareVersion' ReaderFirmwareVersion_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReaderFirmwareVersion.Length)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (ReaderFirmwareVersion' ReaderFirmwareVersion_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReaderFirmwareVersion.Length)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (ReaderFirmwareVersion' ReaderFirmwareVersion_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_GeneralDeviceCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ReceiveSensitivityTableEntry,The following statement contains a magic number: typeID = 139;  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_ReceiveSensitivityTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_PerAntennaReceiveSensitivityRange,The following statement contains a magic number: typeID = 149;  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_PerAntennaReceiveSensitivityRange,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_PerAntennaAirProtocol,The following statement contains a magic number: typeID = 140;  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (ProtocolID != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ProtocolID.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (ProtocolID' ProtocolID_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (ProtocolID != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ProtocolID.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (ProtocolID' ProtocolID_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ProtocolID.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (ProtocolID' ProtocolID_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ProtocolID.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (ProtocolID' ProtocolID_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_PerAntennaAirProtocol,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_GPIOCapabilities,The following statement contains a magic number: typeID = 141;  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_GPIOCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_LLRPCapabilities,The following statement contains a magic number: typeID = 142;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_RegulatoryCapabilities,The following statement contains a magic number: typeID = 143;  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_RegulatoryCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_UHFBandCapabilities,The following statement contains a magic number: typeID = 144;  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_UHFBandCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_TransmitPowerLevelTableEntry,The following statement contains a magic number: typeID = 145;  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_TransmitPowerLevelTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_FrequencyInformation,The following statement contains a magic number: typeID = 146;  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_FrequencyInformation,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_FrequencyHopTable,The following statement contains a magic number: typeID = 147;  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (Frequency != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Frequency.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (Frequency' Frequency_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (Frequency != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Frequency.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (Frequency' Frequency_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Frequency.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (Frequency' Frequency_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Frequency.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (Frequency' Frequency_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_FrequencyHopTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_FixedFrequencyTable,The following statement contains a magic number: typeID = 148;  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (Frequency != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Frequency.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (Frequency' Frequency_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (Frequency != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Frequency.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (Frequency' Frequency_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Frequency.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (Frequency' Frequency_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Frequency.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (Frequency' Frequency_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_FixedFrequencyTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ROSpec,The following statement contains a magic number: typeID = 177;  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_ROSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ROBoundarySpec,The following statement contains a magic number: typeID = 178;  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ROBoundarySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ROSpecStartTrigger,The following statement contains a magic number: typeID = 179;  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ROSpecStartTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_PeriodicTriggerValue,The following statement contains a magic number: typeID = 180;  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_PeriodicTriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_GPITriggerValue,The following statement contains a magic number: typeID = 181;  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_GPITriggerValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ROSpecStopTrigger,The following statement contains a magic number: typeID = 182;  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_ROSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_AISpec,The following statement contains a magic number: typeID = 183;  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (AntennaIDs != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(AntennaIDs.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (AntennaIDs' AntennaIDs_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (AntennaIDs != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(AntennaIDs.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (AntennaIDs' AntennaIDs_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(AntennaIDs.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (AntennaIDs' AntennaIDs_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(AntennaIDs.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (AntennaIDs' AntennaIDs_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AISpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_AISpecStopTrigger,The following statement contains a magic number: typeID = 184;  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_AISpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_TagObservationTrigger,The following statement contains a magic number: typeID = 185;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_TagObservationTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_InventoryParameterSpec,The following statement contains a magic number: typeID = 186;  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_InventoryParameterSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_RFSurveySpec,The following statement contains a magic number: typeID = 187;  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_RFSurveySpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_RFSurveySpecStopTrigger,The following statement contains a magic number: typeID = 188;  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_RFSurveySpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_AccessSpec,The following statement contains a magic number: typeID = 207;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_AccessSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_AccessSpecStopTrigger,The following statement contains a magic number: typeID = 208;  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_AccessSpecStopTrigger,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_AccessCommand,The following statement contains a magic number: typeID = 209;  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AccessCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_LLRPConfigurationStateValue,The following statement contains a magic number: typeID = 217;  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_LLRPConfigurationStateValue,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_Identification,The following statement contains a magic number: typeID = 218;  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (ReaderID != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReaderID.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (ReaderID' ReaderID_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (ReaderID != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReaderID.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (ReaderID' ReaderID_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReaderID.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (ReaderID' ReaderID_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReaderID.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (ReaderID' ReaderID_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_Identification,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_GPOWriteData,The following statement contains a magic number: typeID = 219;  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_GPOWriteData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_KeepaliveSpec,The following statement contains a magic number: typeID = 220;  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_KeepaliveSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_AntennaProperties,The following statement contains a magic number: typeID = 221;  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_AntennaProperties,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_AntennaConfiguration,The following statement contains a magic number: typeID = 222;  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AntennaConfiguration,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_RFReceiver,The following statement contains a magic number: typeID = 223;  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_RFReceiver,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_RFTransmitter,The following statement contains a magic number: typeID = 224;  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_RFTransmitter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_GPIPortCurrentState,The following statement contains a magic number: typeID = 225;  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_GPIPortCurrentState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_EventsAndReports,The following statement contains a magic number: typeID = 226;  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_EventsAndReports,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ROReportSpec,The following statement contains a magic number: typeID = 237;  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_ROReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_TagReportContentSelector,The following statement contains a magic number: typeID = 238;  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_TagReportContentSelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_AccessReportSpec,The following statement contains a magic number: typeID = 239;  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AccessReportSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_TagReportData,The following statement contains a magic number: typeID = 240;  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_TagReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_EPCData,The following statement contains a magic number: typeID = 241;  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (EPC != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(EPC.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (EPC' EPC_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (EPC != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(EPC.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (EPC' EPC_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(EPC.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (EPC' EPC_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(EPC.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (EPC' EPC_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_EPCData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_EPC_96,The following statement contains a magic number: typeID = 13;  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (EPC != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(EPC.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (EPC' EPC_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (EPC != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(EPC.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (EPC' EPC_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(EPC.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (EPC' EPC_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(EPC.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (EPC' EPC_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_EPC_96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 96;  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ROSpecID,The following statement contains a magic number: typeID = 9;  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ROSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_SpecIndex,The following statement contains a magic number: typeID = 14;  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_SpecIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_InventoryParameterSpecID,The following statement contains a magic number: typeID = 10;  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_InventoryParameterSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AntennaID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_PeakRSSI,The following statement contains a magic number: typeID = 6;  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_PeakRSSI,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ChannelIndex,The following statement contains a magic number: typeID = 7;  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ChannelIndex,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_FirstSeenTimestampUTC,The following statement contains a magic number: typeID = 2;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 64;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_FirstSeenTimestampUptime,The following statement contains a magic number: typeID = 3;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_FirstSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 64;  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_LastSeenTimestampUTC,The following statement contains a magic number: typeID = 4;  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_LastSeenTimestampUTC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 64;  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_LastSeenTimestampUptime,The following statement contains a magic number: typeID = 5;  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_LastSeenTimestampUptime,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 64;  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_TagSeenCount,The following statement contains a magic number: typeID = 8;  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_TagSeenCount,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_AccessSpecID,The following statement contains a magic number: typeID = 16;  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AccessSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_RFSurveyReportData,The following statement contains a magic number: typeID = 242;  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_RFSurveyReportData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_FrequencyRSSILevelEntry,The following statement contains a magic number: typeID = 243;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_FrequencyRSSILevelEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ReaderEventNotificationSpec,The following statement contains a magic number: typeID = 244;  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_EventNotificationState,The following statement contains a magic number: typeID = 245;  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_EventNotificationState,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ReaderEventNotificationData,The following statement contains a magic number: typeID = 246;  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ReaderEventNotificationData,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_HoppingEvent,The following statement contains a magic number: typeID = 247;  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_HoppingEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_GPIEvent,The following statement contains a magic number: typeID = 248;  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_GPIEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ROSpecEvent,The following statement contains a magic number: typeID = 249;  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_ROSpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ReportBufferLevelWarningEvent,The following statement contains a magic number: typeID = 250;  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ReportBufferLevelWarningEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ReportBufferOverflowErrorEvent,The following statement contains a magic number: typeID = 251;  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ReportBufferOverflowErrorEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ReaderExceptionEvent,The following statement contains a magic number: typeID = 252;  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (Message != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Message.Length)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (Message' Message_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (Message != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Message.Length)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (Message' Message_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Message.Length)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (Message' Message_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(Message.Length)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (Message' Message_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ReaderExceptionEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_OpSpecID,The following statement contains a magic number: typeID = 17;  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_OpSpecID,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_RFSurveyEvent,The following statement contains a magic number: typeID = 253;  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_RFSurveyEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_AISpecEvent,The following statement contains a magic number: typeID = 254;  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_AISpecEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_AntennaEvent,The following statement contains a magic number: typeID = 255;  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_AntennaEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ConnectionAttemptEvent,The following statement contains a magic number: typeID = 256;  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ConnectionAttemptEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ConnectionCloseEvent,The following statement contains a magic number: typeID = 257;  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ConnectionCloseEvent,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_LLRPStatus,The following statement contains a magic number: typeID = 287;  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (ErrorDescription != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ErrorDescription.Length)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (ErrorDescription' ErrorDescription_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (ErrorDescription != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ErrorDescription.Length)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (ErrorDescription' ErrorDescription_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ErrorDescription.Length)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (ErrorDescription' ErrorDescription_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ErrorDescription.Length)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (ErrorDescription' ErrorDescription_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_LLRPStatus,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_FieldError,The following statement contains a magic number: typeID = 288;  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_FieldError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_ParameterError,The following statement contains a magic number: typeID = 289;  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_ParameterError,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2LLRPCapabilities,The following statement contains a magic number: typeID = 327;  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2LLRPCapabilities,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2UHFRFModeTable,The following statement contains a magic number: typeID = 328;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTable,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2UHFRFModeTableEntry,The following statement contains a magic number: typeID = 329;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2UHFRFModeTableEntry,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2InventoryCommand,The following statement contains a magic number: typeID = 330;  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2InventoryCommand,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2Filter,The following statement contains a magic number: typeID = 331;  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2Filter,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 2;  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2TagInventoryMask,The following statement contains a magic number: typeID = 332;  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (TagMask != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagMask.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (TagMask' TagMask_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (TagMask != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagMask.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (TagMask' TagMask_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagMask.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (TagMask' TagMask_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagMask.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (TagMask' TagMask_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 2;  
Magic Number,LLRP,PARAM_C1G2TagInventoryMask,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2TagInventoryStateAwareFilterAction,The following statement contains a magic number: typeID = 333;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2TagInventoryStateUnawareFilterAction,The following statement contains a magic number: typeID = 334;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateUnawareFilterAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2RFControl,The following statement contains a magic number: typeID = 335;  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2RFControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2SingulationControl,The following statement contains a magic number: typeID = 336;  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 2;  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2SingulationControl,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2TagInventoryStateAwareSingulationAction,The following statement contains a magic number: typeID = 337;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TagInventoryStateAwareSingulationAction,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2TagSpec,The following statement contains a magic number: typeID = 338;  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TagSpec,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2TargetTag,The following statement contains a magic number: typeID = 339;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (TagMask != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagMask.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (TagMask' TagMask_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (TagMask != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagMask.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (TagMask' TagMask_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagMask.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (TagMask' TagMask_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagMask.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (TagMask' TagMask_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (TagData != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagData.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (TagData' TagData_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (TagData != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagData.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (TagData' TagData_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagData.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (TagData' TagData_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(TagData.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (TagData' TagData_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 2;  
Magic Number,LLRP,PARAM_C1G2TargetTag,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2Read,The following statement contains a magic number: typeID = 341;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 2;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2Read,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2Write,The following statement contains a magic number: typeID = 342;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (WriteData != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(WriteData.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (WriteData' WriteData_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (WriteData != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(WriteData.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (WriteData' WriteData_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(WriteData.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (WriteData' WriteData_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(WriteData.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (WriteData' WriteData_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 2;  
Magic Number,LLRP,PARAM_C1G2Write,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2Kill,The following statement contains a magic number: typeID = 343;  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2Kill,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2Lock,The following statement contains a magic number: typeID = 344;  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2Lock,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2LockPayload,The following statement contains a magic number: typeID = 345;  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2LockPayload,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2BlockErase,The following statement contains a magic number: typeID = 346;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 2;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2BlockErase,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2BlockWrite,The following statement contains a magic number: typeID = 347;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (WriteData != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(WriteData.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (WriteData' WriteData_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (WriteData != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(WriteData.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (WriteData' WriteData_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(WriteData.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (WriteData' WriteData_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(WriteData.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (WriteData' WriteData_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 32;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 2;  
Magic Number,LLRP,PARAM_C1G2BlockWrite,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2EPCMemorySelector,The following statement contains a magic number: typeID = 348;  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2EPCMemorySelector,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2_PC,The following statement contains a magic number: typeID = 12;  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2_PC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2_CRC,The following statement contains a magic number: typeID = 11;  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2_CRC,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2SingulationDetails,The following statement contains a magic number: typeID = 18;  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2SingulationDetails,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2ReadOpSpecResult,The following statement contains a magic number: typeID = 349;  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (ReadData != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReadData.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (ReadData' ReadData_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (ReadData != null) {  	try {  		int temp_cursor = cursor;  		BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReadData.Count)' 16);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += 16;  		tempBitArr = Util.ConvertObjToBitArray (ReadData' ReadData_len);  		tempBitArr.CopyTo (bit_array' cursor);  		cursor += tempBitArr.Length;  	} catch {  	}  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReadData.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (ReadData' ReadData_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: try {  	int temp_cursor = cursor;  	BitArray tempBitArr = Util.ConvertIntToBitArray ((UInt32)(ReadData.Count)' 16);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += 16;  	tempBitArr = Util.ConvertObjToBitArray (ReadData' ReadData_len);  	tempBitArr.CopyTo (bit_array' cursor);  	cursor += tempBitArr.Length;  } catch {  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2ReadOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2WriteOpSpecResult,The following statement contains a magic number: typeID = 350;  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2WriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2KillOpSpecResult,The following statement contains a magic number: typeID = 351;  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2KillOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2LockOpSpecResult,The following statement contains a magic number: typeID = 352;  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2LockOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2BlockEraseOpSpecResult,The following statement contains a magic number: typeID = 353;  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2BlockEraseOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,PARAM_C1G2BlockWriteOpSpecResult,The following statement contains a magic number: typeID = 354;  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (tvCoding) {  	bit_array [cursor] = true;  	cursor++;  	bArr = Util.ConvertIntToBitArray (typeID' 7);  	bArr.CopyTo (bit_array' cursor);  	cursor += 7;  } else {  	cursor += 6;  	bArr = Util.ConvertIntToBitArray (typeID' 10);  	bArr.CopyTo (bit_array' cursor);  	cursor += 10;  	cursor += 16;  	//Omit the parameter length' will be added at the end.  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 7);  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 7;  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (typeID' 10);  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 10;  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: cursor += 16;  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: if (!tvCoding) {  	UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;  	bArr = Util.ConvertIntToBitArray (param_len' 16);  	bArr.CopyTo (bit_array' cursor_old + 16);  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr = Util.ConvertIntToBitArray (param_len' 16);  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,ToBitArray,The following statement contains a magic number: bArr.CopyTo (bit_array' cursor_old + 16);  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param.tvCoding) {  	cursor++;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  	if (param_type != param.TypeID) {  		cursor -= 8;  		return null;  	}  } else {  	cursor += 6;  	param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  	if (param_type != param.TypeID) {  		cursor -= 16;  		return null;  	}  	param.length = (UInt16)(int)Util.DetermineFieldLength (ref bit_array' ref cursor);  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 7);  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 8;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 8;  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor += 6;  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: param_type = (int)(UInt64)Util.CalculateVal (ref bit_array' ref cursor' 10);  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: if (param_type != param.TypeID) {  	cursor -= 16;  	return null;  }  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: cursor -= 16;  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 8;  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,PARAM_C1G2BlockWriteOpSpecResult,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPParam.cs,FromBitArray,The following statement contains a magic number: field_len = 16;  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: lock (syn_msg) {  	try {  		REPEAT:  		if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  		 {  			msg_cursor = 0;  			int reserved_date_len = ss.data.Length - offset;  			if (reserved_date_len > 10) {  				//Calculate message type' version' length and id  				int header = (ss.data [offset] << 8) + ss.data [offset + 1];  				try {  					msg_type = (Int16)(header & 0x03FF);  					msg_ver = (Int16)((header >> 10) & 0x07);  					msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  					msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  				} catch {  					msg_len = 0;  				}  				if (msg_len > 20000) {  					int i = 0;  				}  				//if data length larger than needed data for a complete message'   				//copy data into existing message and triggered message event   				if (msg_len > 0 && msg_ver == 1) {  					msg_data = new byte[msg_len];  					//if message length greater than the calcualted message length. copy message and trigger message event  					if (ss.data.Length >= (offset + msg_len)) {  						Array.Copy (ss.data' offset' msg_data' 0' msg_len);  						delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  						msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  						offset += msg_len;  						new_message = true;  						goto REPEAT;  					} else//If the received data is shorter than the message length' keep reading for the next data   					 {  						new_message = false;  						Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  						msg_cursor = ss.data.Length - offset;  					}  				}  			} else {  				new_message = true;  				//if ns !=null' do next asyn-read' to ensure that read  				if (ns != null && ns.CanRead) {  					try {  						ns.Flush ();  						state = new AsynReadState (BUFFER_SIZE);  						Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  						if (!trying_to_close)  							ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  					} catch {  					}  				}  				return;  			}  		} else {  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (ss.data.Length >= msg_len - msg_cursor) {  				Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len - msg_cursor;  				new_message = true;  				goto REPEAT;  			} else//keep reading  			 {  				new_message = false;  				Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  				msg_cursor += ss.data.Length;  			}  		}  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				if (!trying_to_close)  					ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  	} catch {  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		msg_cursor = 0;  		int reserved_date_len = ss.data.Length - offset;  		if (reserved_date_len > 10) {  			//Calculate message type' version' length and id  			int header = (ss.data [offset] << 8) + ss.data [offset + 1];  			try {  				msg_type = (Int16)(header & 0x03FF);  				msg_ver = (Int16)((header >> 10) & 0x07);  				msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  				msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  			} catch {  				msg_len = 0;  			}  			if (msg_len > 20000) {  				int i = 0;  			}  			//if data length larger than needed data for a complete message'   			//copy data into existing message and triggered message event   			if (msg_len > 0 && msg_ver == 1) {  				msg_data = new byte[msg_len];  				//if message length greater than the calcualted message length. copy message and trigger message event  				if (ss.data.Length >= (offset + msg_len)) {  					Array.Copy (ss.data' offset' msg_data' 0' msg_len);  					delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  					msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  					offset += msg_len;  					new_message = true;  					goto REPEAT;  				} else//If the received data is shorter than the message length' keep reading for the next data   				 {  					new_message = false;  					Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  					msg_cursor = ss.data.Length - offset;  				}  			}  		} else {  			new_message = true;  			//if ns !=null' do next asyn-read' to ensure that read  			if (ns != null && ns.CanRead) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  					if (!trying_to_close)  						ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  			}  			return;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			if (!trying_to_close)  				ns.BeginRead (state.data' 0' BUFFER_SIZE' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	msg_cursor = 0;  	int reserved_date_len = ss.data.Length - offset;  	if (reserved_date_len > 10) {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		try {  			msg_type = (Int16)(header & 0x03FF);  			msg_ver = (Int16)((header >> 10) & 0x07);  			msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  			msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		} catch {  			msg_len = 0;  		}  		if (msg_len > 20000) {  			int i = 0;  		}  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (msg_len > 0 && msg_ver == 1) {  			msg_data = new byte[msg_len];  			//if message length greater than the calcualted message length. copy message and trigger message event  			if (ss.data.Length >= (offset + msg_len)) {  				Array.Copy (ss.data' offset' msg_data' 0' msg_len);  				delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  				msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  				offset += msg_len;  				new_message = true;  				goto REPEAT;  			} else//If the received data is shorter than the message length' keep reading for the next data   			 {  				new_message = false;  				Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  				msg_cursor = ss.data.Length - offset;  			}  		}  	} else {  		new_message = true;  		//if ns !=null' do next asyn-read' to ensure that read  		if (ns != null && ns.CanRead) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  				if (!trying_to_close)  					ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  		}  		return;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (reserved_date_len > 10) {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	try {  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	} catch {  		msg_len = 0;  	}  	if (msg_len > 20000) {  		int i = 0;  	}  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (msg_len > 0 && msg_ver == 1) {  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= (offset + msg_len)) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			new_message = true;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' offset' msg_data' 0' ss.data.Length - offset);  			msg_cursor = ss.data.Length - offset;  		}  	}  } else {  	new_message = true;  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			Array.Copy (ss.data' offset' state.data' 0' reserved_date_len);  			if (!trying_to_close)  				ns.BeginRead (state.data' reserved_date_len' BUFFER_SIZE - reserved_date_len' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  	return;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  } catch {  	msg_len = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_ver = (Int16)((header >> 10) & 0x07);  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (msg_len > 20000) {  	int i = 0;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,Receive,The following statement contains a magic number: try {  	ns.ReadTimeout = 200;  	byte[] buf = new byte[8096];  	int readSize = ns.Read (buf' 0' 8096);  	buffer = new byte[readSize];  	Array.Copy (buf' 0' buffer' 0' readSize);  	return readSize;  } catch {  	buffer = null;  	return -1;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,Receive,The following statement contains a magic number: try {  	ns.ReadTimeout = 200;  	byte[] buf = new byte[8096];  	int readSize = ns.Read (buf' 0' 8096);  	buffer = new byte[readSize];  	Array.Copy (buf' 0' buffer' 0' readSize);  	return readSize;  } catch {  	buffer = null;  	return -1;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,Receive,The following statement contains a magic number: try {  	ns.ReadTimeout = 200;  	byte[] buf = new byte[8096];  	int readSize = ns.Read (buf' 0' 8096);  	buffer = new byte[readSize];  	Array.Copy (buf' 0' buffer' 0' readSize);  	return readSize;  } catch {  	buffer = null;  	return -1;  }  
Magic Number,LLRP,TCPIPClient,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,Receive,The following statement contains a magic number: ns.ReadTimeout = 200;  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,Open,The following statement contains a magic number: try {  	IPAddress ipAddr = new IPAddress (new byte[] {  		127'  		0'  		0'  		1  	});  	server = new TcpListener (ipAddr' port);  	server.Start ();  	server.BeginAcceptTcpClient (new AsyncCallback (DoAcceptTCPClientCallBack)' server);  } catch {  	return false;  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,Receive,The following statement contains a magic number: try {  	ns.ReadTimeout = 200;  	byte[] buf = new byte[8096];  	int readSize = ns.Read (buf' 0' 8096);  	buffer = new byte[readSize];  	Array.Copy (buf' 0' buffer' 0' readSize);  	return readSize;  } catch {  	buffer = null;  	return -1;  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,Receive,The following statement contains a magic number: try {  	ns.ReadTimeout = 200;  	byte[] buf = new byte[8096];  	int readSize = ns.Read (buf' 0' 8096);  	buffer = new byte[readSize];  	Array.Copy (buf' 0' buffer' 0' readSize);  	return readSize;  } catch {  	buffer = null;  	return -1;  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,Receive,The following statement contains a magic number: try {  	ns.ReadTimeout = 200;  	byte[] buf = new byte[8096];  	int readSize = ns.Read (buf' 0' 8096);  	buffer = new byte[readSize];  	Array.Copy (buf' 0' buffer' 0' readSize);  	return readSize;  } catch {  	buffer = null;  	return -1;  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,Receive,The following statement contains a magic number: ns.ReadTimeout = 200;  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: try {  	REPEAT:  	//if multiple messages exist in the result. repeat the process  	if (new_message)//new_message is a flag to indicate if the data is part of unfinished message  	 {  		//Calculate message type' version' length and id  		int header = (ss.data [offset] << 8) + ss.data [offset + 1];  		msg_type = (Int16)(header & 0x03FF);  		msg_ver = (Int16)((header >> 10) & 0x07);  		msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  		msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  		//if the message length is 0. the rest of byte array are empty. restart non-block reading  		if (msg_len == 0) {  			if (ns != null) {  				try {  					ns.Flush ();  					state = new AsynReadState (BUFFER_SIZE);  					ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  				} catch {  				}  				return;  			} else  				return;  		}  		msg_data = new byte[msg_len];  		//if message length greater than the calcualted message length. copy message and trigger message event  		if (ss.data.Length >= msg_len) {  			Array.Copy (ss.data' offset' msg_data' 0' msg_len);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len;  			msg_len = 0;  			goto REPEAT;  		} else//If the received data is shorter than the message length' keep reading for the next data   		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	} else {  		//if data length larger than needed data for a complete message'   		//copy data into existing message and triggered message event   		if (ss.data.Length >= msg_len - msg_cursor) {  			Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  			delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  			msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  			offset += msg_len - msg_cursor;  			msg_len = 0;  			msg_cursor = 0;  			new_message = true;  			goto REPEAT;  		} else//keep reading  		 {  			new_message = false;  			Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  			msg_cursor += ss.data.Length;  		}  	}  	//if ns !=null' do next asyn-read' to ensure that read  	if (ns != null && ns.CanRead) {  		try {  			ns.Flush ();  			state = new AsynReadState (BUFFER_SIZE);  			ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  		} catch {  		}  	}  } catch {  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: if (new_message)//new_message is a flag to indicate if the data is part of unfinished message   {  	//Calculate message type' version' length and id  	int header = (ss.data [offset] << 8) + ss.data [offset + 1];  	msg_type = (Int16)(header & 0x03FF);  	msg_ver = (Int16)((header >> 10) & 0x07);  	msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  	msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  	//if the message length is 0. the rest of byte array are empty. restart non-block reading  	if (msg_len == 0) {  		if (ns != null) {  			try {  				ns.Flush ();  				state = new AsynReadState (BUFFER_SIZE);  				ns.BeginRead (state.data' 0' state.data.Length' new AsyncCallback (OnDataRead)' state);  			} catch {  			}  			return;  		} else  			return;  	}  	msg_data = new byte[msg_len];  	//if message length greater than the calcualted message length. copy message and trigger message event  	if (ss.data.Length >= msg_len) {  		Array.Copy (ss.data' offset' msg_data' 0' msg_len);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len;  		msg_len = 0;  		goto REPEAT;  	} else//If the received data is shorter than the message length' keep reading for the next data   	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' 0' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  } else {  	//if data length larger than needed data for a complete message'   	//copy data into existing message and triggered message event   	if (ss.data.Length >= msg_len - msg_cursor) {  		Array.Copy (ss.data' 0' msg_data' msg_cursor' msg_len - msg_cursor);  		delegateMessageReceived msgRecv = new delegateMessageReceived (TriggerMessageEvent);  		msgRecv.BeginInvoke (msg_ver' msg_type' msg_id' msg_data' null' null);  		offset += msg_len - msg_cursor;  		msg_len = 0;  		msg_cursor = 0;  		new_message = true;  		goto REPEAT;  	} else//keep reading  	 {  		new_message = false;  		Array.Copy (ss.data' 0' msg_data' msg_cursor' ss.data.Length);  		msg_cursor += ss.data.Length;  	}  }  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_ver = (Int16)((header >> 10) & 0x07);  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_len = (ss.data [offset + 2] << 24) + (ss.data [offset + 3] << 16) + (ss.data [offset + 4] << 8) + ss.data [offset + 5];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP,TCPIPServer,D:\newReposJune17\wisp_impinj-reader-app\LLRP\TCPIPConnection.cs,OnDataRead,The following statement contains a magic number: msg_id = (ss.data [offset + 6] << 24) + (ss.data [offset + 7] << 16) + (ss.data [offset + 8] << 8) + ss.data [offset + 9];  
Magic Number,LLRP.DataType,UInt16Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,ToHexString,The following statement contains a magic number: for (int i = 0; i < data.Count; i++) {  	UInt16 hD = (UInt16)(data [i] >> 8);  	UInt16 lD = (UInt16)(data [i] & 0x00FF);  	s += hD.ToString ("X2") + lD.ToString ("X2");  }  
Magic Number,LLRP.DataType,UInt16Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,FromString,The following statement contains a magic number: if (str != string.Empty) {  	string[] s = Util.SplitString (str' new char[] {  		''''  		' '  	}' 4);  	for (int i = 0; i < s.Length; i++) {  		try {  			if (s [i] != string.Empty)  				Arr.Add (Convert.ToUInt16 (s [i]' 16));  		} catch {  		}  	}  }  
Magic Number,LLRP.DataType,UInt16Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,FromString,The following statement contains a magic number: if (str != string.Empty) {  	string[] s = Util.SplitString (str' new char[] {  		''''  		' '  	}' 4);  	for (int i = 0; i < s.Length; i++) {  		try {  			if (s [i] != string.Empty)  				Arr.Add (Convert.ToUInt16 (s [i]' 16));  		} catch {  		}  	}  }  
Magic Number,LLRP.DataType,UInt16Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,FromString,The following statement contains a magic number: for (int i = 0; i < s.Length; i++) {  	try {  		if (s [i] != string.Empty)  			Arr.Add (Convert.ToUInt16 (s [i]' 16));  	} catch {  	}  }  
Magic Number,LLRP.DataType,UInt16Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,FromString,The following statement contains a magic number: try {  	if (s [i] != string.Empty)  		Arr.Add (Convert.ToUInt16 (s [i]' 16));  } catch {  }  
Magic Number,LLRP.DataType,UInt16Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,FromString,The following statement contains a magic number: if (s [i] != string.Empty)  	Arr.Add (Convert.ToUInt16 (s [i]' 16));  
Magic Number,LLRP.DataType,UInt16Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,FromString,The following statement contains a magic number: Arr.Add (Convert.ToUInt16 (s [i]' 16));  
Magic Number,LLRP.DataType,UInt32Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,ToHexString,The following statement contains a magic number: for (int i = 0; i < data.Count; i++) {  	UInt16 hD = (UInt16)(data [i] >> 16);  	UInt16 lD = (UInt16)(data [i] & 0x0000FFFF);  	UInt16 d1 = (UInt16)(hD >> 8);  	UInt16 d2 = (UInt16)(hD & 0x00FF);  	UInt16 d3 = (UInt16)(lD >> 8);  	UInt16 d4 = (UInt16)(lD & 0x00FF);  	s += d1.ToString ("X2") + d2.ToString ("X2") + d3.ToString ("X2") + d4.ToString ("X2");  }  
Magic Number,LLRP.DataType,UInt32Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,ToHexString,The following statement contains a magic number: for (int i = 0; i < data.Count; i++) {  	UInt16 hD = (UInt16)(data [i] >> 16);  	UInt16 lD = (UInt16)(data [i] & 0x0000FFFF);  	UInt16 d1 = (UInt16)(hD >> 8);  	UInt16 d2 = (UInt16)(hD & 0x00FF);  	UInt16 d3 = (UInt16)(lD >> 8);  	UInt16 d4 = (UInt16)(lD & 0x00FF);  	s += d1.ToString ("X2") + d2.ToString ("X2") + d3.ToString ("X2") + d4.ToString ("X2");  }  
Magic Number,LLRP.DataType,UInt32Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,ToHexString,The following statement contains a magic number: for (int i = 0; i < data.Count; i++) {  	UInt16 hD = (UInt16)(data [i] >> 16);  	UInt16 lD = (UInt16)(data [i] & 0x0000FFFF);  	UInt16 d1 = (UInt16)(hD >> 8);  	UInt16 d2 = (UInt16)(hD & 0x00FF);  	UInt16 d3 = (UInt16)(lD >> 8);  	UInt16 d4 = (UInt16)(lD & 0x00FF);  	s += d1.ToString ("X2") + d2.ToString ("X2") + d3.ToString ("X2") + d4.ToString ("X2");  }  
Magic Number,LLRP.DataType,UInt32Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,FromString,The following statement contains a magic number: for (int i = 0; i < s.Length; i++) {  	try {  		Arr.Add (Convert.ToUInt32 (s [i]' 16));  	} catch {  	}  }  
Magic Number,LLRP.DataType,UInt32Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,FromString,The following statement contains a magic number: try {  	Arr.Add (Convert.ToUInt32 (s [i]' 16));  } catch {  }  
Magic Number,LLRP.DataType,UInt32Array,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,FromString,The following statement contains a magic number: Arr.Add (Convert.ToUInt32 (s [i]' 16));  
Magic Number,LLRP.DataType,U96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,ToString,The following statement contains a magic number: return string.Format ("{0:4X}{1:4X}{2:4X}{3:4X}{4:4X}{5:4X}"' data [0]' data [1]' data [2]' data [3]' data [4]' data [5]);  
Magic Number,LLRP.DataType,U96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,ToString,The following statement contains a magic number: return string.Format ("{0:4X}{1:4X}{2:4X}{3:4X}{4:4X}{5:4X}"' data [0]' data [1]' data [2]' data [3]' data [4]' data [5]);  
Magic Number,LLRP.DataType,U96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,ToString,The following statement contains a magic number: return string.Format ("{0:4X}{1:4X}{2:4X}{3:4X}{4:4X}{5:4X}"' data [0]' data [1]' data [2]' data [3]' data [4]' data [5]);  
Magic Number,LLRP.DataType,U96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,ToString,The following statement contains a magic number: return string.Format ("{0:4X}{1:4X}{2:4X}{3:4X}{4:4X}{5:4X}"' data [0]' data [1]' data [2]' data [3]' data [4]' data [5]);  
Magic Number,LLRP.DataType,U96,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,U96,The following statement contains a magic number: data = new ushort[6];  
Magic Number,LLRP.DataType,TwoBits,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,TwoBits,The following statement contains a magic number: bits = new bool[2];  
Magic Number,LLRP.DataType,TwoBits,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,TwoBits,The following statement contains a magic number: bits [0] = ((data & 0x0002) == 2) ? true : false;  
Magic Number,LLRP.DataType,TwoBits,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPDataType.cs,ToInt,The following statement contains a magic number: return (UInt16)((UInt16)(bits [0] ? 2 : 0) + (UInt16)(bits [1] ? 1 : 0));  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToByteArray,The following statement contains a magic number: for (int i = 0; i < size; i++) {  	for (int j = 0; j < reserved; j++) {  		val = (byte)(val << 1);  		val += (byte)(bit_array [i * 8 + j] ? 0x01 : 0x00);  	}  	data [i] = val;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToByteArray,The following statement contains a magic number: for (int j = 0; j < reserved; j++) {  	val = (byte)(val << 1);  	val += (byte)(bit_array [i * 8 + j] ? 0x01 : 0x00);  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToByteArray,The following statement contains a magic number: val += (byte)(bit_array [i * 8 + j] ? 0x01 : 0x00);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertByteArrayToBitArray,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)  	for (int j = 0; j < 8; j++)  		bit_array [i * 8 + j] = (((data [i] >> (7 - j)) & 0x01) == 1) ? true : false;  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertByteArrayToBitArray,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)  	for (int j = 0; j < 8; j++)  		bit_array [i * 8 + j] = (((data [i] >> (7 - j)) & 0x01) == 1) ? true : false;  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertByteArrayToBitArray,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)  	for (int j = 0; j < 8; j++)  		bit_array [i * 8 + j] = (((data [i] >> (7 - j)) & 0x01) == 1) ? true : false;  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertByteArrayToBitArray,The following statement contains a magic number: for (int j = 0; j < 8; j++)  	bit_array [i * 8 + j] = (((data [i] >> (7 - j)) & 0x01) == 1) ? true : false;  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertByteArrayToBitArray,The following statement contains a magic number: for (int j = 0; j < 8; j++)  	bit_array [i * 8 + j] = (((data [i] >> (7 - j)) & 0x01) == 1) ? true : false;  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertByteArrayToBitArray,The following statement contains a magic number: for (int j = 0; j < 8; j++)  	bit_array [i * 8 + j] = (((data [i] >> (7 - j)) & 0x01) == 1) ? true : false;  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertByteArrayToBitArray,The following statement contains a magic number: bit_array [i * 8 + j] = (((data [i] >> (7 - j)) & 0x01) == 1) ? true : false;  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertByteArrayToBitArray,The following statement contains a magic number: bit_array [i * 8 + j] = (((data [i] >> (7 - j)) & 0x01) == 1) ? true : false;  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,DetermineFieldLength,The following statement contains a magic number: return (int)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	obj = bit_array [cursor];  	cursor++;  } else if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: obj = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  } else if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: obj = (sbyte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: obj = (UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  } else if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: obj = (Int16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  } else if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  } else if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: obj = (Int32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: obj = (UInt64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  } else if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: obj = (Int64)(UInt64)CalculateVal (ref bit_array' ref cursor' 64);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	string s = string.Empty;  	for (int i = 0; i < field_len; i++) {  		try {  			byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  			System.Text.UTF8Encoding encoding = new UTF8Encoding ();  			byte[] bdarr = new byte[1] {  				bd  			};  			s += encoding.GetString (bdarr);  		} catch {  		}  	}  	if (field_len > 1 && s [field_len - 1] == 0)  		s = s.Substring (0' field_len - 1);  	obj = s;  } else if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: for (int i = 0; i < field_len; i++) {  	try {  		byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  		System.Text.UTF8Encoding encoding = new UTF8Encoding ();  		byte[] bdarr = new byte[1] {  			bd  		};  		s += encoding.GetString (bdarr);  	} catch {  	}  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: try {  	byte bd = (byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8);  	System.Text.UTF8Encoding encoding = new UTF8Encoding ();  	byte[] bdarr = new byte[1] {  		bd  	};  	s += encoding.GetString (bdarr);  } catch {  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	obj = new ByteArray ();  	for (int i = 0; i < field_len; i++)  		((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  } else if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: for (int i = 0; i < field_len; i++)  	((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: ((ByteArray)obj).Add ((byte)(UInt64)CalculateVal (ref bit_array' ref cursor' 8));  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	obj = new UInt16Array ();  	for (int i = 0; i < field_len; i++)  		((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  } else if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: for (int i = 0; i < field_len; i++)  	((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: ((UInt16Array)obj).Add ((UInt16)(UInt64)CalculateVal (ref bit_array' ref cursor' 16));  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(UInt32Array))) {  	obj = new UInt32Array ();  	for (int i = 0; i < field_len; i++)  		((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  } else if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: for (int i = 0; i < field_len; i++)  	((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: ((UInt32Array)obj).Add ((UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' 32));  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	obj = new TwoBits (bit_array [cursor]' bit_array [cursor + 1]);  	cursor += 2;  } else if (type.Equals (typeof(BitArray))) {  	obj = new BitArray (field_len);  	for (int i = 0; i < field_len; i++) {  		((BitArray)obj) [i] = bit_array [cursor];  		cursor++;  	}  } else if (type.Equals (typeof(LLRPBitArray))) {  	obj = new LLRPBitArray ();  	for (int i = 0; i < field_len; i++) {  		((LLRPBitArray)obj).Add (bit_array [cursor]);  		cursor++;  	}  } else  	obj = (UInt32)(UInt64)CalculateVal (ref bit_array' ref cursor' field_len);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBitArrayToObj,The following statement contains a magic number: cursor += 2;  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(bool))) {  	bit_arr = new BitArray (1);  	bit_arr [0] = (bool)obj;  	return bit_arr;  } else if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(TwoBits))) {  	bit_arr = new BitArray (2);  	bit_arr [0] = ((TwoBits)obj) [0];  	bit_arr [1] = ((TwoBits)obj) [1];  	return bit_arr;  } else if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr = new BitArray (2);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(byte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr = new BitArray (8);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((byte)obj' 2).PadLeft (8' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	bit_arr [i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(sbyte))) {  	bit_arr = new BitArray (8);  	s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr = new BitArray (8);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((sbyte)obj' 2).PadLeft (8' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	bit_arr [i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr = new BitArray (16);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((UInt16)obj' 2).PadLeft (16' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 16; i++)  	bit_arr [i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int16))) {  	bit_arr = new BitArray (16);  	s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr = new BitArray (16);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((Int16)obj' 2).PadLeft (16' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 16; i++)  	bit_arr [i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr = new BitArray (32);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((UInt32)obj' 2).PadLeft (32' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 32; i++)  	bit_arr [i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int32))) {  	bit_arr = new BitArray (32);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr = new BitArray (32);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((Int32)obj' 2).PadLeft (32' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 32; i++)  	bit_arr [i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt64))) {  	bit_arr = new BitArray (64);  	Int64 tempV = (Int64)(UInt64)obj;  	s = Convert.ToString (tempV' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr = new BitArray (64);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString (tempV' 2).PadLeft (64' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString (tempV' 2).PadLeft (64' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 64; i++)  	bit_arr [i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(Int64))) {  	bit_arr = new BitArray (64);  	s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  	for (int i = 0; i < 64; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  } else if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr = new BitArray (64);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((Int64)obj' 2).PadLeft (64' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 64; i++)  	bit_arr [i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(string))) {  	int len = ((string)obj).Length * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((string)obj).Length; k++) {  		s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((string)obj).Length; k++) {  	s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [k * 8 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((string)obj).Length; k++) {  	s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [k * 8 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((string)obj).Length; k++) {  	s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [k * 8 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((string)obj).Length; k++) {  	s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [k * 8 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString (((string)obj) [k]' 2).PadLeft (8' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	bit_arr [k * 8 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	bit_arr [k * 8 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr [k * 8 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(BitArray))) {  	int len = ((BitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((BitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(LLRPBitArray))) {  	int len = ((LLRPBitArray)obj).Count * 1;  	bit_arr = new BitArray (len);  	for (int k = 0; k < len; k++)  		bit_arr [k] = ((LLRPBitArray)obj) [k];  	return bit_arr;  } else if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(ByteArray))) {  	int len = ((ByteArray)obj).Count * 8;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((ByteArray)obj).Count; k++) {  		s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  		for (int i = 0; i < 8; i++)  			bit_arr [k * 8 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((ByteArray)obj).Count; k++) {  	s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [k * 8 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((ByteArray)obj).Count; k++) {  	s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [k * 8 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((ByteArray)obj).Count; k++) {  	s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [k * 8 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((ByteArray)obj).Count; k++) {  	s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  	for (int i = 0; i < 8; i++)  		bit_arr [k * 8 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((byte)(((ByteArray)obj) [k])' 2).PadLeft (8' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	bit_arr [k * 8 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	bit_arr [k * 8 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr [k * 8 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt16Array))) {  	int len = ((UInt16Array)obj).Count * 16;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  		s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  		for (int i = 0; i < 16; i++)  			bit_arr [k * 16 + i] = (s [i] == '1');  	}  	return bit_arr;  } else if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  	s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [k * 16 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  	s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [k * 16 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  	s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [k * 16 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((UInt16Array)obj).Count; k++) {  	s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  	for (int i = 0; i < 16; i++)  		bit_arr [k * 16 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((UInt16)(((UInt16Array)obj) [k])' 2).PadLeft (16' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 16; i++)  	bit_arr [k * 16 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 16; i++)  	bit_arr [k * 16 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr [k * 16 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: if (type.Equals (typeof(UInt32Array))) {  	int len = ((UInt32Array)obj).Count * 32;  	bit_arr = new BitArray (len);  	for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  		s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  		for (int i = 0; i < 32; i++)  			bit_arr [k * 32 + i] = (s [i] == '1');  	}  	return bit_arr;  } else {  	bit_arr = new BitArray (length);  	s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  	for (int i = 0; i < length; i++)  		bit_arr [i] = (s [i] == '1');  	return bit_arr;  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  	s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [k * 32 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  	s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [k * 32 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  	s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [k * 32 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int k = 0; k < ((UInt32Array)obj).Count; k++) {  	s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  	for (int i = 0; i < 32; i++)  		bit_arr [k * 32 + i] = (s [i] == '1');  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((UInt32)(((UInt32Array)obj) [k])' 2).PadLeft (32' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 32; i++)  	bit_arr [k * 32 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: for (int i = 0; i < 32; i++)  	bit_arr [k * 32 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: bit_arr [k * 32 + i] = (s [i] == '1');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertObjToBitArray,The following statement contains a magic number: s = Convert.ToString ((Int32)obj' 2).PadLeft (length' '0');  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertHexStringToByteArray,The following statement contains a magic number: if (nSize * 2 > fLen) {  	strArray = "0" + str;  } else  	strArray = str;  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertHexStringToByteArray,The following statement contains a magic number: for (int i = 0; i < nSize; i++) {  	int index = i * 2;  	char[] cArr = new char[] {  		strArray [index]'  		strArray [index + 1]  	};  	string s = new string (cArr);  	try {  		bytes [i] = Convert.ToByte (s' 16);  	} catch (System.OverflowException) {  		System.Console.WriteLine ("Conversion from string to byte overflowed.");  	} catch (System.FormatException) {  		System.Console.WriteLine ("The string is not formatted as a byte.");  	} catch (System.ArgumentNullException) {  		System.Console.WriteLine ("The string is null.");  	}  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertHexStringToByteArray,The following statement contains a magic number: for (int i = 0; i < nSize; i++) {  	int index = i * 2;  	char[] cArr = new char[] {  		strArray [index]'  		strArray [index + 1]  	};  	string s = new string (cArr);  	try {  		bytes [i] = Convert.ToByte (s' 16);  	} catch (System.OverflowException) {  		System.Console.WriteLine ("Conversion from string to byte overflowed.");  	} catch (System.FormatException) {  		System.Console.WriteLine ("The string is not formatted as a byte.");  	} catch (System.ArgumentNullException) {  		System.Console.WriteLine ("The string is null.");  	}  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertHexStringToByteArray,The following statement contains a magic number: try {  	bytes [i] = Convert.ToByte (s' 16);  } catch (System.OverflowException) {  	System.Console.WriteLine ("Conversion from string to byte overflowed.");  } catch (System.FormatException) {  	System.Console.WriteLine ("The string is not formatted as a byte.");  } catch (System.ArgumentNullException) {  	System.Console.WriteLine ("The string is null.");  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertHexStringToByteArray,The following statement contains a magic number: bytes [i] = Convert.ToByte (s' 16);  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBinaryStringToHexString,The following statement contains a magic number: while (tmp.Length > 0) {  	int index = tmp.Length > 4 ? (tmp.Length - 4) : 0;  	int length = tmp.Length > 4 ? 4 : tmp.Length;  	string str = tmp.Substring (index' length);  	tmp = tmp.Remove (index' length);  	UInt64 dec = ConvertBinaryStringToDecimal (str);  	string s = Convert.ToString ((long)dec' 16);  	strHex = strHex.Insert (0' s);  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBinaryStringToHexString,The following statement contains a magic number: while (tmp.Length > 0) {  	int index = tmp.Length > 4 ? (tmp.Length - 4) : 0;  	int length = tmp.Length > 4 ? 4 : tmp.Length;  	string str = tmp.Substring (index' length);  	tmp = tmp.Remove (index' length);  	UInt64 dec = ConvertBinaryStringToDecimal (str);  	string s = Convert.ToString ((long)dec' 16);  	strHex = strHex.Insert (0' s);  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBinaryStringToHexString,The following statement contains a magic number: while (tmp.Length > 0) {  	int index = tmp.Length > 4 ? (tmp.Length - 4) : 0;  	int length = tmp.Length > 4 ? 4 : tmp.Length;  	string str = tmp.Substring (index' length);  	tmp = tmp.Remove (index' length);  	UInt64 dec = ConvertBinaryStringToDecimal (str);  	string s = Convert.ToString ((long)dec' 16);  	strHex = strHex.Insert (0' s);  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBinaryStringToHexString,The following statement contains a magic number: while (tmp.Length > 0) {  	int index = tmp.Length > 4 ? (tmp.Length - 4) : 0;  	int length = tmp.Length > 4 ? 4 : tmp.Length;  	string str = tmp.Substring (index' length);  	tmp = tmp.Remove (index' length);  	UInt64 dec = ConvertBinaryStringToDecimal (str);  	string s = Convert.ToString ((long)dec' 16);  	strHex = strHex.Insert (0' s);  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBinaryStringToHexString,The following statement contains a magic number: while (tmp.Length > 0) {  	int index = tmp.Length > 4 ? (tmp.Length - 4) : 0;  	int length = tmp.Length > 4 ? 4 : tmp.Length;  	string str = tmp.Substring (index' length);  	tmp = tmp.Remove (index' length);  	UInt64 dec = ConvertBinaryStringToDecimal (str);  	string s = Convert.ToString ((long)dec' 16);  	strHex = strHex.Insert (0' s);  }  
Magic Number,LLRP.DataType,Util,D:\newReposJune17\wisp_impinj-reader-app\LLRP\LLRPUtil.cs,ConvertBinaryStringToDecimal,The following statement contains a magic number: if (strBinary.Length > 64) {  	throw new Exception ("String is longer than 64 bits' less than 64 bits is required");  }  
