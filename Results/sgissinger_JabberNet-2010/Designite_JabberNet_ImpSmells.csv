Implementation smell,Namespace,Class,File,Method,Description
Long Method,Bedrock.Net,HttpSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,OnRead,The method has 113 lines of code.
Long Method,Bedrock.Net,XEP25Socket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,The method has 163 lines of code.
Long Method,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The method has 130 lines of code.
Long Method,Jabber.Connection,XmppStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,ProcessFeatures,The method has 106 lines of code.
Long Method,Jabber.Connection,XmppStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,OnElement,The method has 140 lines of code.
Long Method,Jabber.Connection,Room,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\ConferenceManager.cs,m_stream_OnProtocol,The method has 102 lines of code.
Long Method,Jabber.Protocol,AsynchElementStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The method has 107 lines of code.
Long Method,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The method has 129 lines of code.
Long Method,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The method has 235 lines of code.
Long Method,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The method has 145 lines of code.
Long Method,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The method has 248 lines of code.
Complex Method,Bedrock.Net,Address,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Address.cs,PickSRV,Cyclomatic complexity of the method is 10
Complex Method,Bedrock.Net,Address,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Address.cs,LookupTXT,Cyclomatic complexity of the method is 8
Complex Method,Bedrock.Net,XEP124Socket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP124Socket.cs,OnRead,Cyclomatic complexity of the method is 12
Complex Method,Bedrock.Net,XEP25Socket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,Cyclomatic complexity of the method is 17
Complex Method,Bedrock.Util,GetOpt,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\GetOptBase.cs,Process,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Client,BookmarkManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\BookmarkManager.Designer.cs,GotBookmarks,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Client,JabberClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,Presence,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Client,JabberClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,OnElement,Cyclomatic complexity of the method is 9
Complex Method,Jabber.Connection,CapsManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CapsManager.Designer.cs,CalculateVer,Cyclomatic complexity of the method is 10
Complex Method,Jabber.Connection,DiscoManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\DiscoManager.Designer.cs,GotAgents,Cyclomatic complexity of the method is 14
Complex Method,Jabber.Connection,PubSubManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\PubSubManager.Designer.cs,OnDefaults,Cyclomatic complexity of the method is 9
Complex Method,Jabber.Connection,XmppStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,ProcessFeatures,Cyclomatic complexity of the method is 13
Complex Method,Jabber.Connection,PubSubNode,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\PubSubManager.cs,OnConfigure,Cyclomatic complexity of the method is 9
Complex Method,Jabber.Server,JabberService,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Server\JabberService.Designer.cs,OnElement,Cyclomatic complexity of the method is 10
Complex Method,Jabber.Stun,HolePuncher,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\HolePuncher.cs,TcpPunchThreadStart,Cyclomatic complexity of the method is 10
Complex Method,Bedrock.Collections,SkipList,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Collections\SkipList.cs,Remove,Cyclomatic complexity of the method is 8
Complex Method,Bedrock.Collections,Tree,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Collections\Tree.cs,swapPosition,Cyclomatic complexity of the method is 10
Complex Method,Jabber.Connection.SASL,MD5Processor,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\MD5Processor.cs,validateStartDirectives,Cyclomatic complexity of the method is 8
Complex Method,Jabber,JID,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\JID.cs,Parse,Cyclomatic complexity of the method is 11
Complex Method,Jabber,JID,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\JID.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Protocol,AsynchElementStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,StartTag,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,CloneNode,Cyclomatic complexity of the method is 10
Complex Method,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,Cyclomatic complexity of the method is 8
Long Parameter List,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,linux_res_query,The method has 5 parameters. Parameters: dname' cls' type' header' headerlen
Long Parameter List,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,linux_dn_expand,The method has 5 parameters. Parameters: msg' endorig' comp_dn' exp_dn' length
Long Parameter List,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,bsd_res_query,The method has 5 parameters. Parameters: dname' cls' type' header' headerlen
Long Parameter List,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,bsd_dn_expand,The method has 5 parameters. Parameters: msg' endorig' comp_dn' exp_dn' length
Long Parameter List,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,res_query,The method has 5 parameters. Parameters: dname' cls' type' header' headerlen
Long Parameter List,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,dn_expand,The method has 5 parameters. Parameters: msg' endorig' comp_dn' exp_dn' length
Long Parameter List,Bedrock.Net,AsyncSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,ChooseClientCertificate,The method has 5 parameters. Parameters: sender' targetHost' localCertificates' remoteCertificate' acceptableIssuers
Long Parameter List,Bedrock.Net,HttpSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,Execute,The method has 6 parameters. Parameters: method' URL' body' offset' len' contentType
Long Parameter List,Bedrock.Net,HttpSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,ParseAt,The method has 5 parameters. Parameters: buf' i' last' check' checkoffset
Long Parameter List,Bedrock.Net,PendingRequest,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,PendingRequest,The method has 6 parameters. Parameters: method' URL' body' offset' len' contentType
Long Parameter List,Jabber.Client,JingleManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleManager.cs,SessionRequest,The method has 6 parameters. Parameters: to' action' sid' contentName' description' transport
Long Parameter List,Jabber.Connection,DiscoManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\DiscoManager.Designer.cs,BeginGetFeatures,The method has 5 parameters. Parameters: jid' node' handler' state' cache
Long Parameter List,Jabber.Connection,DiscoManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\DiscoManager.Designer.cs,BeginGetItems,The method has 5 parameters. Parameters: jid' node' handler' state' cache
Long Parameter List,Jabber.Protocol.IQ,JingleIce,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The method has 10 parameters. Parameters: localPriority' component' foundation' generation' id' network' ip' port' protocol' type
Long Parameter List,Jabber.Protocol.IQ,JingleIce,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The method has 12 parameters. Parameters: localPriority' component' foundation' generation' id' network' ip' port' protocol' type' relatedAddress' relatedPort
Long Parameter List,Jabber.Server,XdbTracker,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Server\XdbTracker.cs,BeginXdbSet,The method has 5 parameters. Parameters: root' owner' ns' cb' cbArg
Long Parameter List,Jabber.Server,XdbTracker,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Server\XdbTracker.cs,BeginXdb,The method has 6 parameters. Parameters: root' xtype' owner' ns' cb' cbArg
Long Parameter List,Jabber.Server,XdbTracker,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Server\XdbTracker.cs,BeginXdb,The method has 7 parameters. Parameters: root' xtype' owner' ns' action' cb' cbArg
Long Parameter List,Jabber.Stun,StunClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,StunClient,The method has 5 parameters. Parameters: hostEP' stunServerEP' protocolType' clientCertificate' remoteCertificateValidation
Long Parameter List,Bedrock.IO,ReadEventStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ReadEventStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Bedrock.IO,ReadEventStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ReadEventStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Bedrock.IO,ZlibStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ZlibStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Bedrock.IO,ZlibStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ZlibStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Jabber.Connection.SASL,SSPIHelper,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\KerbProcessor.cs,AcquireCredentialsHandle,The method has 9 parameters. Parameters: pszPrincipal' pszPackage' fCredentialUse' PAuthenticationID' pAuthData' pGetKeyFn' pvGetKeyArgument' phCredential' ptsExpiry
Long Parameter List,Jabber.Connection.SASL,SSPIHelper,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\KerbProcessor.cs,AcquireCredentialsHandle,The method has 9 parameters. Parameters: pszPrincipal' pszPackage' fCredentialUse' PAuthenticationID' pAuthData' pGetKeyFn' pvGetKeyArgument' phCredential' ptsExpiry
Long Parameter List,Jabber.Connection.SASL,SSPIHelper,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\KerbProcessor.cs,InitializeSecurityContext,The method has 12 parameters. Parameters: phCredential' phContext' pszTargetName' fContextReq' Reserved1' TargetDataRep' pInput' Reserved2' phNewContext' pOutput' pfContextAttr' ptsExpiry
Long Parameter List,Jabber.Connection.SASL,SSPIHelper,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\KerbProcessor.cs,InitializeSecurityContext,The method has 12 parameters. Parameters: phCredential' phContext' pszTargetName' fContextReq' Reserved1' TargetDataRep' SecBufferDesc' Reserved2' phNewContext' pOutput' pfContextAttr' ptsExpiry
Long Parameter List,Jabber.Protocol,XMLParseException,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,XMLParseException,The method has 5 parameters. Parameters: innerException' stream' buf' offset' length
Long Parameter List,Jabber.Protocol.X,Data,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\X\Data.cs,AddField,The method has 5 parameters. Parameters: var' typ' label' val' desc
Long Parameter List,XpNet,ContentToken,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\ContentToken.cs,appendAttribute,The method has 5 parameters. Parameters: nameStart' nameEnd' valueStart' valueEnd' normalized
Long Parameter List,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,convert,The method has 5 parameters. Parameters: sourceBuf' sourceStart' sourceEnd' targetBuf' targetStart
Long Parameter List,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The method has 5 parameters. Parameters: nameStart' buf' off' end' token
Long Parameter List,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The method has 5 parameters. Parameters: open' buf' off' end' token
Long Parameter List,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The method has 5 parameters. Parameters: sourceBuf' sourceStart' sourceEnd' targetBuf' targetStart
Long Identifier,Jabber.Connection,Options,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.cs,,The length of the parameter NESTED_GROUPS_DEFAULT_DELIMITER is 31.
Long Identifier,Jabber.Connection,Options,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.cs,,The length of the parameter AUTO_STORE_NESTED_GROUPS_DELIMITER is 34.
Long Identifier,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,GetMappedAddressFrom,The length of the parameter remoteCertificateValidationHandler is 34.
Long Identifier,Jabber.Stun,TurnManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,TurnManager,The length of the parameter remoteCertificateValidationHandler is 34.
Long Identifier,Jabber.Connection.SASL,SSPIHelper,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\KerbProcessor.cs,,The length of the parameter ISC_REQ_MANUAL_CRED_VALIDATION is 30.
Long Statement,Jabber.Client,JingleIceManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleIceManager.cs,CreateTurnSession,The length of the statement  "            TurnManager turnManager = new TurnManager(this.StunServerEP' ProtocolType.Tcp' this.TurnClientCertificate' this.TurnRemoteCertificateValidation); " is 145.
Long Statement,Jabber.Client,JingleIceManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleIceManager.cs,CreateTurnSession,The length of the statement  "            turnManager.OnConnectionAttemptReceived += new StunIndicationReceptionHandler(this.turnManager_OnConnectionAttemptReceived); " is 124.
Long Statement,Jabber.Client,JingleIceManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleIceManager.cs,turnManager_OnAllocateSucceed,The length of the statement  "                    this.OnIceCandidatesGathering(this' jingleIce' (sender as TurnManager).HostEP' this.turnSessions[this.StartingSessionSid].UseTurnOnly' allocation); " is 147.
Long Statement,Jabber.Client,PresenceManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\PresenceManager.Designer.cs,AddPresence,The length of the statement  "                "Do not call AddPresence by hand.  I can tell you are doing that because you didn't put a from address on your presence packet' and all presences from the server have a from address."); " is 185.
Long Statement,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The length of the statement  "            this.btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 145.
Long Statement,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The length of the statement  "            this.btnAllow.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 144.
Long Statement,Jabber.Connection,XmppStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,OnInvalidCertificate,The length of the statement  "            return (bool)m_invoker.Invoke(new RemoteCertificateValidationCallback(ShowCertificatePrompt)' new object[]{ sock' certificate' chain' sslPolicyErrors }); " is 153.
Long Statement,Jabber.Stun,StunClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,Connect,The length of the statement  "                throw new ArgumentException("StunClient socket is not null' you must close it before doing any new connection"' "this.Socket"); " is 127.
Long Statement,Jabber.Stun,StunClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,Connect,The length of the statement  "                localCertificateSelection = (sender' targetHost' localCertificates' remoteCertificate' acceptableIssuers) => localCertificates[0]; " is 130.
Long Statement,Jabber.Stun,StunClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,Connect,The length of the statement  "                IAsyncResult ar = this.SslStream.BeginAuthenticateAsClient(this.ServerEP.Address.ToString()' clientCertificates' SslProtocols.Tls' true' null' null); " is 149.
Long Statement,Jabber.Stun,StunClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,BeginSendMessage,The length of the statement  "                this.PendingTransactions.Add(msgToSend.TransactionID' new KeyValuePair<StunMessage' Object>(msgToSend' transactionObject)); " is 123.
Long Statement,Jabber.Stun,StunClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,BeginSendMessage,The length of the statement  "                this.Socket.BeginSend(msgToSend' 0' msgToSend.Bytes.Length' SocketFlags.None' new AsyncCallback(this.SendCallback)' null); " is 122.
Long Statement,Jabber.Stun,StunMessage,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,AddMessageIntegrity,The length of the statement  "                    throw new ArgumentException("USERNAME attribute is mandatory for long-term credentials MESSAGE-INTEGRITY creation"' "this.Username"); " is 133.
Long Statement,Jabber.Stun,StunMessage,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,AddMessageIntegrity,The length of the statement  "                    throw new ArgumentException("REALM attribute is mandatory for long-term credentials MESSAGE-INTEGRITY creation"' "this.Realm"); " is 127.
Long Statement,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,GetMappedAddressFrom,The length of the statement  "            StunClient cli = new StunClient(hostEP' serverEP' ProtocolType.Tcp' clientCertificate' remoteCertificateValidationHandler); " is 123.
Long Statement,Jabber.Stun,TurnManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,AllocateRetry,The length of the statement  "            msg.Turn.RequestedTransport = new StunAttribute(StunAttributeType.RequestedTransport' BitConverter.GetBytes(StunMessage.CODE_POINT_TCP)); " is 137.
Long Statement,Jabber.Stun,TurnManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,RefreshAllocation,The length of the statement  "            msg.Turn.LifeTime = new StunAttribute(StunAttributeType.LifeTime' BitConverter.GetBytes(StunUtilities.ReverseBytes(lifeTime))); " is 127.
Long Statement,Jabber.Stun,TurnManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,CreatePermission,The length of the statement  "            StunMessage msg = new StunMessage(StunMethodType.CreatePermission' StunMethodClass.Request' StunUtilities.NewTransactionId); " is 124.
Long Statement,Jabber.Stun,TurnManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,ConnectionBind,The length of the statement  "            this.TurnTcpManager.OnAllocateSucceed += (object sender' TurnAllocation allocation' StunMessage sentMsg' StunMessage receivedMsg) => " is 132.
Long Statement,Jabber.Stun,TurnManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,ConnectionBind,The length of the statement  "                    StunMessage msg = new StunMessage(StunMethodType.ConnectionBind' StunMethodClass.Request' StunUtilities.NewTransactionId); " is 122.
Long Statement,Bedrock.IO,ZlibStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ZlibStream.cs,BeginWrite,The length of the statement  "                    ZlibStreamAsyncResult res = new ZlibStreamAsyncResult(state' new CompressionFailedException("Compress failed: " + err)); " is 120.
Long Statement,Bedrock.IO,ZlibStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ZlibStream.cs,BeginWrite,The length of the statement  "                return m_stream.BeginWrite(m_outbuf' 0' bufsize - m_out.avail_out' new AsyncCallback(IntermediateWrite)' new ZlibState(callback' state)); " is 137.
Long Statement,Bedrock.IO,ZlibStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ZlibStream.cs,IntermediateWrite,The length of the statement  "                    ZlibStreamAsyncResult res = new ZlibStreamAsyncResult(state.state' new CompressionFailedException("Compress failed: " + err)); " is 126.
Long Statement,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,CreateChildElement,The length of the statement  "            Debug.Assert(constructor != null' "Type " + typeof(T).ToString() + " does not have a constructor taking an XmlDocument"); " is 121.
Long Statement,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,CloneNode,The length of the statement  "            XmlElement el = (Element)ci.Invoke(new object[] { this.Prefix' new XmlQualifiedName(this.LocalName' this.NamespaceURI)' doc }); " is 127.
Complex Conditional,Bedrock.Net,ShttpProxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\ShttpProxy.cs,OnConnect,The conditional expression  "Username != null && Username.Length > 0 && Password != null && Password.Length > 0"  is complex.
Complex Conditional,Bedrock.Net,XEP124Socket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP124Socket.cs,OnConnect,The conditional expression  "!m_running &&                      m_sockA != null && m_sockA.Connected &&                      m_sockB != null && m_sockB.Connected"  is complex.
Complex Conditional,Jabber.Client,PingManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\PingManager.cs,GotIQ,The conditional expression  "!iq.Handled &&                  iq.Query != null && iq.Type == IQType.get &&                  iq.Query.NamespaceURI == URI.PING"  is complex.
Complex Conditional,Jabber.Client,JabberClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,FireOnIQ,The conditional expression  "this.SupportNestedGroups && !iq.Handled &&                  iq.Query != null && iq.Type == IQType.result &&                  iq.Query.NamespaceURI == URI.PRIVATE &&                  iq.GetChildElement<Private>().GetChildElement<RosterDelimiter>() != null"  is complex.
Complex Conditional,Jabber.Client,JabberClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,FireOnIQ,The conditional expression  "!iq.Handled && iq.HasAttribute("from") &&   // Belt.  Suspenders.  Don't respond to roster pushes.                      (iq.Type == IQType.get || iq.Type == IQType.set)"  is complex.
Complex Conditional,Jabber.Client,RosterManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RosterManager.Designer.cs,GotIQ,The conditional expression  "iq.Query == null ||                  iq.Query.NamespaceURI != URI.ROSTER ||                  (iq.Type != IQType.result && iq.Type != IQType.set)"  is complex.
Complex Conditional,Jabber.Connection,XmppStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,ProcessFeatures,The conditional expression  "(bool)this[Options.AUTO_TLS] &&                  m_features.StartTLS != null &&                  !m_sslOn &&                  m_stanzas.SupportsTLS"  is complex.
Complex Conditional,Jabber.Connection,XmppStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,ProcessFeatures,The conditional expression  "(bool)this[Options.AUTO_COMPRESS] &&                  comp != null &&                  comp.HasMethod("zlib") &&                  !m_compressionOn &&                  m_stanzas.SupportsCompression"  is complex.
Complex Conditional,Jabber.Connection,XmppStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,FireOnError,The conditional expression  "(State == ClosingState.Instance || State == ClosedState.Instance) &&                  (e is IOException || e.InnerException is IOException)"  is complex.
Complex Conditional,StringPrep.Steps,NFKCStep,C:\repos\sgissinger_JabberNet-2010\Jabber\StringPrep\Steps\NFKCStep.cs,Comp,The conditional expression  "(i > 0) &&                      ((last_cc == 0) || (last_cc != cc)) &&                      Compose.Combine(result[last_start]' result[i]' out c)"  is complex.
Complex Conditional,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The conditional expression  "end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';')"  is complex.
Complex Conditional,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The conditional expression  "end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';')"  is complex.
Complex Conditional,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The conditional expression  "normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open)))"  is complex.
Empty Catch Block,Bedrock.Net,Address,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Address.cs,LookupTXT,The method has an empty catch block.
Empty Catch Block,Bedrock.Net,AsyncSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,Close,The method has an empty catch block.
Empty Catch Block,Bedrock.Net,XEP25Socket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,The method has an empty catch block.
Empty Catch Block,Jabber.Stun,StunClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,Jabber,JID,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\JID.cs,TryParse,The method has an empty catch block.
Empty Catch Block,Jabber.Protocol,AsynchElementStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The method has an empty catch block.
Empty Catch Block,Jabber.Protocol,AsynchElementStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The method has an empty catch block.
Magic Number,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,GETSHORT,The following statement contains a magic number: ushort s = (ushort)(((ushort)t_cp[0] << 8) | ((ushort)t_cp[1]));
Magic Number,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: byte[] buffer = new byte[1024];
Magic Number,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: byte[] name = new byte[256];
Magic Number,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: try              {                  HEADER header = (HEADER)Marshal.PtrToStructure(handle.AddrOfPinnedObject()' typeof(HEADER));                    int qdcount = ntohs(header.qdcount);                  int ancount = ntohs(header.ancount);                    int headerSize = Marshal.SizeOf(header);                    unsafe                  {                      fixed (byte* pBuffer = buffer)                      {                            byte* pos = pBuffer + headerSize;                          byte* end = pBuffer + size;                            // We don't care about the question section.                          while (qdcount-- > 0 && pos < end)                          {                              size = dn_expand(pBuffer' end' pos' name' 256);                              if (size < 0) return null;                              pos += size + 4;                          }                            // The answers' however' we do care about!                          while (ancount-- > 0 && pos < end)                          {                              size = dn_expand(pBuffer' end' pos' name' 256);                              if (size < 0) return null;                                pos += size;                                type = GETSHORT(ref pos);                                // Skip TTL                              pos += 6;                                dlen = GETSHORT(ref pos);                                if (type == T_SRV)                              {                                  priority = GETSHORT(ref pos);                                  weight = GETSHORT(ref pos);                                  port = GETSHORT(ref pos);                                    size = dn_expand(pBuffer' end' pos' name' 256);                                  if (size < 0) return null;                                    string nameStr = null;                                  fixed (byte* pName = name)                                  {                                      nameStr = new String((sbyte*)pName);                                  }                                    var record = new SRVRecord();                                  record.NameNext = nameStr;                                  record.Priority = priority;                                  record.Weight = weight;                                  record.Port = port;                                  results.Add(record);                                    pos += size;                              }                              else                              {                                  pos += dlen;                              }                          }                      }                  }                }              finally              {                  handle.Free();              }
Magic Number,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: try              {                  HEADER header = (HEADER)Marshal.PtrToStructure(handle.AddrOfPinnedObject()' typeof(HEADER));                    int qdcount = ntohs(header.qdcount);                  int ancount = ntohs(header.ancount);                    int headerSize = Marshal.SizeOf(header);                    unsafe                  {                      fixed (byte* pBuffer = buffer)                      {                            byte* pos = pBuffer + headerSize;                          byte* end = pBuffer + size;                            // We don't care about the question section.                          while (qdcount-- > 0 && pos < end)                          {                              size = dn_expand(pBuffer' end' pos' name' 256);                              if (size < 0) return null;                              pos += size + 4;                          }                            // The answers' however' we do care about!                          while (ancount-- > 0 && pos < end)                          {                              size = dn_expand(pBuffer' end' pos' name' 256);                              if (size < 0) return null;                                pos += size;                                type = GETSHORT(ref pos);                                // Skip TTL                              pos += 6;                                dlen = GETSHORT(ref pos);                                if (type == T_SRV)                              {                                  priority = GETSHORT(ref pos);                                  weight = GETSHORT(ref pos);                                  port = GETSHORT(ref pos);                                    size = dn_expand(pBuffer' end' pos' name' 256);                                  if (size < 0) return null;                                    string nameStr = null;                                  fixed (byte* pName = name)                                  {                                      nameStr = new String((sbyte*)pName);                                  }                                    var record = new SRVRecord();                                  record.NameNext = nameStr;                                  record.Priority = priority;                                  record.Weight = weight;                                  record.Port = port;                                  results.Add(record);                                    pos += size;                              }                              else                              {                                  pos += dlen;                              }                          }                      }                  }                }              finally              {                  handle.Free();              }
Magic Number,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: try              {                  HEADER header = (HEADER)Marshal.PtrToStructure(handle.AddrOfPinnedObject()' typeof(HEADER));                    int qdcount = ntohs(header.qdcount);                  int ancount = ntohs(header.ancount);                    int headerSize = Marshal.SizeOf(header);                    unsafe                  {                      fixed (byte* pBuffer = buffer)                      {                            byte* pos = pBuffer + headerSize;                          byte* end = pBuffer + size;                            // We don't care about the question section.                          while (qdcount-- > 0 && pos < end)                          {                              size = dn_expand(pBuffer' end' pos' name' 256);                              if (size < 0) return null;                              pos += size + 4;                          }                            // The answers' however' we do care about!                          while (ancount-- > 0 && pos < end)                          {                              size = dn_expand(pBuffer' end' pos' name' 256);                              if (size < 0) return null;                                pos += size;                                type = GETSHORT(ref pos);                                // Skip TTL                              pos += 6;                                dlen = GETSHORT(ref pos);                                if (type == T_SRV)                              {                                  priority = GETSHORT(ref pos);                                  weight = GETSHORT(ref pos);                                  port = GETSHORT(ref pos);                                    size = dn_expand(pBuffer' end' pos' name' 256);                                  if (size < 0) return null;                                    string nameStr = null;                                  fixed (byte* pName = name)                                  {                                      nameStr = new String((sbyte*)pName);                                  }                                    var record = new SRVRecord();                                  record.NameNext = nameStr;                                  record.Priority = priority;                                  record.Weight = weight;                                  record.Port = port;                                  results.Add(record);                                    pos += size;                              }                              else                              {                                  pos += dlen;                              }                          }                      }                  }                }              finally              {                  handle.Free();              }
Magic Number,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: try              {                  HEADER header = (HEADER)Marshal.PtrToStructure(handle.AddrOfPinnedObject()' typeof(HEADER));                    int qdcount = ntohs(header.qdcount);                  int ancount = ntohs(header.ancount);                    int headerSize = Marshal.SizeOf(header);                    unsafe                  {                      fixed (byte* pBuffer = buffer)                      {                            byte* pos = pBuffer + headerSize;                          byte* end = pBuffer + size;                            // We don't care about the question section.                          while (qdcount-- > 0 && pos < end)                          {                              size = dn_expand(pBuffer' end' pos' name' 256);                              if (size < 0) return null;                              pos += size + 4;                          }                            // The answers' however' we do care about!                          while (ancount-- > 0 && pos < end)                          {                              size = dn_expand(pBuffer' end' pos' name' 256);                              if (size < 0) return null;                                pos += size;                                type = GETSHORT(ref pos);                                // Skip TTL                              pos += 6;                                dlen = GETSHORT(ref pos);                                if (type == T_SRV)                              {                                  priority = GETSHORT(ref pos);                                  weight = GETSHORT(ref pos);                                  port = GETSHORT(ref pos);                                    size = dn_expand(pBuffer' end' pos' name' 256);                                  if (size < 0) return null;                                    string nameStr = null;                                  fixed (byte* pName = name)                                  {                                      nameStr = new String((sbyte*)pName);                                  }                                    var record = new SRVRecord();                                  record.NameNext = nameStr;                                  record.Priority = priority;                                  record.Weight = weight;                                  record.Port = port;                                  results.Add(record);                                    pos += size;                              }                              else                              {                                  pos += dlen;                              }                          }                      }                  }                }              finally              {                  handle.Free();              }
Magic Number,Bedrock.Net,UnixDnsResolver,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: try              {                  HEADER header = (HEADER)Marshal.PtrToStructure(handle.AddrOfPinnedObject()' typeof(HEADER));                    int qdcount = ntohs(header.qdcount);                  int ancount = ntohs(header.ancount);                    int headerSize = Marshal.SizeOf(header);                    unsafe                  {                      fixed (byte* pBuffer = buffer)                      {                            byte* pos = pBuffer + headerSize;                          byte* end = pBuffer + size;                            // We don't care about the question section.                          while (qdcount-- > 0 && pos < end)                          {                              size = dn_expand(pBuffer' end' pos' name' 256);                              if (size < 0) return null;                              pos += size + 4;                          }                            // The answers' however' we do care about!                          while (ancount-- > 0 && pos < end)                          {                              size = dn_expand(pBuffer' end' pos' name' 256);                              if (size < 0) return null;                                pos += size;                                type = GETSHORT(ref pos);                                // Skip TTL                              pos += 6;                                dlen = GETSHORT(ref pos);                                if (type == T_SRV)                              {                                  priority = GETSHORT(ref pos);                                  weight = GETSHORT(ref pos);                                  port = GETSHORT(ref pos);                                    size = dn_expand(pBuffer' end' pos' name' 256);                                  if (size < 0) return null;                                    string nameStr = null;                                  fixed (byte* pName = name)                                  {                                      nameStr = new String((sbyte*)pName);                                  }                                    var record = new SRVRecord();                                  record.NameNext = nameStr;                                  record.Priority = priority;                                  record.Weight = weight;                                  record.Port = port;                                  results.Add(record);                                    pos += size;                              }                              else                              {                                  pos += dlen;                              }                          }                      }                  }                }              finally              {                  handle.Free();              }
Magic Number,Bedrock.Net,AsyncSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,OnConnectResolved,The following statement contains a magic number: lock (this)              {                  if (State != SocketState.Resolving)                  {                      // closed in the mean time.   Probably not an error.                      return;                  }                  if ((addr == null) || (addr.IP == null) || (addr.Endpoint == null))                  {                      FireError(new AsyncSocketConnectionException("Bad host: " + addr.Hostname));                      return;                  }                      if (m_watcher != null)                      m_watcher.RegisterSocket(this);                    m_addr = addr;                  State = SocketState.Connecting;                    if (Socket.OSSupportsIPv6 && (m_addr.Endpoint.AddressFamily == AddressFamily.InterNetworkV6))                  {                      // Debug.WriteLine("ipv6");                      m_sock = new Socket(AddressFamily.InterNetworkV6'                          SocketType.Stream'                          ProtocolType.Tcp);                  }                  else                  {                      // Debug.WriteLine("ipv4");                      m_sock = new Socket(AddressFamily.InterNetwork'                          SocketType.Stream'                          ProtocolType.Tcp);                  }                    // well' of course this isn't right.                  m_sock.SetSocketOption(SocketOptionLevel.Socket'                      SocketOptionName.ReceiveBuffer'                      4 * m_buf.Length);              }
Magic Number,Bedrock.Net,AsyncSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,RequestRead,The following statement contains a magic number: try              {                  if (m_synch)                  {                      lock (this)                      {                          if (State != SocketState.Connected)                          {                              throw new InvalidOperationException("Socket not connected.");                          }                      }                        while (SyncRead())                      {                          ;                      }                      return;                  }                    lock (this)                  {                      if (m_reading)                      {                          throw new InvalidOperationException("Cannot call RequestRead while another read is pending.");                      }                      if (State != SocketState.Connected)                      {                          throw new InvalidOperationException("Socket not connected.");                      }                        m_reading = true;                  }                  m_stream.BeginRead(m_buf' 0' m_buf.Length' new AsyncCallback(GotData)' null);              }              catch (AuthenticationException)              {                  Close();                  // don't throw.  this gets caught elsewhere.              }              catch (SocketException e)              {                  Close();                    // 10053 = An established connection was aborted by the                  //         software in your host machine.                  // 10054 = An existing connection was forcibly closed                  //         by the remote host.                  if ((e.ErrorCode != 10053) &&                      (e.ErrorCode != 10054))                  {                      throw;                  }              }              catch (IOException)              {                  Close();              }              catch (Exception e)              {                  Debug.WriteLine("Exception in RequestRead: " + e.ToString());                  Close();                  throw e;              }
Magic Number,Bedrock.Net,AsyncSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,RequestRead,The following statement contains a magic number: try              {                  if (m_synch)                  {                      lock (this)                      {                          if (State != SocketState.Connected)                          {                              throw new InvalidOperationException("Socket not connected.");                          }                      }                        while (SyncRead())                      {                          ;                      }                      return;                  }                    lock (this)                  {                      if (m_reading)                      {                          throw new InvalidOperationException("Cannot call RequestRead while another read is pending.");                      }                      if (State != SocketState.Connected)                      {                          throw new InvalidOperationException("Socket not connected.");                      }                        m_reading = true;                  }                  m_stream.BeginRead(m_buf' 0' m_buf.Length' new AsyncCallback(GotData)' null);              }              catch (AuthenticationException)              {                  Close();                  // don't throw.  this gets caught elsewhere.              }              catch (SocketException e)              {                  Close();                    // 10053 = An established connection was aborted by the                  //         software in your host machine.                  // 10054 = An existing connection was forcibly closed                  //         by the remote host.                  if ((e.ErrorCode != 10053) &&                      (e.ErrorCode != 10054))                  {                      throw;                  }              }              catch (IOException)              {                  Close();              }              catch (Exception e)              {                  Debug.WriteLine("Exception in RequestRead: " + e.ToString());                  Close();                  throw e;              }
Magic Number,Bedrock.Net,AsyncSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,GotData,The following statement contains a magic number: try              {                  count = m_stream.EndRead(ar);              }              catch (SocketException e)              {                  AsyncClose();                    // closed in middle of read                  if (e.ErrorCode != 64)                  {                      FireError(e);                  }                  return;              }              catch (ObjectDisposedException)              {                  //object already disposed' just exit                  return;              }              catch (Exception e)              {                  AsyncClose();                  FireError(e);                  return;              }
Magic Number,Bedrock.Net,AsyncSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,Write,The following statement contains a magic number: lock (this)              {                  if (State != SocketState.Connected)                  {                      return;                      //throw new InvalidOperationException("Socket must be connected before writing.  Current state: " + State.ToString());                  }                    try                  {                      if (m_synch)                      {                          m_stream.Write(buf' offset' len);                          m_listener.OnWrite(this' buf' offset' len);                      }                      else                      {                            if (m_writing)                          {                              // already writing.  save this for later.                              m_pending.Write(buf' offset' len);                          }                          else                          {                              m_writing = true;                              // make copy' since we might be a while in async-land                              byte[] ret = new byte[len];                              Buffer.BlockCopy(buf' offset' ret' 0' len);                                m_stream.BeginWrite(ret' 0' ret.Length'                                                  new AsyncCallback(WroteData)'                                                  ret);                          }                      }                  }                  catch (SocketException e)                  {                      Close();                        // closed in middle of write                      if (e.ErrorCode != 10054)                      {                          FireError(e);                      }                      return;                  }                  catch (Exception e)                  {                      Close();                      FireError(e);                      return;                  }              }
Magic Number,Bedrock.Net,BaseSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\BaseSocket.cs,Accept,The following statement contains a magic number: Accept(addr' 5);
Magic Number,Bedrock.Net,HttpSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,Execute,The following statement contains a magic number: if (req.Method != null)              {                  lock (m_lock)                  {                      if (!Connected)                      {                          Connect(req.URI);                            Monitor.Wait(m_lock' (int)(m_connectRetrySec * 1000));                          if (!m_keepRunning)                              return;                            Debug.Assert(Connected);                          Debug.Assert(!IsPending);                      }                  }              }
Magic Number,Bedrock.Net,HttpSocket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,Send,The following statement contains a magic number: MemoryStream ms = new MemoryStream(req.Length + 256);
Magic Number,Bedrock.Net,ShttpProxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\ShttpProxy.cs,OnRead,The following statement contains a magic number: switch (m_state)              {              case States.WaitingForAuth:                  m_headerstream.Write(buf' offset' length);                  int state = 0;                  int line = 0;                  foreach (byte b in buf)                  {                      // Look for \r\n\r\n for end of response header                      switch (state)                      {                      case 0:                          if (b == '\r')                              state++;                          break;                      case 1:                          if (b == '\n')                          {                              byte[] hs = m_headerstream.ToArray();                              string s = System.Text.Encoding.UTF8.GetString(hs);                              Debug.Write("PRECV: " + s);                              m_headers.Add(s);                              m_headerstream.SetLength(0);                              state++;                              line++;                          }                          else                              state = 0;                          break;                      case 2:                          if (b == '\r')                              state++;                          else                              state = 0;                          break;                      case 3:                          if (b == '\n')                          {                              Debug.WriteLine("End of proxy headers");                              string line0 = (string)m_headers[0];                              if (line0.IndexOf("200") == -1)                              {                                  Debug.WriteLine("200 response not detected.  Closing.");                                  m_state = States.Error;                                  this.Close();                              }                              else                              {                                  Debug.WriteLine("Proxy connected");                                  m_listener.OnConnect(sock); // tell the real listener that we're connected.                                  m_state = States.Running;                              }                              // they'll call RequestRead()' so we can return false here.                              return false;                          }                          else                              state = 0;                          break;                      }                  }                  return true;              case States.Error:                  throw new InvalidOperationException("Cannot read after error");              default:                  return base.OnRead(sock' buf' offset' length);              }
Magic Number,Bedrock.Net,ShttpProxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\ShttpProxy.cs,OnRead,The following statement contains a magic number: switch (m_state)              {              case States.WaitingForAuth:                  m_headerstream.Write(buf' offset' length);                  int state = 0;                  int line = 0;                  foreach (byte b in buf)                  {                      // Look for \r\n\r\n for end of response header                      switch (state)                      {                      case 0:                          if (b == '\r')                              state++;                          break;                      case 1:                          if (b == '\n')                          {                              byte[] hs = m_headerstream.ToArray();                              string s = System.Text.Encoding.UTF8.GetString(hs);                              Debug.Write("PRECV: " + s);                              m_headers.Add(s);                              m_headerstream.SetLength(0);                              state++;                              line++;                          }                          else                              state = 0;                          break;                      case 2:                          if (b == '\r')                              state++;                          else                              state = 0;                          break;                      case 3:                          if (b == '\n')                          {                              Debug.WriteLine("End of proxy headers");                              string line0 = (string)m_headers[0];                              if (line0.IndexOf("200") == -1)                              {                                  Debug.WriteLine("200 response not detected.  Closing.");                                  m_state = States.Error;                                  this.Close();                              }                              else                              {                                  Debug.WriteLine("Proxy connected");                                  m_listener.OnConnect(sock); // tell the real listener that we're connected.                                  m_state = States.Running;                              }                              // they'll call RequestRead()' so we can return false here.                              return false;                          }                          else                              state = 0;                          break;                      }                  }                  return true;              case States.Error:                  throw new InvalidOperationException("Cannot read after error");              default:                  return base.OnRead(sock' buf' offset' length);              }
Magic Number,Bedrock.Net,SocketWatcher,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\SocketWatcher.cs,CreateListenSocket,The following statement contains a magic number: return CreateListenSocket(listener' addr' 5' SSL);
Magic Number,Bedrock.Net,SocketWatcher,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\SocketWatcher.cs,CreateListenSocket,The following statement contains a magic number: return CreateListenSocket(listener' addr' 5' false);
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,HandleRequestResponse,The following statement contains a magic number: if (reply != 90)              {                  Debug.WriteLine("request failed on proxy: " + reply);                  return false;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks4Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  IPHostEntry server = Dns.GetHostEntry(RemoteAddress.Hostname);                  IPAddress ip_addr = server.AddressList[0];                    byte[] addr = ip_addr.GetAddressBytes();                    int port = RemoteAddress.Port;                  byte [] buffer = new Byte[14];                  buffer[0] = 4;  // protocol version.                  buffer[1] = 1;  // connect.                  buffer[2] = (byte)(port >> 8);                  buffer[3] = (byte)port;                  // TODO: test byte order!                  buffer[4] = addr[3];                  buffer[5] = addr[2];                  buffer[6] = addr[1];                  buffer[7] = addr[0];                  buffer[8] = (byte)'i';                  buffer[9] = (byte)'d';                  buffer[10] = (byte)'e';                  buffer[11] = (byte)'n';                  buffer[12] = (byte)'t';                  buffer[13] = 0;                    /*                  +----+----+----+----+----+----+----+----+----+----+....+----+                  | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                  +----+----+----+----+----+----+----+----+----+----+....+----+      # of bytes:    1    1      2              4           variable       1                  */                      Write(buffer);                  RequestRead();                  m_state = States.RequestingProxy;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: byte [] buffer = new Byte[7 + n];
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[0] = 5;
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[2] = 0;
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[3] = 3;
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[3] = 3;
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[4] = (byte)n;
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: host.CopyTo(buffer' 5);
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[5+n] = (byte)(RemoteAddress.Port >> 8);
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[5+n] = (byte)(RemoteAddress.Port >> 8);
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[6+n] = (byte)RemoteAddress.Port;
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: if (ver != 5)              {                  Debug.WriteLine("bogus version  from proxy: " + ver);                  return false;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method)              {                  case 2:                      /*                       * +----+------+----------+------+----------+                       * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                       * +----+------+----------+------+----------+                       * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                       * +----+------+----------+------+----------+                       */                      m_state = States.WaitingForAuth;                      byte [] buffer = new Byte[3 + Username.Length + Password.Length];                      buffer[0] = 1; // version of this subnegotiation.                      buffer[1] = (byte)Username.Length;                      Encoding.ASCII.GetBytes(Username' 0' Username.Length' buffer' 2);                      int pw_offset = 2 + Username.Length;                      buffer[pw_offset] = (byte)Password.Length;                      Encoding.ASCII.GetBytes(Password' 0' Password.Length' buffer' pw_offset + 1);                      Debug.WriteLine("sending plain auth to proxy");                      Write(buffer);                      return true;                  case 0:                      RequestProxyConnection();                      return true;                  default:                      Debug.WriteLine("bogus auth method: " + method);                      return false;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method)              {                  case 2:                      /*                       * +----+------+----------+------+----------+                       * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                       * +----+------+----------+------+----------+                       * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                       * +----+------+----------+------+----------+                       */                      m_state = States.WaitingForAuth;                      byte [] buffer = new Byte[3 + Username.Length + Password.Length];                      buffer[0] = 1; // version of this subnegotiation.                      buffer[1] = (byte)Username.Length;                      Encoding.ASCII.GetBytes(Username' 0' Username.Length' buffer' 2);                      int pw_offset = 2 + Username.Length;                      buffer[pw_offset] = (byte)Password.Length;                      Encoding.ASCII.GetBytes(Password' 0' Password.Length' buffer' pw_offset + 1);                      Debug.WriteLine("sending plain auth to proxy");                      Write(buffer);                      return true;                  case 0:                      RequestProxyConnection();                      return true;                  default:                      Debug.WriteLine("bogus auth method: " + method);                      return false;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method)              {                  case 2:                      /*                       * +----+------+----------+------+----------+                       * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                       * +----+------+----------+------+----------+                       * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                       * +----+------+----------+------+----------+                       */                      m_state = States.WaitingForAuth;                      byte [] buffer = new Byte[3 + Username.Length + Password.Length];                      buffer[0] = 1; // version of this subnegotiation.                      buffer[1] = (byte)Username.Length;                      Encoding.ASCII.GetBytes(Username' 0' Username.Length' buffer' 2);                      int pw_offset = 2 + Username.Length;                      buffer[pw_offset] = (byte)Password.Length;                      Encoding.ASCII.GetBytes(Password' 0' Password.Length' buffer' pw_offset + 1);                      Debug.WriteLine("sending plain auth to proxy");                      Write(buffer);                      return true;                  case 0:                      RequestProxyConnection();                      return true;                  default:                      Debug.WriteLine("bogus auth method: " + method);                      return false;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method)              {                  case 2:                      /*                       * +----+------+----------+------+----------+                       * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                       * +----+------+----------+------+----------+                       * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                       * +----+------+----------+------+----------+                       */                      m_state = States.WaitingForAuth;                      byte [] buffer = new Byte[3 + Username.Length + Password.Length];                      buffer[0] = 1; // version of this subnegotiation.                      buffer[1] = (byte)Username.Length;                      Encoding.ASCII.GetBytes(Username' 0' Username.Length' buffer' 2);                      int pw_offset = 2 + Username.Length;                      buffer[pw_offset] = (byte)Password.Length;                      Encoding.ASCII.GetBytes(Password' 0' Password.Length' buffer' pw_offset + 1);                      Debug.WriteLine("sending plain auth to proxy");                      Write(buffer);                      return true;                  case 0:                      RequestProxyConnection();                      return true;                  default:                      Debug.WriteLine("bogus auth method: " + method);                      return false;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleRequestResponse,The following statement contains a magic number: if (ver != 5)              {                  Debug.WriteLine("bogus version in reply from proxy: " + ver);                  return false;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  byte [] buffer = new Byte[4];                  buffer[0] = 5; // protocol version.                  buffer[1] = 2; // number of methods.                  buffer[2] = 0; // no auth.                  buffer[3] = 2; // username password.                  Debug.WriteLine("sending auth methods to proxy...");                  Write(buffer);                  RequestRead();                  m_state = States.GettingMethods;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  byte [] buffer = new Byte[4];                  buffer[0] = 5; // protocol version.                  buffer[1] = 2; // number of methods.                  buffer[2] = 0; // no auth.                  buffer[3] = 2; // username password.                  Debug.WriteLine("sending auth methods to proxy...");                  Write(buffer);                  RequestRead();                  m_state = States.GettingMethods;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  byte [] buffer = new Byte[4];                  buffer[0] = 5; // protocol version.                  buffer[1] = 2; // number of methods.                  buffer[2] = 0; // no auth.                  buffer[3] = 2; // username password.                  Debug.WriteLine("sending auth methods to proxy...");                  Write(buffer);                  RequestRead();                  m_state = States.GettingMethods;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  byte [] buffer = new Byte[4];                  buffer[0] = 5; // protocol version.                  buffer[1] = 2; // number of methods.                  buffer[2] = 0; // no auth.                  buffer[3] = 2; // username password.                  Debug.WriteLine("sending auth methods to proxy...");                  Write(buffer);                  RequestRead();                  m_state = States.GettingMethods;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  byte [] buffer = new Byte[4];                  buffer[0] = 5; // protocol version.                  buffer[1] = 2; // number of methods.                  buffer[2] = 0; // no auth.                  buffer[3] = 2; // username password.                  Debug.WriteLine("sending auth methods to proxy...");                  Write(buffer);                  RequestRead();                  m_state = States.GettingMethods;              }
Magic Number,Bedrock.Net,Socks5Proxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting)              {                  byte [] buffer = new Byte[4];                  buffer[0] = 5; // protocol version.                  buffer[1] = 2; // number of methods.                  buffer[2] = 0; // no auth.                  buffer[3] = 2; // username password.                  Debug.WriteLine("sending auth methods to proxy...");                  Write(buffer);                  RequestRead();                  m_state = States.GettingMethods;              }
Magic Number,Bedrock.Net,XEP124Socket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP124Socket.cs,OnRead,The following statement contains a magic number: if (tok == XpNet.TOK.START_TAG_WITH_ATTS)              {                  // len(</body>) = 7                  start = ct.TokenEnd;                  if (m_listener.OnRead(this' buf' start' offset + length - start - 7))                      RequestRead();              }              else                  RequestRead();
Magic Number,Bedrock.Net,XEP25Socket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,GenKeys,The following statement contains a magic number: byte[] seed = new byte[32];
Magic Number,Bedrock.Net,XEP25Socket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,The following statement contains a magic number: CookieContainer cookies = new CookieContainer(5);
Magic Number,Bedrock.Net,XEP25Socket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,The following statement contains a magic number: byte[] readbuf = new byte[1024];
Magic Number,Bedrock.Net,XEP25Socket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,The following statement contains a magic number: while (m_running)              {                  lock (m_lock)                  {                      if (m_writeQ.Count == 0)                      {                          Monitor.Wait(m_lock' (int)(m_curPoll * 1000.0));                      }                  }                  // did we get closed?                  if (!m_running)                      break;                      if (m_id == null)                  {                      GenKeys();                      start = new WriteBuf(string.Format("0;{0}'"' m_keys[m_curKey]));                  }                  else                  {                      if (m_curKey == 0)                      {                          string k = m_keys[0];                          GenKeys();                          start = new WriteBuf(string.Format("{0};{1};{2}'"' m_id' k' m_keys[m_curKey]));                      }                      else                      {                          start = new WriteBuf(string.Format("{0};{1}'"' m_id' m_keys[m_curKey]));                      }                  }                  m_curKey--;                    ms.SetLength(0);                  int count = start.len;                  while (m_writeQ.Count > 0)                  {                      WriteBuf b = (WriteBuf) m_writeQ.Dequeue();                      count += b.len;                      ms.Write(b.buf' b.offset' b.len);                  }                POLL:                  req = (HttpWebRequest)WebRequest.Create(m_url);                  req.CookieContainer = cookies;                  req.ContentType     = CONTENT_TYPE;                  req.Method          = METHOD;                    if (m_cert != null)                      req.ClientCertificates.Add(m_cert);                    req.KeepAlive       = false;                    req.CachePolicy = new System.Net.Cache.HttpRequestCachePolicy(System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore);                  req.CachePolicy = new System.Net.Cache.HttpRequestCachePolicy(System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore);                    if (m_proxy != null)                      req.Proxy = m_proxy;                  req.ContentLength = count;                      try                  {                      ServicePointManager.ServerCertificateValidationCallback =                          ValidateRemoteCertificate;                        s = req.GetRequestStream();                      s.Write(start.buf' start.offset' start.len);                        m_remote_cert = req.ServicePoint.Certificate;                        buf = ms.ToArray();                      s.Write(buf' 0' buf.Length);                      s.Close();                        resp = (HttpWebResponse) req.GetResponse();                  }                  catch (WebException ex)                  {                      if (ex.Status != WebExceptionStatus.KeepAliveFailure)                      {                          m_listener.OnError(this' ex);                          return;                      }                      goto POLL;                  }                        if (resp.StatusCode != HttpStatusCode.OK)                  {                      m_listener.OnError(this' new WebException("Invalid HTTP return code: " + resp.StatusCode));                      return;                  }                    CookieCollection cc = resp.Cookies;                  Debug.Assert(cc != null);                    Cookie c = cc["ID"];                  if ((c == null) || (c.Value == null))                  {                      m_listener.OnError(this' new WebException("No ID cookie returned"));                      return;                  }                    if (m_id == null)                  {                      // if ID ends in :0' it's an error                      if (!c.Value.EndsWith(":0"))                          m_id = c.Value;                  }                    if (m_id != c.Value)                  {                      switch (c.Value)                      {                          case "0:0":                              m_listener.OnError(this' new XEP25Exception("Unknown XEP25 error"));                              return;                          case "-1:0":                              m_listener.OnError(this' new XEP25Exception("Server error"));                              return;                          case "-2:0":                              m_listener.OnError(this' new XEP25Exception("Bad request"));                              return;                          case "-3:0":                              m_listener.OnError(this' new XEP25Exception("Key sequence error"));                              return;                          default:                              m_listener.OnError(this' new WebException("ID cookie changed"));                              return;                      }                  }                    if (ms.Length > 0)                  {                      m_listener.OnWrite(this' buf' 0' buf.Length);                  }                    ms.SetLength(0);                  rs = resp.GetResponseStream();                      int readlen;                  while ((readlen = rs.Read(readbuf' 0' readbuf.Length)) > 0)                  {                      ms.Write(readbuf' 0' readlen);                  }                  rs.Close();                  if (ms.Length > 0)                  {                      buf = ms.ToArray();                        try                      {                          if (!m_listener.OnRead(this' buf' 0' buf.Length))                          {                              Close();                              return;                          }                      } catch (NullReferenceException)                      {}                      m_curPoll = m_minPoll;                  }                  else                  {                      m_curPoll *= 1.25;                      if (m_curPoll > m_maxPoll)                          m_curPoll = m_maxPoll;                  }              }
Magic Number,Bedrock.Net,XEP25Socket,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,The following statement contains a magic number: while (m_running)              {                  lock (m_lock)                  {                      if (m_writeQ.Count == 0)                      {                          Monitor.Wait(m_lock' (int)(m_curPoll * 1000.0));                      }                  }                  // did we get closed?                  if (!m_running)                      break;                      if (m_id == null)                  {                      GenKeys();                      start = new WriteBuf(string.Format("0;{0}'"' m_keys[m_curKey]));                  }                  else                  {                      if (m_curKey == 0)                      {                          string k = m_keys[0];                          GenKeys();                          start = new WriteBuf(string.Format("{0};{1};{2}'"' m_id' k' m_keys[m_curKey]));                      }                      else                      {                          start = new WriteBuf(string.Format("{0};{1}'"' m_id' m_keys[m_curKey]));                      }                  }                  m_curKey--;                    ms.SetLength(0);                  int count = start.len;                  while (m_writeQ.Count > 0)                  {                      WriteBuf b = (WriteBuf) m_writeQ.Dequeue();                      count += b.len;                      ms.Write(b.buf' b.offset' b.len);                  }                POLL:                  req = (HttpWebRequest)WebRequest.Create(m_url);                  req.CookieContainer = cookies;                  req.ContentType     = CONTENT_TYPE;                  req.Method          = METHOD;                    if (m_cert != null)                      req.ClientCertificates.Add(m_cert);                    req.KeepAlive       = false;                    req.CachePolicy = new System.Net.Cache.HttpRequestCachePolicy(System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore);                  req.CachePolicy = new System.Net.Cache.HttpRequestCachePolicy(System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore);                    if (m_proxy != null)                      req.Proxy = m_proxy;                  req.ContentLength = count;                      try                  {                      ServicePointManager.ServerCertificateValidationCallback =                          ValidateRemoteCertificate;                        s = req.GetRequestStream();                      s.Write(start.buf' start.offset' start.len);                        m_remote_cert = req.ServicePoint.Certificate;                        buf = ms.ToArray();                      s.Write(buf' 0' buf.Length);                      s.Close();                        resp = (HttpWebResponse) req.GetResponse();                  }                  catch (WebException ex)                  {                      if (ex.Status != WebExceptionStatus.KeepAliveFailure)                      {                          m_listener.OnError(this' ex);                          return;                      }                      goto POLL;                  }                        if (resp.StatusCode != HttpStatusCode.OK)                  {                      m_listener.OnError(this' new WebException("Invalid HTTP return code: " + resp.StatusCode));                      return;                  }                    CookieCollection cc = resp.Cookies;                  Debug.Assert(cc != null);                    Cookie c = cc["ID"];                  if ((c == null) || (c.Value == null))                  {                      m_listener.OnError(this' new WebException("No ID cookie returned"));                      return;                  }                    if (m_id == null)                  {                      // if ID ends in :0' it's an error                      if (!c.Value.EndsWith(":0"))                          m_id = c.Value;                  }                    if (m_id != c.Value)                  {                      switch (c.Value)                      {                          case "0:0":                              m_listener.OnError(this' new XEP25Exception("Unknown XEP25 error"));                              return;                          case "-1:0":                              m_listener.OnError(this' new XEP25Exception("Server error"));                              return;                          case "-2:0":                              m_listener.OnError(this' new XEP25Exception("Bad request"));                              return;                          case "-3:0":                              m_listener.OnError(this' new XEP25Exception("Key sequence error"));                              return;                          default:                              m_listener.OnError(this' new WebException("ID cookie changed"));                              return;                      }                  }                    if (ms.Length > 0)                  {                      m_listener.OnWrite(this' buf' 0' buf.Length);                  }                    ms.SetLength(0);                  rs = resp.GetResponseStream();                      int readlen;                  while ((readlen = rs.Read(readbuf' 0' readbuf.Length)) > 0)                  {                      ms.Write(readbuf' 0' readlen);                  }                  rs.Close();                  if (ms.Length > 0)                  {                      buf = ms.ToArray();                        try                      {                          if (!m_listener.OnRead(this' buf' 0' buf.Length))                          {                              Close();                              return;                          }                      } catch (NullReferenceException)                      {}                      m_curPoll = m_minPoll;                  }                  else                  {                      m_curPoll *= 1.25;                      if (m_curPoll > m_maxPoll)                          m_curPoll = m_maxPoll;                  }              }
Magic Number,Bedrock.Util,IdleTime,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\IdleTime.Designer.cs,GetIdleTime,The following statement contains a magic number: return (Environment.TickCount - lii.dwTime) / 1000.0;
Magic Number,Bedrock.Util,IdleTime,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\IdleTime.Designer.cs,IdleTime,The following statement contains a magic number: m_timer = new System.Timers.Timer(DEFAULT_POLL * 1000.0);
Magic Number,Bedrock.Util,GetOpt,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\GetOptBase.cs,Process,The following statement contains a magic number: for (i = 0; i < args.Length; i++)              {                  rm = FLAG_REGEX.Match(args[i]);                    if (!rm.Success)   // no more flags                      break;                    mi = m_flags[rm.Groups[1].ToString()] as MemberInfo;                    if (mi == null)                      throw new ArgumentException("Invalid command-line argument"' args[i]);                    mit = GetOpt.GetMemberType(mi);                    // methods return null types' for now.                  // TODO: should this be moved to SetValue?                  // Not sure what to do with bool params' then.                  if (mit == null)                  {                      String old_flag = args[i];                      MethodInfo meth = mi as MethodInfo;                      ParameterInfo[] pi = meth.GetParameters();                      Object[] parms = new Object[pi.Length];                        for (int j = 0; j < pi.Length; j++)                      {                          if (i + 1 >= args.Length)                              throw new IndexOutOfRangeException("Not enough parameters for: " + old_flag);                            parms[j] = this.ConvertValue(args[++i]' pi[j].ParameterType);                      }                        meth.Invoke(m_obj' parms);                  }                    // bool flags act as toggles                  else if (mit == typeof(Boolean))                  {                      this.SetValue(mi' !(Boolean)this.GetValue(mi));                  }                  else                  {                      // use the value after the colon' if it exists                      if (rm.Groups[3].Success)                      {                          this.SetValue(mi' rm.Groups[3].ToString());                      }                      else                      {                          if (i + 1 >= args.Length)                              throw new IndexOutOfRangeException("Not enough parameters for: " + args[i]);                            this.SetValue(mi' args[++i]);                      }                  }              }
Magic Number,Bedrock.Util,GetOpt,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\GetOptBase.cs,Process,The following statement contains a magic number: for (i = 0; i < args.Length; i++)              {                  rm = FLAG_REGEX.Match(args[i]);                    if (!rm.Success)   // no more flags                      break;                    mi = m_flags[rm.Groups[1].ToString()] as MemberInfo;                    if (mi == null)                      throw new ArgumentException("Invalid command-line argument"' args[i]);                    mit = GetOpt.GetMemberType(mi);                    // methods return null types' for now.                  // TODO: should this be moved to SetValue?                  // Not sure what to do with bool params' then.                  if (mit == null)                  {                      String old_flag = args[i];                      MethodInfo meth = mi as MethodInfo;                      ParameterInfo[] pi = meth.GetParameters();                      Object[] parms = new Object[pi.Length];                        for (int j = 0; j < pi.Length; j++)                      {                          if (i + 1 >= args.Length)                              throw new IndexOutOfRangeException("Not enough parameters for: " + old_flag);                            parms[j] = this.ConvertValue(args[++i]' pi[j].ParameterType);                      }                        meth.Invoke(m_obj' parms);                  }                    // bool flags act as toggles                  else if (mit == typeof(Boolean))                  {                      this.SetValue(mi' !(Boolean)this.GetValue(mi));                  }                  else                  {                      // use the value after the colon' if it exists                      if (rm.Groups[3].Success)                      {                          this.SetValue(mi' rm.Groups[3].ToString());                      }                      else                      {                          if (i + 1 >= args.Length)                              throw new IndexOutOfRangeException("Not enough parameters for: " + args[i]);                            this.SetValue(mi' args[++i]);                      }                  }              }
Magic Number,Bedrock.Util,GetOpt,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\GetOptBase.cs,UsageExit,The following statement contains a magic number: Environment.Exit(64);
Magic Number,Bedrock.Util,GetOpt,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\GetOptBase.cs,UsageGUIExit,The following statement contains a magic number: Environment.Exit(64);
Magic Number,Bedrock.Util,SourceSafeAttribute,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\Version.cs,Parse,The following statement contains a magic number: if (m.Groups["archive"].Success)              {                  m_archive = m.Groups["archive"].ToString();                  m_version = m.Groups["version"].ToString();                  m_date    = DateTime.Parse(m.Groups["date"].ToString());                  if (m.Groups["ampm"].ToString() == "p")                  {                      m_date = m_date.AddHours(12);                  }                  m_author  = m.Groups["author"].ToString();              }
Magic Number,Jabber.Client,JabberClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,Presence,The following statement contains a magic number: if (IsAuthenticated)              {                  if ((priority < -128) || (priority > 127))                  {                      throw new ArgumentException("Priority must be -128 to 127"' "priority");                  }                    Presence p = new Presence(Document);                  if (status != null)                      p.Status = status;                  if (t != PresenceType.available)                  {                      p.Type = t;                  }                  if (show != null)                      p.Show = show;                  p.Priority = priority.ToString();                    if (OnBeforePresenceOut != null)                      OnBeforePresenceOut(this' p);                  Write(p);                  if (OnAfterPresenceOut != null)                      OnAfterPresenceOut(this' p);              }              else              {                  throw new InvalidOperationException("Client must be authenticated before sending presence.");              }
Magic Number,Jabber.Client,JabberClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,Presence,The following statement contains a magic number: if (IsAuthenticated)              {                  if ((priority < -128) || (priority > 127))                  {                      throw new ArgumentException("Priority must be -128 to 127"' "priority");                  }                    Presence p = new Presence(Document);                  if (status != null)                      p.Status = status;                  if (t != PresenceType.available)                  {                      p.Type = t;                  }                  if (show != null)                      p.Show = show;                  p.Priority = priority.ToString();                    if (OnBeforePresenceOut != null)                      OnBeforePresenceOut(this' p);                  Write(p);                  if (OnAfterPresenceOut != null)                      OnAfterPresenceOut(this' p);              }              else              {                  throw new InvalidOperationException("Client must be authenticated before sending presence.");              }
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label1.Location = new System.Drawing.Point(12' 9);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label1.Location = new System.Drawing.Point(12' 9);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label1.Size = new System.Drawing.Size(77' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label1.Size = new System.Drawing.Size(77' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label1.TabIndex = 2;
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label2.Location = new System.Drawing.Point(12' 36);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label2.Location = new System.Drawing.Point(12' 36);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label2.Size = new System.Drawing.Size(63' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label2.Size = new System.Drawing.Size(63' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label2.TabIndex = 3;
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label3.Location = new System.Drawing.Point(12' 64);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label3.Location = new System.Drawing.Point(12' 64);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label3.Size = new System.Drawing.Size(55' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label3.Size = new System.Drawing.Size(55' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label3.TabIndex = 4;
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(0' 134);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(500' 44);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(500' 44);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(413' 9);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(413' 9);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 2;
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnAllow.Location = new System.Drawing.Point(332' 9);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnAllow.Location = new System.Drawing.Point(332' 9);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnAllow.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnAllow.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblSubject.Location = new System.Drawing.Point(126' 9);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblSubject.Location = new System.Drawing.Point(126' 9);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblSubject.Size = new System.Drawing.Size(43' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblSubject.Size = new System.Drawing.Size(43' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblSubject.TabIndex = 5;
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblBegin.Location = new System.Drawing.Point(126' 36);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblBegin.Location = new System.Drawing.Point(126' 36);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblBegin.Size = new System.Drawing.Size(34' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblBegin.Size = new System.Drawing.Size(34' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblBegin.TabIndex = 6;
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblEnd.Location = new System.Drawing.Point(126' 64);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblEnd.Location = new System.Drawing.Point(126' 64);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblEnd.Size = new System.Drawing.Size(26' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblEnd.Size = new System.Drawing.Size(26' 13);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblEnd.TabIndex = 7;
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Location = new System.Drawing.Point(14' 90);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Location = new System.Drawing.Point(14' 90);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.TabIndex = 8;
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(500' 178);
Magic Number,Jabber.Connection,CertificatePrompt,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(500' 178);
Magic Number,Jabber.Connection,PubSubManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\PubSubManager.Designer.cs,RemoveNode,The following statement contains a magic number: if (m_nodes.TryGetValue(jn' out psNode))              {                  m_nodes.Remove(jn);              }              else              {                  psNode = new PubSubNode(Stream' service' node' 10);              }
Magic Number,Jabber.Connection,BindingStanzaStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\BindingStanzaStream.cs,CreateSocket,The following statement contains a magic number: if (pt == ProxyType.HTTP)              {                  string host = m_listener[Options.PROXY_HOST] as string;                  int port = (int)m_listener[Options.PROXY_PORT];                    if (port == -1)                      port = 80;                    string proxy_uri = string.Format("http://{0}:{1}/"' host' port);                  sock.ProxyURI = new System.Uri(proxy_uri);                    string user = m_listener[Options.PROXY_USER] as string;                    if (!String.IsNullOrEmpty(user))                  {                      sock.ProxyCredentials = new System.Net.NetworkCredential(user' m_listener[Options.PROXY_PW] as string);                  }              }
Magic Number,Jabber.Connection,SocketStanzaStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SocketStanzaStream.cs,DoKeepAlive,The following statement contains a magic number: if ((m_sock != null) && this.Connected && ((int)m_listener[Options.CURRENT_KEEP_ALIVE] > 0))                  m_sock.Write(new byte[] { 32 });
Magic Number,Jabber.Protocol.IQ,JingleIce,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Debug.Assert(port > 1024);
Magic Number,Jabber.Protocol.IQ,JingleIce,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Protocol.IQ,JingleIce,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Protocol.IQ,JingleIce,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Protocol.IQ,JingleIce,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Protocol.IQ,JingleIce,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Protocol.IQ,JingleIce,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Stun.Attributes,MappedAddress,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\Attributes\AddressAttributes.cs,MappedAddress,The following statement contains a magic number: if (endPoint.AddressFamily == AddressFamily.InterNetwork)                  this.Value = new byte[8];              else if (endPoint.AddressFamily == AddressFamily.InterNetworkV6)                  this.Value = new byte[20];
Magic Number,Jabber.Stun.Attributes,MappedAddress,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\Attributes\AddressAttributes.cs,MappedAddress,The following statement contains a magic number: if (endPoint.AddressFamily == AddressFamily.InterNetwork)                  this.Value = new byte[8];              else if (endPoint.AddressFamily == AddressFamily.InterNetworkV6)                  this.Value = new byte[20];
Magic Number,Jabber.Stun.Attributes,XorMappedAddress,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\Attributes\AddressAttributes.cs,XorMappedAddress,The following statement contains a magic number: if (endPoint.AddressFamily == AddressFamily.InterNetwork)                  this.Value = new byte[8];              else if (endPoint.AddressFamily == AddressFamily.InterNetworkV6)                  throw new NotImplementedException();
Magic Number,Jabber.Stun.Attributes,UnknownAttributes,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\Attributes\UnknownAttributes.cs,UnknownAttributes,The following statement contains a magic number: while (offset < this.ValueLength)              {                  byte[] unknownAttrBytes = StunUtilities.SubArray(this.Value' offset' 2);                  UInt16 unknownAttrValue = StunUtilities.ReverseBytes(BitConverter.ToUInt16(unknownAttrBytes' 0));                    this.attributes.Add(unknownAttrValue);                    offset += 2;              }
Magic Number,Jabber.Stun.Attributes,UnknownAttributes,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\Attributes\UnknownAttributes.cs,UnknownAttributes,The following statement contains a magic number: while (offset < this.ValueLength)              {                  byte[] unknownAttrBytes = StunUtilities.SubArray(this.Value' offset' 2);                  UInt16 unknownAttrValue = StunUtilities.ReverseBytes(BitConverter.ToUInt16(unknownAttrBytes' 0));                    this.attributes.Add(unknownAttrValue);                    offset += 2;              }
Magic Number,Jabber.Stun,HolePuncher,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\HolePuncher.cs,TcpPunchThreadStart,The following statement contains a magic number: foreach (IPEndPoint peerEP in this.PeersEP)              {                  Int32 nbTries = 0;                  Boolean quit = false;                    try                  {                      while (!quit)                      {                          nbTries++;                            client = new TcpClient();                            client.Client.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.ReuseAddress' 1);                            if (this.HostEP != null)                              client.Client.Bind(this.HostEP);                            IAsyncResult result = client.Client.BeginConnect(peerEP.Address' peerEP.Port' null' null);                            result.AsyncWaitHandle.WaitOne(3000' true);                            if (nbTries == 3 || client.Client.Connected)                              quit = true;                            client.Client.Close();                      }                  }                  catch (Exception)                  {                      quit = true;                      client = null;                  }                    if (quit)                      break;              }
Magic Number,Jabber.Stun,HolePuncher,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\HolePuncher.cs,TcpPunchThreadStart,The following statement contains a magic number: foreach (IPEndPoint peerEP in this.PeersEP)              {                  Int32 nbTries = 0;                  Boolean quit = false;                    try                  {                      while (!quit)                      {                          nbTries++;                            client = new TcpClient();                            client.Client.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.ReuseAddress' 1);                            if (this.HostEP != null)                              client.Client.Bind(this.HostEP);                            IAsyncResult result = client.Client.BeginConnect(peerEP.Address' peerEP.Port' null' null);                            result.AsyncWaitHandle.WaitOne(3000' true);                            if (nbTries == 3 || client.Client.Connected)                              quit = true;                            client.Client.Close();                      }                  }                  catch (Exception)                  {                      quit = true;                      client = null;                  }                    if (quit)                      break;              }
Magic Number,Jabber.Stun,StunAttribute,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunAttribute.cs,StunAttribute,The following statement contains a magic number: switch (type)              {                  case StunAttributeType.Software:                  case StunAttributeType.Realm:                  case StunAttributeType.Nonce:                  case StunAttributeType.ErrorCode:                      if (value.Length > 763)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 763 bytes for the given type as described in RFC 5389");                      break;                    case StunAttributeType.Username:                      if (value.Length > 513)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 513 bytes for the given type as described in RFC 5389");                      break;              }
Magic Number,Jabber.Stun,StunAttribute,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunAttribute.cs,StunAttribute,The following statement contains a magic number: switch (type)              {                  case StunAttributeType.Software:                  case StunAttributeType.Realm:                  case StunAttributeType.Nonce:                  case StunAttributeType.ErrorCode:                      if (value.Length > 763)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 763 bytes for the given type as described in RFC 5389");                      break;                    case StunAttributeType.Username:                      if (value.Length > 513)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 513 bytes for the given type as described in RFC 5389");                      break;              }
Magic Number,Jabber.Stun,StunMessage,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ComputeHMAC,The following statement contains a magic number: using (HMACSHA1 hmacSha1 = new HMACSHA1(hmacSha1Key))              {                  StunMessage thisCopy = new StunMessage(this.MethodType' this.MethodClass' this.TransactionID);                    foreach (var item in this.attributesList)                  {                      if (item.Key == StunAttributeType.MessageIntegrity)                          break;                        thisCopy.SetAttribute(item.Value);                  }                    if (this.Stun.FingerPrint != null)                      thisCopy.SetAttribute(this.Stun.FingerPrint);                    byte[] thisCopyBytes = thisCopy;                    // Insert a fake message length for HMAC computation as described in [RFC5489#15.4]                  UInt16 dummyLength = StunUtilities.ReverseBytes((UInt16)(thisCopy.MessageLength + 24)); // 20 hmac + 4 header                    BitConverter.GetBytes(dummyLength).CopyTo(thisCopyBytes' 2);                    hashed = hmacSha1.ComputeHash(thisCopyBytes);              }
Magic Number,Jabber.Stun,StunMessage,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ComputeHMAC,The following statement contains a magic number: using (HMACSHA1 hmacSha1 = new HMACSHA1(hmacSha1Key))              {                  StunMessage thisCopy = new StunMessage(this.MethodType' this.MethodClass' this.TransactionID);                    foreach (var item in this.attributesList)                  {                      if (item.Key == StunAttributeType.MessageIntegrity)                          break;                        thisCopy.SetAttribute(item.Value);                  }                    if (this.Stun.FingerPrint != null)                      thisCopy.SetAttribute(this.Stun.FingerPrint);                    byte[] thisCopyBytes = thisCopy;                    // Insert a fake message length for HMAC computation as described in [RFC5489#15.4]                  UInt16 dummyLength = StunUtilities.ReverseBytes((UInt16)(thisCopy.MessageLength + 24)); // 20 hmac + 4 header                    BitConverter.GetBytes(dummyLength).CopyTo(thisCopyBytes' 2);                    hashed = hmacSha1.ComputeHash(thisCopyBytes);              }
Magic Number,Jabber.Stun,StunMessage,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: while (offset < attributesLength)              {                  // We retrieve length and add it attribute header length (4 bytes)                  UInt16 valueLength = BitConverter.ToUInt16(StunUtilities.SubArray(attributes' offset + 2' 2)' 0);                  UInt16 attributeLength = (UInt16)(StunUtilities.ReverseBytes(valueLength) + 4);                    // Adjust original length to a padded 32bit length                  if (attributeLength % 4 != 0)                      attributeLength = (UInt16)(attributeLength + (4 - attributeLength % 4));                    StunAttribute attr = StunUtilities.SubArray(attributes' offset' attributeLength);                    // When doing auto conversion of a byte array' according to STUN RFC 5389                   // only the first attribute of a given type must be taken into account                  this.SetAttribute(attr' false);                    offset += attributeLength;              }
Magic Number,Jabber.Stun,StunMessage,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: while (offset < attributesLength)              {                  // We retrieve length and add it attribute header length (4 bytes)                  UInt16 valueLength = BitConverter.ToUInt16(StunUtilities.SubArray(attributes' offset + 2' 2)' 0);                  UInt16 attributeLength = (UInt16)(StunUtilities.ReverseBytes(valueLength) + 4);                    // Adjust original length to a padded 32bit length                  if (attributeLength % 4 != 0)                      attributeLength = (UInt16)(attributeLength + (4 - attributeLength % 4));                    StunAttribute attr = StunUtilities.SubArray(attributes' offset' attributeLength);                    // When doing auto conversion of a byte array' according to STUN RFC 5389                   // only the first attribute of a given type must be taken into account                  this.SetAttribute(attr' false);                    offset += attributeLength;              }
Magic Number,Jabber.Stun,StunMessage,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: while (offset < attributesLength)              {                  // We retrieve length and add it attribute header length (4 bytes)                  UInt16 valueLength = BitConverter.ToUInt16(StunUtilities.SubArray(attributes' offset + 2' 2)' 0);                  UInt16 attributeLength = (UInt16)(StunUtilities.ReverseBytes(valueLength) + 4);                    // Adjust original length to a padded 32bit length                  if (attributeLength % 4 != 0)                      attributeLength = (UInt16)(attributeLength + (4 - attributeLength % 4));                    StunAttribute attr = StunUtilities.SubArray(attributes' offset' attributeLength);                    // When doing auto conversion of a byte array' according to STUN RFC 5389                   // only the first attribute of a given type must be taken into account                  this.SetAttribute(attr' false);                    offset += attributeLength;              }
Magic Number,Jabber.Stun,StunMessage,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: while (offset < attributesLength)              {                  // We retrieve length and add it attribute header length (4 bytes)                  UInt16 valueLength = BitConverter.ToUInt16(StunUtilities.SubArray(attributes' offset + 2' 2)' 0);                  UInt16 attributeLength = (UInt16)(StunUtilities.ReverseBytes(valueLength) + 4);                    // Adjust original length to a padded 32bit length                  if (attributeLength % 4 != 0)                      attributeLength = (UInt16)(attributeLength + (4 - attributeLength % 4));                    StunAttribute attr = StunUtilities.SubArray(attributes' offset' attributeLength);                    // When doing auto conversion of a byte array' according to STUN RFC 5389                   // only the first attribute of a given type must be taken into account                  this.SetAttribute(attr' false);                    offset += attributeLength;              }
Magic Number,Jabber.Stun,StunMessage,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: while (offset < attributesLength)              {                  // We retrieve length and add it attribute header length (4 bytes)                  UInt16 valueLength = BitConverter.ToUInt16(StunUtilities.SubArray(attributes' offset + 2' 2)' 0);                  UInt16 attributeLength = (UInt16)(StunUtilities.ReverseBytes(valueLength) + 4);                    // Adjust original length to a padded 32bit length                  if (attributeLength % 4 != 0)                      attributeLength = (UInt16)(attributeLength + (4 - attributeLength % 4));                    StunAttribute attr = StunUtilities.SubArray(attributes' offset' attributeLength);                    // When doing auto conversion of a byte array' according to STUN RFC 5389                   // only the first attribute of a given type must be taken into account                  this.SetAttribute(attr' false);                    offset += attributeLength;              }
Magic Number,Jabber.Stun,StunMessage,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: while (offset < attributesLength)              {                  // We retrieve length and add it attribute header length (4 bytes)                  UInt16 valueLength = BitConverter.ToUInt16(StunUtilities.SubArray(attributes' offset + 2' 2)' 0);                  UInt16 attributeLength = (UInt16)(StunUtilities.ReverseBytes(valueLength) + 4);                    // Adjust original length to a padded 32bit length                  if (attributeLength % 4 != 0)                      attributeLength = (UInt16)(attributeLength + (4 - attributeLength % 4));                    StunAttribute attr = StunUtilities.SubArray(attributes' offset' attributeLength);                    // When doing auto conversion of a byte array' according to STUN RFC 5389                   // only the first attribute of a given type must be taken into account                  this.SetAttribute(attr' false);                    offset += attributeLength;              }
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,PadTo32Bits,The following statement contains a magic number: Int32 neededPadding = value.Length % 4;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,PadTo32Bits,The following statement contains a magic number: switch (neededPadding)              {                  case 0:                  default:                      return value;                    case 1:                      result = new byte[value.Length + 3];                        value.CopyTo(result' 0);                      new byte[] { 0' 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 2:                      result = new byte[value.Length + 2];                        value.CopyTo(result' 0);                      new byte[] { 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 3:                      result = new byte[value.Length + 1];                        value.CopyTo(result' 0);                      new byte[] { 0 }.CopyTo(result' value.Length);                        return result;              }
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,PadTo32Bits,The following statement contains a magic number: switch (neededPadding)              {                  case 0:                  default:                      return value;                    case 1:                      result = new byte[value.Length + 3];                        value.CopyTo(result' 0);                      new byte[] { 0' 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 2:                      result = new byte[value.Length + 2];                        value.CopyTo(result' 0);                      new byte[] { 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 3:                      result = new byte[value.Length + 1];                        value.CopyTo(result' 0);                      new byte[] { 0 }.CopyTo(result' value.Length);                        return result;              }
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,PadTo32Bits,The following statement contains a magic number: switch (neededPadding)              {                  case 0:                  default:                      return value;                    case 1:                      result = new byte[value.Length + 3];                        value.CopyTo(result' 0);                      new byte[] { 0' 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 2:                      result = new byte[value.Length + 2];                        value.CopyTo(result' 0);                      new byte[] { 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 3:                      result = new byte[value.Length + 1];                        value.CopyTo(result' 0);                      new byte[] { 0 }.CopyTo(result' value.Length);                        return result;              }
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,PadTo32Bits,The following statement contains a magic number: switch (neededPadding)              {                  case 0:                  default:                      return value;                    case 1:                      result = new byte[value.Length + 3];                        value.CopyTo(result' 0);                      new byte[] { 0' 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 2:                      result = new byte[value.Length + 2];                        value.CopyTo(result' 0);                      new byte[] { 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 3:                      result = new byte[value.Length + 1];                        value.CopyTo(result' 0);                      new byte[] { 0 }.CopyTo(result' value.Length);                        return result;              }
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (UInt16)((value & 0xFFU) << 8 | (value & 0xFF00U) >> 8);
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (UInt16)((value & 0xFFU) << 8 | (value & 0xFF00U) >> 8);
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |                     (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |                     (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |                     (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |                     (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,TurnManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,StunClient_OnReceivedSuccessResponse,The following statement contains a magic number: switch (receivedMsg.MethodType)              {                  case StunMethodType.Allocate:                      TurnAllocation allocation = new TurnAllocation()                      {                          Username = sentMsg.Stun.Username.ValueString'                          Password = transactionObject as String'                          Realm = sentMsg.Stun.Realm.ValueString'                          Nonce = sentMsg.Stun.Nonce.ValueString'                          RelayedMappedAddress = receivedMsg.Turn.XorRelayedAddress'                          MappedAddress = receivedMsg.Stun.XorMappedAddress'                          StartTime = DateTime.Now'                          LifeTime = StunUtilities.ReverseBytes(BitConverter.ToUInt32(receivedMsg.Turn.LifeTime.Value' 0))                      };                        if (this.Allocations.ContainsKey(receivedMsg.Turn.XorRelayedAddress))                          this.Allocations[receivedMsg.Turn.XorRelayedAddress] = allocation;                      else                      {                          this.Allocations.Add(receivedMsg.Turn.XorRelayedAddress' allocation);                            if (this.OnAllocateSucceed != null)                              this.OnAllocateSucceed(this' allocation' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.CreatePermission:                      TurnPermission permission = new TurnPermission()                      {                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 300                      };                      TurnAllocation permAllocation = transactionObject as TurnAllocation;                        if (permAllocation.Permissions.ContainsKey(sentMsg.Turn.XorPeerAddress))                          permAllocation.Permissions[sentMsg.Turn.XorPeerAddress] = permission;                      else                      {                          permAllocation.Permissions.Add(sentMsg.Turn.XorPeerAddress' permission);                            if (this.OnCreatePermissionSucceed != null)                              this.OnCreatePermissionSucceed(this' permAllocation' permission' sentMsg' receivedMsg);                      }                        break;                    case StunMethodType.ChannelBind:                      TurnChannel channel = new TurnChannel()                      {                          Channel = sentMsg.Turn.ChannelNumber'                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 600                      };                      TurnAllocation channelAllocation = transactionObject as TurnAllocation;                        if (channelAllocation.Channels.ContainsKey(sentMsg.Turn.ChannelNumber))                          channelAllocation.Channels[sentMsg.Turn.ChannelNumber] = channel;                      else                      {                          channelAllocation.Channels.Add(sentMsg.Turn.ChannelNumber' channel);                            if (this.OnChannelBindSucceed != null)                              this.OnChannelBindSucceed(this' transactionObject as TurnAllocation' channel' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.ConnectionBind:                      if (this.OnConnectionBindSucceed != null)                          this.OnConnectionBindSucceed(this' transactionObject as Socket' receivedMsg);                      break;              }
Magic Number,Jabber.Stun,TurnManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,StunClient_OnReceivedSuccessResponse,The following statement contains a magic number: switch (receivedMsg.MethodType)              {                  case StunMethodType.Allocate:                      TurnAllocation allocation = new TurnAllocation()                      {                          Username = sentMsg.Stun.Username.ValueString'                          Password = transactionObject as String'                          Realm = sentMsg.Stun.Realm.ValueString'                          Nonce = sentMsg.Stun.Nonce.ValueString'                          RelayedMappedAddress = receivedMsg.Turn.XorRelayedAddress'                          MappedAddress = receivedMsg.Stun.XorMappedAddress'                          StartTime = DateTime.Now'                          LifeTime = StunUtilities.ReverseBytes(BitConverter.ToUInt32(receivedMsg.Turn.LifeTime.Value' 0))                      };                        if (this.Allocations.ContainsKey(receivedMsg.Turn.XorRelayedAddress))                          this.Allocations[receivedMsg.Turn.XorRelayedAddress] = allocation;                      else                      {                          this.Allocations.Add(receivedMsg.Turn.XorRelayedAddress' allocation);                            if (this.OnAllocateSucceed != null)                              this.OnAllocateSucceed(this' allocation' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.CreatePermission:                      TurnPermission permission = new TurnPermission()                      {                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 300                      };                      TurnAllocation permAllocation = transactionObject as TurnAllocation;                        if (permAllocation.Permissions.ContainsKey(sentMsg.Turn.XorPeerAddress))                          permAllocation.Permissions[sentMsg.Turn.XorPeerAddress] = permission;                      else                      {                          permAllocation.Permissions.Add(sentMsg.Turn.XorPeerAddress' permission);                            if (this.OnCreatePermissionSucceed != null)                              this.OnCreatePermissionSucceed(this' permAllocation' permission' sentMsg' receivedMsg);                      }                        break;                    case StunMethodType.ChannelBind:                      TurnChannel channel = new TurnChannel()                      {                          Channel = sentMsg.Turn.ChannelNumber'                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 600                      };                      TurnAllocation channelAllocation = transactionObject as TurnAllocation;                        if (channelAllocation.Channels.ContainsKey(sentMsg.Turn.ChannelNumber))                          channelAllocation.Channels[sentMsg.Turn.ChannelNumber] = channel;                      else                      {                          channelAllocation.Channels.Add(sentMsg.Turn.ChannelNumber' channel);                            if (this.OnChannelBindSucceed != null)                              this.OnChannelBindSucceed(this' transactionObject as TurnAllocation' channel' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.ConnectionBind:                      if (this.OnConnectionBindSucceed != null)                          this.OnConnectionBindSucceed(this' transactionObject as Socket' receivedMsg);                      break;              }
Magic Number,Jabber.Stun,TurnAllocation,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnObjects.cs,StartAutoRefresh,The following statement contains a magic number: this.refreshTimer.Interval = (this.LifeTime * 1000) - 60000;
Magic Number,Jabber.Stun,TurnAllocation,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnObjects.cs,StartAutoRefresh,The following statement contains a magic number: this.refreshTimer.Interval = (this.LifeTime * 1000) - 60000;
Magic Number,Jabber.Stun,TurnAllocation,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnObjects.cs,AutoRefresh,The following statement contains a magic number: this.refreshTimer.Interval = (this.LifeTime * 1000) - 60000;
Magic Number,Jabber.Stun,TurnAllocation,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnObjects.cs,AutoRefresh,The following statement contains a magic number: this.refreshTimer.Interval = (this.LifeTime * 1000) - 60000;
Magic Number,Bedrock.Collections,LinkedList,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Collections\LinkedList.cs,GetNode,The following statement contains a magic number: if (index < m_size/2)              {                  for (int i = 0; i <= index; i++)                      e = e.next;              }              else              {                  for (int i = m_size; i > index; i--)                      e = e.previous;              }
Magic Number,Jabber.Connection.SASL,MD5Processor,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\MD5Processor.cs,generateResponseString,The following statement contains a magic number: int v = r.Next(1024);
Magic Number,Jabber.Connection.SASL,MD5Processor,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\MD5Processor.cs,generateResponseString,The following statement contains a magic number: m_ncString = m_nc.ToString().PadLeft(8''0');
Magic Number,Jabber.Connection.SASL,MD5Processor,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\MD5Processor.cs,generateResponseString,The following statement contains a magic number: ms.Write(H1'0'16);
Magic Number,Jabber.Protocol,AsynchElementStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: try              {                  while (off < b.Length)                  {                          if (m_cdata)                          tok = m_enc.tokenizeCdataSection(b' off' b.Length' ct);                      else                          tok = m_enc.tokenizeContent(b' off' b.Length' ct);                        switch (tok)                      {                      case TOK.EMPTY_ELEMENT_NO_ATTS:                      case TOK.EMPTY_ELEMENT_WITH_ATTS:                          StartTag(b' off' ct' tok);                          EndTag(b' off' ct' tok);                          break;                      case TOK.START_TAG_NO_ATTS:                      case TOK.START_TAG_WITH_ATTS:                          StartTag(b' off' ct' tok);                          break;                      case TOK.END_TAG:                          EndTag(b' off' ct' tok);                          break;                      case TOK.DATA_CHARS:                      case TOK.DATA_NEWLINE:                          AddText(utf.GetString(b' off' ct.TokenEnd - off));                          break;                      case TOK.CHAR_REF:                      case TOK.MAGIC_ENTITY_REF:                          AddText(new string(new char[] { ct.RefChar1 }));                          break;                      case TOK.CHAR_PAIR_REF:                          AddText(new string(new char[] {ct.RefChar1'                                                                ct.RefChar2}));                          break;                      case TOK.COMMENT:                          if (m_elem != null)                          {                              // <!-- 4                              //  --> 3                              int start = off + 4*m_enc.MinBytesPerChar;                              int end = ct.TokenEnd - off -                                      7*m_enc.MinBytesPerChar;                              string text = utf.GetString(b' start' end);                              m_elem.AppendChild(m_doc.CreateComment(text));                          }                          break;                      case TOK.CDATA_SECT_OPEN:                          m_cdata = true;                          break;                      case TOK.CDATA_SECT_CLOSE:                          m_cdata = false;                          break;                      case TOK.XML_DECL:                          // thou shalt use UTF8' and XML version 1.                          // i shall ignore evidence to the contrary...                            // TODO: Throw an exception if these assuptions are                          // wrong                          break;                      case TOK.ENTITY_REF:                      case TOK.PI:                          throw new System.NotImplementedException("Token type not implemented: " + tok);                      }                      off = ct.TokenEnd;                      ct.clearAttributes();                  }              }              catch (PartialTokenException)              {                  // Console.WriteLine("PartialTokenException: " + System.Text.Encoding.UTF8.GetString(copy));                  // ignored;              }              catch (ExtensibleTokenException)              {                  // ignored;              }              catch (XpNet.InvalidTokenException e)              {                  throw new XMLParseException(e' this' buf' offset' length);              }              catch (Exception e)              {                  throw new Exception("Unexpected exception"' e);              }              finally              {                  m_buf.Clear(off);                  ct.clearAttributes();              }
Magic Number,Jabber.Protocol,AsynchElementStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: try              {                  while (off < b.Length)                  {                          if (m_cdata)                          tok = m_enc.tokenizeCdataSection(b' off' b.Length' ct);                      else                          tok = m_enc.tokenizeContent(b' off' b.Length' ct);                        switch (tok)                      {                      case TOK.EMPTY_ELEMENT_NO_ATTS:                      case TOK.EMPTY_ELEMENT_WITH_ATTS:                          StartTag(b' off' ct' tok);                          EndTag(b' off' ct' tok);                          break;                      case TOK.START_TAG_NO_ATTS:                      case TOK.START_TAG_WITH_ATTS:                          StartTag(b' off' ct' tok);                          break;                      case TOK.END_TAG:                          EndTag(b' off' ct' tok);                          break;                      case TOK.DATA_CHARS:                      case TOK.DATA_NEWLINE:                          AddText(utf.GetString(b' off' ct.TokenEnd - off));                          break;                      case TOK.CHAR_REF:                      case TOK.MAGIC_ENTITY_REF:                          AddText(new string(new char[] { ct.RefChar1 }));                          break;                      case TOK.CHAR_PAIR_REF:                          AddText(new string(new char[] {ct.RefChar1'                                                                ct.RefChar2}));                          break;                      case TOK.COMMENT:                          if (m_elem != null)                          {                              // <!-- 4                              //  --> 3                              int start = off + 4*m_enc.MinBytesPerChar;                              int end = ct.TokenEnd - off -                                      7*m_enc.MinBytesPerChar;                              string text = utf.GetString(b' start' end);                              m_elem.AppendChild(m_doc.CreateComment(text));                          }                          break;                      case TOK.CDATA_SECT_OPEN:                          m_cdata = true;                          break;                      case TOK.CDATA_SECT_CLOSE:                          m_cdata = false;                          break;                      case TOK.XML_DECL:                          // thou shalt use UTF8' and XML version 1.                          // i shall ignore evidence to the contrary...                            // TODO: Throw an exception if these assuptions are                          // wrong                          break;                      case TOK.ENTITY_REF:                      case TOK.PI:                          throw new System.NotImplementedException("Token type not implemented: " + tok);                      }                      off = ct.TokenEnd;                      ct.clearAttributes();                  }              }              catch (PartialTokenException)              {                  // Console.WriteLine("PartialTokenException: " + System.Text.Encoding.UTF8.GetString(copy));                  // ignored;              }              catch (ExtensibleTokenException)              {                  // ignored;              }              catch (XpNet.InvalidTokenException e)              {                  throw new XMLParseException(e' this' buf' offset' length);              }              catch (Exception e)              {                  throw new Exception("Unexpected exception"' e);              }              finally              {                  m_buf.Clear(off);                  ct.clearAttributes();              }
Magic Number,Jabber.Protocol,AsynchElementStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,EndTag,The following statement contains a magic number: if ((tok == TOK.EMPTY_ELEMENT_WITH_ATTS) ||                  (tok == TOK.EMPTY_ELEMENT_NO_ATTS))                  name = utf.GetString(buf'                                       offset + m_enc.MinBytesPerChar'                                       ct.NameEnd - offset -                                       m_enc.MinBytesPerChar);              else                  name = utf.GetString(buf'                                       offset + m_enc.MinBytesPerChar*2'                                       ct.NameEnd - offset -                                       m_enc.MinBytesPerChar*2);
Magic Number,Jabber.Protocol,AsynchElementStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,EndTag,The following statement contains a magic number: if ((tok == TOK.EMPTY_ELEMENT_WITH_ATTS) ||                  (tok == TOK.EMPTY_ELEMENT_NO_ATTS))                  name = utf.GetString(buf'                                       offset + m_enc.MinBytesPerChar'                                       ct.NameEnd - offset -                                       m_enc.MinBytesPerChar);              else                  name = utf.GetString(buf'                                       offset + m_enc.MinBytesPerChar*2'                                       ct.NameEnd - offset -                                       m_enc.MinBytesPerChar*2);
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,GetByteAttr,The following statement contains a magic number: if (String.IsNullOrEmpty(a))                  return 255;
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,GetByteAttr,The following statement contains a magic number: try              {                  return byte.Parse(a);              }              catch (FormatException)              {                  return 255;              }              catch (OverflowException)              {                  return 255;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,GetByteAttr,The following statement contains a magic number: try              {                  return byte.Parse(a);              }              catch (FormatException)              {                  return 255;              }              catch (OverflowException)              {                  return 255;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,SetByteAttr,The following statement contains a magic number: if (val == 255)                  // testing shows this is safe for non-existing attributes.                  RemoveAttribute(name);              else                  SetAttribute(name' val.ToString());
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: try              {                  return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));              }              catch              {                  return DateTime.MinValue;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: try              {                  return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));              }              catch              {                  return DateTime.MinValue;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: try              {                  return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));              }              catch              {                  return DateTime.MinValue;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: try              {                  return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));              }              catch              {                  return DateTime.MinValue;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: try              {                  return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));              }              catch              {                  return DateTime.MinValue;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: try              {                  return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));              }              catch              {                  return DateTime.MinValue;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: try              {                  return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));              }              catch              {                  return DateTime.MinValue;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: try              {                  return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));              }              catch              {                  return DateTime.MinValue;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: try              {                  return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));              }              catch              {                  return DateTime.MinValue;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: try              {                  return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));              }              catch              {                  return DateTime.MinValue;              }
Magic Number,Jabber.Protocol,Element,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: try              {                  return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));              }              catch              {                  return DateTime.MinValue;              }
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(BAD_REQUEST' new CodeType(400' ErrorType.modify));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(CONFLICT' new CodeType(409' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(FEATURE_NOT_IMPLEMENTED' new CodeType(501' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(FORBIDDEN' new CodeType(403' ErrorType.auth));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(GONE' new CodeType(302' ErrorType.modify));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(INTERNAL_SERVER_ERROR' new CodeType(500' ErrorType.wait));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(ITEM_NOT_FOUND' new CodeType(404' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(JID_MALFORMED' new CodeType(400' ErrorType.modify));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(NOT_ACCEPTABLE' new CodeType(406' ErrorType.modify));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(NOT_ALLOWED' new CodeType(405' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(NOT_AUTHORIZED' new CodeType(401' ErrorType.auth));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(PAYMENT_REQUIRED' new CodeType(402' ErrorType.auth));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(RECIPIENT_UNAVAILABLE' new CodeType(404' ErrorType.wait));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(REDIRECT' new CodeType(302' ErrorType.modify));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(REGISTRATION_REQUIRED' new CodeType(407' ErrorType.auth));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(REMOTE_SERVER_NOT_FOUND' new CodeType(404' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(REMOTE_SERVER_TIMEOUT' new CodeType(504' ErrorType.wait));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(RESOURCE_CONSTRAINT' new CodeType(500' ErrorType.wait));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(SERVICE_UNAVAILABLE' new CodeType(503' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(SUBSCRIPTION_REQUIRED' new CodeType(407' ErrorType.auth));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(UNDEFINED_CONDITION' new CodeType(500' ErrorType.NONE));
Magic Number,Jabber.Protocol.Client,Error,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(UNEXPECTED_REQUEST' new CodeType(400' ErrorType.wait));
Magic Number,Jabber.Protocol.Client,Presence,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Presence.cs,IntShow,The following statement contains a magic number: switch (show)              {              case "dnd":                  return 0;              case "xa":                  return 1;              case "away":                  return 2;              case "chat":                  return 4;              default:                  return 3;              }
Magic Number,Jabber.Protocol.Client,Presence,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Presence.cs,IntShow,The following statement contains a magic number: switch (show)              {              case "dnd":                  return 0;              case "xa":                  return 1;              case "away":                  return 2;              case "chat":                  return 4;              default:                  return 3;              }
Magic Number,Jabber.Protocol.Client,Presence,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Presence.cs,IntShow,The following statement contains a magic number: switch (show)              {              case "dnd":                  return 0;              case "xa":                  return 1;              case "away":                  return 2;              case "chat":                  return 4;              default:                  return 3;              }
Magic Number,Jabber.Protocol.Client,IQException,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\ProtocolException.cs,IQException,The following statement contains a magic number: if (iq == null)              {                  //timeout                  m_code = 504;                  m_message = "Request timed out";              }              else              {                  Error e = iq.Error;                  m_code = e.Code;                  m_message = e.InnerText;              }
Magic Number,Jabber.Protocol.Stream,Stream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Stream\Stream.cs,Stream,The following statement contains a magic number: byte[] buf = new byte[4];
Magic Number,StringPrep.Steps,MapStep,C:\repos\sgissinger_JabberNet-2010\Jabber\StringPrep\Steps\MapStep.cs,Prepare,The following statement contains a magic number: for (int i=0; i<result.Length; i++)              {                  pos = Array.BinarySearch(m_table' result[i]' m_comp);                  if (pos < 0)                      continue;                    map = m_table[pos];                  len = map.Length;                  if (len == 1)                  {                      result.Remove(i' 1);                      i--;                  }                  else                  {                      result[i] = map[1];                      if (len > 2)                      {                          result.Insert(i+1' map.ToCharArray(2' len - 2));                          i += len - 2;                      }                  }              }
Magic Number,StringPrep.Steps,MapStep,C:\repos\sgissinger_JabberNet-2010\Jabber\StringPrep\Steps\MapStep.cs,Prepare,The following statement contains a magic number: for (int i=0; i<result.Length; i++)              {                  pos = Array.BinarySearch(m_table' result[i]' m_comp);                  if (pos < 0)                      continue;                    map = m_table[pos];                  len = map.Length;                  if (len == 1)                  {                      result.Remove(i' 1);                      i--;                  }                  else                  {                      result[i] = map[1];                      if (len > 2)                      {                          result.Insert(i+1' map.ToCharArray(2' len - 2));                          i += len - 2;                      }                  }              }
Magic Number,StringPrep.Steps,MapStep,C:\repos\sgissinger_JabberNet-2010\Jabber\StringPrep\Steps\MapStep.cs,Prepare,The following statement contains a magic number: for (int i=0; i<result.Length; i++)              {                  pos = Array.BinarySearch(m_table' result[i]' m_comp);                  if (pos < 0)                      continue;                    map = m_table[pos];                  len = map.Length;                  if (len == 1)                  {                      result.Remove(i' 1);                      i--;                  }                  else                  {                      result[i] = map[1];                      if (len > 2)                      {                          result.Insert(i+1' map.ToCharArray(2' len - 2));                          i += len - 2;                      }                  }              }
Magic Number,StringPrep.Steps,MapStep,C:\repos\sgissinger_JabberNet-2010\Jabber\StringPrep\Steps\MapStep.cs,Prepare,The following statement contains a magic number: for (int i=0; i<result.Length; i++)              {                  pos = Array.BinarySearch(m_table' result[i]' m_comp);                  if (pos < 0)                      continue;                    map = m_table[pos];                  len = map.Length;                  if (len == 1)                  {                      result.Remove(i' 1);                      i--;                  }                  else                  {                      result[i] = map[1];                      if (len > 2)                      {                          result.Insert(i+1' map.ToCharArray(2' len - 2));                          i += len - 2;                      }                  }              }
Magic Number,StringPrep.Unicode,Combining,C:\repos\sgissinger_JabberNet-2010\Jabber\StringPrep\Unicode\Combining.cs,Class,The following statement contains a magic number: int page = c >> 8;
Magic Number,StringPrep.Unicode,Combining,C:\repos\sgissinger_JabberNet-2010\Jabber\StringPrep\Unicode\Combining.cs,Class,The following statement contains a magic number: if (CombiningData.Pages[page] == 255)                  return 0;              else                  return CombiningData.Classes[CombiningData.Pages[page]' c & 0xff];
Magic Number,StringPrep.Unicode,Compose,C:\repos\sgissinger_JabberNet-2010\Jabber\StringPrep\Unicode\Compose.cs,Index,The following statement contains a magic number: int p = c >> 8;
Magic Number,StringPrep.Unicode,Compose,C:\repos\sgissinger_JabberNet-2010\Jabber\StringPrep\Unicode\Compose.cs,Index,The following statement contains a magic number: if (ComposeData.Table[p] == 255)                  return 0;              else                  return ComposeData.Data[ComposeData.Table[p]' c & 0xff];
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end)              {                  checkCharMatches(buf' off' '-');                  off += minBPC;                  while (off != end)                  {                      switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end)              {                  checkCharMatches(buf' off' '-');                  off += minBPC;                  while (off != end)                  {                      switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end)              {                  checkCharMatches(buf' off' '-');                  off += minBPC;                  while (off != end)                  {                      switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end)              {                  checkCharMatches(buf' off' '-');                  off += minBPC;                  while (off != end)                  {                      switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end)              {                  checkCharMatches(buf' off' '-');                  off += minBPC;                  while (off != end)                  {                      switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end)              {                  checkCharMatches(buf' off' '-');                  off += minBPC;                  while (off != end)                  {                      switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,targetIsXml,The following statement contains a magic number: if (end - off != minBPC*3)                  return false;
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanCdataSection,The following statement contains a magic number: if (end - off < 6 * minBPC)                  throw new PartialTokenException();
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end)              {                  int c = byteToAscii(buf' off);                  int num;                  switch (c)                  {                      case '0': case '1': case '2': case '3': case '4':                      case '5': case '6': case '7': case '8': case '9':                          num = c - '0';                          break;                      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                          num = c - ('A' - 10);                          break;                      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                          num = c - ('a' - 10);                          break;                      default:                          throw new InvalidTokenException(off);                  }                  for (off += minBPC; off != end; off += minBPC)                  {                      c = byteToAscii(buf' off);                      switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }                      if (num >= 0x110000)                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end)              {                  int c = byteToAscii(buf' off);                  int num;                  switch (c)                  {                      case '0': case '1': case '2': case '3': case '4':                      case '5': case '6': case '7': case '8': case '9':                          num = c - '0';                          break;                      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                          num = c - ('A' - 10);                          break;                      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                          num = c - ('a' - 10);                          break;                      default:                          throw new InvalidTokenException(off);                  }                  for (off += minBPC; off != end; off += minBPC)                  {                      c = byteToAscii(buf' off);                      switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }                      if (num >= 0x110000)                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end)              {                  int c = byteToAscii(buf' off);                  int num;                  switch (c)                  {                      case '0': case '1': case '2': case '3': case '4':                      case '5': case '6': case '7': case '8': case '9':                          num = c - '0';                          break;                      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                          num = c - ('A' - 10);                          break;                      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                          num = c - ('a' - 10);                          break;                      default:                          throw new InvalidTokenException(off);                  }                  for (off += minBPC; off != end; off += minBPC)                  {                      c = byteToAscii(buf' off);                      switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }                      if (num >= 0x110000)                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end)              {                  int c = byteToAscii(buf' off);                  int num;                  switch (c)                  {                      case '0': case '1': case '2': case '3': case '4':                      case '5': case '6': case '7': case '8': case '9':                          num = c - '0';                          break;                      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                          num = c - ('A' - 10);                          break;                      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                          num = c - ('a' - 10);                          break;                      default:                          throw new InvalidTokenException(off);                  }                  for (off += minBPC; off != end; off += minBPC)                  {                      c = byteToAscii(buf' off);                      switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }                      if (num >= 0x110000)                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end)              {                  int c = byteToAscii(buf' off);                  int num;                  switch (c)                  {                      case '0': case '1': case '2': case '3': case '4':                      case '5': case '6': case '7': case '8': case '9':                          num = c - '0';                          break;                      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                          num = c - ('A' - 10);                          break;                      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                          num = c - ('a' - 10);                          break;                      default:                          throw new InvalidTokenException(off);                  }                  for (off += minBPC; off != end; off += minBPC)                  {                      c = byteToAscii(buf' off);                      switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }                      if (num >= 0x110000)                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end)              {                  int c = byteToAscii(buf' off);                  int num;                  switch (c)                  {                      case '0': case '1': case '2': case '3': case '4':                      case '5': case '6': case '7': case '8': case '9':                          num = c - '0';                          break;                      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                          num = c - ('A' - 10);                          break;                      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                          num = c - ('a' - 10);                          break;                      default:                          throw new InvalidTokenException(off);                  }                  for (off += minBPC; off != end; off += minBPC)                  {                      c = byteToAscii(buf' off);                      switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }                      if (num >= 0x110000)                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end)              {                  int c = byteToAscii(buf' off);                  int num;                  switch (c)                  {                      case '0': case '1': case '2': case '3': case '4':                      case '5': case '6': case '7': case '8': case '9':                          num = c - '0';                          break;                      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                          num = c - ('A' - 10);                          break;                      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                          num = c - ('a' - 10);                          break;                      default:                          throw new InvalidTokenException(off);                  }                  for (off += minBPC; off != end; off += minBPC)                  {                      c = byteToAscii(buf' off);                      switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }                      if (num >= 0x110000)                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanCharRef,The following statement contains a magic number: if (off != end)              {                  int c = byteToAscii(buf' off);                  switch (c)                  {                      case 'x':                          return scanHexCharRef(buf' off + minBPC' end' token);                      case '0':                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          break;                      default:                          throw new InvalidTokenException(off);                  }                    int num = c - '0';                  for (off += minBPC; off != end; off += minBPC)                  {                      c = byteToAscii(buf' off);                      switch (c)                      {                          case '0':                          case '1':                          case '2':                          case '3':                          case '4':                          case '5':                          case '6':                          case '7':                          case '8':                          case '9':                              num = num * 10 + (c - '0');                              if (num < 0x110000)                                  break;                              /* fall through */                              goto default;                          default:                              throw new InvalidTokenException(off);                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                      }                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setRefChar,The following statement contains a magic number: if (num < 0x10000)              {                  switch (charTypeTable[num >> 8][num & 0xFF])                  {                      case BT_NONXML:                      case BT_LEAD4:                      case BT_MALFORM:                          throw new InvalidTokenException(token.TokenEnd - minBPC);                  }                  token.RefChar1 = (char)num;                  return TOK.CHAR_REF;              }              else              {                  num -= 0x10000;                  token.RefChar1 = (char)((num >> 10) + 0xD800);                  token.RefChar2 = (char)((num & ((1 << 10) - 1)) + 0xDC00);                  return TOK.CHAR_PAIR_REF;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setRefChar,The following statement contains a magic number: if (num < 0x10000)              {                  switch (charTypeTable[num >> 8][num & 0xFF])                  {                      case BT_NONXML:                      case BT_LEAD4:                      case BT_MALFORM:                          throw new InvalidTokenException(token.TokenEnd - minBPC);                  }                  token.RefChar1 = (char)num;                  return TOK.CHAR_REF;              }              else              {                  num -= 0x10000;                  token.RefChar1 = (char)((num >> 10) + 0xD800);                  token.RefChar2 = (char)((num & ((1 << 10) - 1)) + 0xDC00);                  return TOK.CHAR_PAIR_REF;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setRefChar,The following statement contains a magic number: if (num < 0x10000)              {                  switch (charTypeTable[num >> 8][num & 0xFF])                  {                      case BT_NONXML:                      case BT_LEAD4:                      case BT_MALFORM:                          throw new InvalidTokenException(token.TokenEnd - minBPC);                  }                  token.RefChar1 = (char)num;                  return TOK.CHAR_REF;              }              else              {                  num -= 0x10000;                  token.RefChar1 = (char)((num >> 10) + 0xD800);                  token.RefChar2 = (char)((num & ((1 << 10) - 1)) + 0xDC00);                  return TOK.CHAR_PAIR_REF;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end)              {                  int t = byteType(buf' off);                  switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end)              {                  int t = byteType(buf' off);                  switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end)              {                  int t = byteType(buf' off);                  switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end)              {                  int t = byteType(buf' off);                  switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end)              {                  int t = byteType(buf' off);                  switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end)              {                  int t = byteType(buf' off);                  switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end)              {                  switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: int hi = c >> 8;
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: if (charTypeTable[hi] == null)              {                  charTypeTable[hi] = new int[256];                  for (int i = 0; i < 256; i++)                      charTypeTable[hi][i] = BT_OTHER;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: if (charTypeTable[hi] == null)              {                  charTypeTable[hi] = new int[256];                  for (int i = 0; i < 256; i++)                      charTypeTable[hi][i] = BT_OTHER;              }
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: do              {                  if ((min & 0xFF) == 0)                  {                      for (; min + (char)0xFF <= max; min += (char)0x100)                      {                          if (shared == null)                          {                              shared = new int[256];                              for (int i = 0; i < 256; i++)                                  shared[i] = type;                          }                          charTypeTable[min >> 8] = shared;                          if (min + 0xFF == max)                              return;                      }                  }                  setCharType(min' type);              } while (min++ != max);
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: do              {                  if ((min & 0xFF) == 0)                  {                      for (; min + (char)0xFF <= max; min += (char)0x100)                      {                          if (shared == null)                          {                              shared = new int[256];                              for (int i = 0; i < 256; i++)                                  shared[i] = type;                          }                          charTypeTable[min >> 8] = shared;                          if (min + 0xFF == max)                              return;                      }                  }                  setCharType(min' type);              } while (min++ != max);
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: do              {                  if ((min & 0xFF) == 0)                  {                      for (; min + (char)0xFF <= max; min += (char)0x100)                      {                          if (shared == null)                          {                              shared = new int[256];                              for (int i = 0; i < 256; i++)                                  shared[i] = type;                          }                          charTypeTable[min >> 8] = shared;                          if (min + 0xFF == max)                              return;                      }                  }                  setCharType(min' type);              } while (min++ != max);
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: charTypeTable = new int[256][];
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < nameRanges.Length; i += 2)                  setCharType(nameRanges[i]' nameRanges[i + 1]' BT_NAME);
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < nameStartRanges.Length; i += 2)                  setCharType(nameStartRanges[i]' nameStartRanges[i + 1]'                      BT_NMSTRT);
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: int[] other = new int[256];
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < 256; i++)                  other[i] = BT_OTHER;
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < 256; i++)                  if (charTypeTable[i] == null)                      charTypeTable[i] = other;
Magic Number,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: System.Array.Copy(asciiTypeTable' 0' charTypeTable[0]' 0' 128);
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy(asciiTypeTable'  0' utf8TypeTable'   0' 128);
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy(utf8HiTypeTable' 0' utf8TypeTable' 128' 128);
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy(utf8HiTypeTable' 0' utf8TypeTable' 128' 128);
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,byteType2,The following statement contains a magic number: int[] page = charTypeTable[(buf[off] >> 2) & 0x7];
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,byteType2,The following statement contains a magic number: return page[((buf[off] & 3) << 6) | (buf[off + 1] & 0x3F)];
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,byteType2,The following statement contains a magic number: return page[((buf[off] & 3) << 6) | (buf[off + 1] & 0x3F)];
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd)              {                  byte b = sourceBuf[sourceStart++];                  if (b >= 0)                      targetBuf[targetStart++] = (char)b;                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          case BT_LEAD2:                              /* 5' 6 */                              targetBuf[targetStart++]                                  = (char)(((b & 0x1F) << 6) | (sourceBuf[sourceStart++] & 0x3F));                              break;                          case BT_LEAD3:                              /* 4' 6' 6 */                              c = (b & 0xF) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              targetBuf[targetStart++] = (char)c;                              break;                          case BT_LEAD4:                              /* 3' 6' 6' 6 */                              c = (b & 0x7) << 18;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              c -= 0x10000;                              targetBuf[targetStart++] = (char)((c >> 10) | 0xD800);                              targetBuf[targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd)              {                  byte b = sourceBuf[sourceStart++];                  if (b >= 0)                      targetBuf[targetStart++] = (char)b;                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          case BT_LEAD2:                              /* 5' 6 */                              targetBuf[targetStart++]                                  = (char)(((b & 0x1F) << 6) | (sourceBuf[sourceStart++] & 0x3F));                              break;                          case BT_LEAD3:                              /* 4' 6' 6 */                              c = (b & 0xF) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              targetBuf[targetStart++] = (char)c;                              break;                          case BT_LEAD4:                              /* 3' 6' 6' 6 */                              c = (b & 0x7) << 18;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              c -= 0x10000;                              targetBuf[targetStart++] = (char)((c >> 10) | 0xD800);                              targetBuf[targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd)              {                  byte b = sourceBuf[sourceStart++];                  if (b >= 0)                      targetBuf[targetStart++] = (char)b;                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          case BT_LEAD2:                              /* 5' 6 */                              targetBuf[targetStart++]                                  = (char)(((b & 0x1F) << 6) | (sourceBuf[sourceStart++] & 0x3F));                              break;                          case BT_LEAD3:                              /* 4' 6' 6 */                              c = (b & 0xF) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              targetBuf[targetStart++] = (char)c;                              break;                          case BT_LEAD4:                              /* 3' 6' 6' 6 */                              c = (b & 0x7) << 18;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              c -= 0x10000;                              targetBuf[targetStart++] = (char)((c >> 10) | 0xD800);                              targetBuf[targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd)              {                  byte b = sourceBuf[sourceStart++];                  if (b >= 0)                      targetBuf[targetStart++] = (char)b;                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          case BT_LEAD2:                              /* 5' 6 */                              targetBuf[targetStart++]                                  = (char)(((b & 0x1F) << 6) | (sourceBuf[sourceStart++] & 0x3F));                              break;                          case BT_LEAD3:                              /* 4' 6' 6 */                              c = (b & 0xF) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              targetBuf[targetStart++] = (char)c;                              break;                          case BT_LEAD4:                              /* 3' 6' 6' 6 */                              c = (b & 0x7) << 18;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              c -= 0x10000;                              targetBuf[targetStart++] = (char)((c >> 10) | 0xD800);                              targetBuf[targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd)              {                  byte b = sourceBuf[sourceStart++];                  if (b >= 0)                      targetBuf[targetStart++] = (char)b;                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          case BT_LEAD2:                              /* 5' 6 */                              targetBuf[targetStart++]                                  = (char)(((b & 0x1F) << 6) | (sourceBuf[sourceStart++] & 0x3F));                              break;                          case BT_LEAD3:                              /* 4' 6' 6 */                              c = (b & 0xF) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              targetBuf[targetStart++] = (char)c;                              break;                          case BT_LEAD4:                              /* 3' 6' 6' 6 */                              c = (b & 0x7) << 18;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              c -= 0x10000;                              targetBuf[targetStart++] = (char)((c >> 10) | 0xD800);                              targetBuf[targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd)              {                  byte b = sourceBuf[sourceStart++];                  if (b >= 0)                      targetBuf[targetStart++] = (char)b;                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          case BT_LEAD2:                              /* 5' 6 */                              targetBuf[targetStart++]                                  = (char)(((b & 0x1F) << 6) | (sourceBuf[sourceStart++] & 0x3F));                              break;                          case BT_LEAD3:                              /* 4' 6' 6 */                              c = (b & 0xF) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              targetBuf[targetStart++] = (char)c;                              break;                          case BT_LEAD4:                              /* 3' 6' 6' 6 */                              c = (b & 0x7) << 18;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              c -= 0x10000;                              targetBuf[targetStart++] = (char)((c >> 10) | 0xD800);                              targetBuf[targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd)              {                  byte b = sourceBuf[sourceStart++];                  if (b >= 0)                      targetBuf[targetStart++] = (char)b;                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          case BT_LEAD2:                              /* 5' 6 */                              targetBuf[targetStart++]                                  = (char)(((b & 0x1F) << 6) | (sourceBuf[sourceStart++] & 0x3F));                              break;                          case BT_LEAD3:                              /* 4' 6' 6 */                              c = (b & 0xF) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              targetBuf[targetStart++] = (char)c;                              break;                          case BT_LEAD4:                              /* 3' 6' 6' 6 */                              c = (b & 0x7) << 18;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              c -= 0x10000;                              targetBuf[targetStart++] = (char)((c >> 10) | 0xD800);                              targetBuf[targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd)              {                  byte b = sourceBuf[sourceStart++];                  if (b >= 0)                      targetBuf[targetStart++] = (char)b;                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          case BT_LEAD2:                              /* 5' 6 */                              targetBuf[targetStart++]                                  = (char)(((b & 0x1F) << 6) | (sourceBuf[sourceStart++] & 0x3F));                              break;                          case BT_LEAD3:                              /* 4' 6' 6 */                              c = (b & 0xF) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              targetBuf[targetStart++] = (char)c;                              break;                          case BT_LEAD4:                              /* 3' 6' 6' 6 */                              c = (b & 0x7) << 18;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              c -= 0x10000;                              targetBuf[targetStart++] = (char)((c >> 10) | 0xD800);                              targetBuf[targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end)              {                  byte b = buf[off];                  if (b >= 0)                  {                      ++off;                      switch (b)                      {                          case (byte)'\n':                              lineNumber += 1;                              colDiff = off;                              break;                          case (byte)'\r':                              lineNumber += 1;                              if (off != end && buf[off] == '\n')                                  off++;                              colDiff = off;                              break;                      }                  }                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          default:                              off += 1;                              break;                          case BT_LEAD2:                              off += 2;                              colDiff++;                              break;                          case BT_LEAD3:                              off += 3;                              colDiff += 2;                              break;                          case BT_LEAD4:                              off += 4;                              colDiff += 3;                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end)              {                  byte b = buf[off];                  if (b >= 0)                  {                      ++off;                      switch (b)                      {                          case (byte)'\n':                              lineNumber += 1;                              colDiff = off;                              break;                          case (byte)'\r':                              lineNumber += 1;                              if (off != end && buf[off] == '\n')                                  off++;                              colDiff = off;                              break;                      }                  }                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          default:                              off += 1;                              break;                          case BT_LEAD2:                              off += 2;                              colDiff++;                              break;                          case BT_LEAD3:                              off += 3;                              colDiff += 2;                              break;                          case BT_LEAD4:                              off += 4;                              colDiff += 3;                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end)              {                  byte b = buf[off];                  if (b >= 0)                  {                      ++off;                      switch (b)                      {                          case (byte)'\n':                              lineNumber += 1;                              colDiff = off;                              break;                          case (byte)'\r':                              lineNumber += 1;                              if (off != end && buf[off] == '\n')                                  off++;                              colDiff = off;                              break;                      }                  }                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          default:                              off += 1;                              break;                          case BT_LEAD2:                              off += 2;                              colDiff++;                              break;                          case BT_LEAD3:                              off += 3;                              colDiff += 2;                              break;                          case BT_LEAD4:                              off += 4;                              colDiff += 3;                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end)              {                  byte b = buf[off];                  if (b >= 0)                  {                      ++off;                      switch (b)                      {                          case (byte)'\n':                              lineNumber += 1;                              colDiff = off;                              break;                          case (byte)'\r':                              lineNumber += 1;                              if (off != end && buf[off] == '\n')                                  off++;                              colDiff = off;                              break;                      }                  }                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          default:                              off += 1;                              break;                          case BT_LEAD2:                              off += 2;                              colDiff++;                              break;                          case BT_LEAD3:                              off += 3;                              colDiff += 2;                              break;                          case BT_LEAD4:                              off += 4;                              colDiff += 3;                              break;                      }                  }              }
Magic Number,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end)              {                  byte b = buf[off];                  if (b >= 0)                  {                      ++off;                      switch (b)                      {                          case (byte)'\n':                              lineNumber += 1;                              colDiff = off;                              break;                          case (byte)'\r':                              lineNumber += 1;                              if (off != end && buf[off] == '\n')                                  off++;                              colDiff = off;                              break;                      }                  }                  else                  {                      switch (utf8TypeTable[b & 0xFF])                      {                          default:                              off += 1;                              break;                          case BT_LEAD2:                              off += 2;                              colDiff++;                              break;                          case BT_LEAD3:                              off += 3;                              colDiff += 2;                              break;                          case BT_LEAD4:                              off += 4;                              colDiff += 3;                              break;                      }                  }              }
Missing Default,Bedrock.Net,ShttpProxy,C:\repos\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\ShttpProxy.cs,OnRead,The following switch statement is missing a default case: switch (state)                      {                      case 0:                          if (b == '\r')                              state++;                          break;                      case 1:                          if (b == '\n')                          {                              byte[] hs = m_headerstream.ToArray();                              string s = System.Text.Encoding.UTF8.GetString(hs);                              Debug.Write("PRECV: " + s);                              m_headers.Add(s);                              m_headerstream.SetLength(0);                              state++;                              line++;                          }                          else                              state = 0;                          break;                      case 2:                          if (b == '\r')                              state++;                          else                              state = 0;                          break;                      case 3:                          if (b == '\n')                          {                              Debug.WriteLine("End of proxy headers");                              string line0 = (string)m_headers[0];                              if (line0.IndexOf("200") == -1)                              {                                  Debug.WriteLine("200 response not detected.  Closing.");                                  m_state = States.Error;                                  this.Close();                              }                              else                              {                                  Debug.WriteLine("Proxy connected");                                  m_listener.OnConnect(sock); // tell the real listener that we're connected.                                  m_state = States.Running;                              }                              // they'll call RequestRead()' so we can return false here.                              return false;                          }                          else                              state = 0;                          break;                      }
Missing Default,Jabber.Client,JingleIceManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleIceManager.cs,CheckConnectivity,The following switch statement is missing a default case: switch (remoteCandidate.Type)                      {                          case IceCandidateType.host:                          case IceCandidateType.prflx:                          case IceCandidateType.srflx:                              foreach (JingleIceCandidate localCandidate in this.localCandidates[sid])                              {                                  if (localCandidate.Type == remoteCandidate.Type)                                  {                                      this.holePuncher.AddEP(remoteCandidate.Priority' remoteCandidate.EndPoint);                                      break;                                  }                              }                              break;                            case IceCandidateType.relay:                              if (this.TurnSupported &&                                  jingleSession.Remote.Action == ActionType.session_accept)                              {                                  this.turnSessions[sid].TurnManager.CreatePermission(new XorMappedAddress(remoteCandidate.RelatedEndPoint)'                                                                                      this.turnSessions[sid].TurnAllocation);                              }                              break;                      }
Missing Default,Jabber.Client,JingleManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleManager.cs,GotIQ,The following switch statement is missing a default case: switch (jingle.Action)                      {                          case ActionType.session_initiate:                              this.Stream.Write(iq.GetAcknowledge(this.Stream.Document));                                if (this.AllowSessionInitiateFrom(iq.From))                              {                                  if (!this.Sessions.ContainsKey(jingle.Sid))                                  {                                      JingleSession jingleSession = new JingleSession();                                      jingleSession.SID = jingle.Sid;                                      jingleSession.Remote = jingle;                                        this.Sessions.Add(jingle.Sid' jingleSession);                                  }                                    if (this.OnReceivedSessionInitiate != null)                                      this.OnReceivedSessionInitiate(this' iq);                                    if (!iq.Handled)                                  {                                      this.SessionTerminate(iq.From' jingle.Sid' ReasonType.decline);                                      iq.Handled = true;                                  }                              }                              else                              {                                  this.SessionTerminate(iq.From' jingle.Sid' ReasonType.security_error);                                  iq.Handled = true;                              }                              break;                            case ActionType.session_accept:                              this.Stream.Write(iq.GetAcknowledge(this.Stream.Document));                                if (!this.Sessions.ContainsKey(jingle.Sid))                              {                                  JingleSession jingleSession = new JingleSession();                                  jingleSession.SID = jingle.Sid;                                  jingleSession.Remote = jingle;                                    this.Sessions.Add(jingle.Sid' jingleSession);                                    if (this.OnReceivedSessionAccept != null)                                      this.OnReceivedSessionAccept(this' iq);                                    if (!iq.Handled)                                  {                                      this.SessionTerminate(iq.From' jingle.Sid' ReasonType.cancel);                                      iq.Handled = true;                                  }                              }                              else                              {                                  this.Stream.Write(new UnknownSession(this.Stream.Document));                                  iq.Handled = true;                              }                              break;                            case ActionType.session_info:                              if (this.Sessions.ContainsKey(jingle.Sid))                                  this.Stream.Write(iq.GetAcknowledge(this.Stream.Document));                              else                                  this.Stream.Write(new UnknownSession(this.Stream.Document));                                if (this.OnReceivedSessionInfo != null)                                  this.OnReceivedSessionInfo(this' iq);                                break;                            case ActionType.transport_info:                              if (this.Sessions.ContainsKey(jingle.Sid))                                  this.Stream.Write(iq.GetAcknowledge(this.Stream.Document));                              else                                  this.Stream.Write(new UnknownSession(this.Stream.Document));                                if (this.OnReceivedTransportInfo != null)                                  this.OnReceivedTransportInfo(this' iq);                                break;                      }
Missing Default,Jabber.Client,JingleManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleManager.cs,SessionTerminate,The following switch statement is missing a default case: switch (reasonType)                  {                      case ReasonType.alternative_session:                          reason.Reason = new AlternativeSession(jingleIq.OwnerDocument);                          break;                        case ReasonType.busy:                          reason.Reason = new Busy(jingleIq.OwnerDocument);                          break;                        case ReasonType.cancel:                          reason.Reason = new Cancel(jingleIq.OwnerDocument);                          break;                        case ReasonType.connectivity_error:                          reason.Reason = new ConnectivityError(jingleIq.OwnerDocument);                          break;                        case ReasonType.decline:                          reason.Reason = new JingleDecline(jingleIq.OwnerDocument);                          break;                        case ReasonType.expired:                          reason.Reason = new Expired(jingleIq.OwnerDocument);                          break;                        case ReasonType.failed_application:                          reason.Reason = new FailedApplication(jingleIq.OwnerDocument);                          break;                        case ReasonType.failed_transport:                          reason.Reason = new FailedTransport(jingleIq.OwnerDocument);                          break;                        case ReasonType.general_error:                          reason.Reason = new GeneralError(jingleIq.OwnerDocument);                          break;                        case ReasonType.gone:                          reason.Reason = new Gone(jingleIq.OwnerDocument);                          break;                        case ReasonType.incompatible_parameters:                          reason.Reason = new IncompatibleParameters(jingleIq.OwnerDocument);                          break;                        case ReasonType.media_error:                          reason.Reason = new MediaError(jingleIq.OwnerDocument);                          break;                        case ReasonType.security_error:                          reason.Reason = new SecurityError(jingleIq.OwnerDocument);                          break;                        case ReasonType.success:                          reason.Reason = new Success(jingleIq.OwnerDocument);                          break;                        case ReasonType.timeout:                          reason.Reason = new Timeout(jingleIq.OwnerDocument);                          break;                        case ReasonType.unsupported_applications:                          reason.Reason = new UnsupportedApplications(jingleIq.OwnerDocument);                          break;                        case ReasonType.unsupported_transports:                          reason.Reason = new UnsupportedTransports(jingleIq.OwnerDocument);                          break;                  }
Missing Default,Jabber.Client,RpcManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RpcManager.cs,GotRpcCall,The following switch statement is missing a default case: switch (iq.Type)              {                  case IQType.set:                      if (this.CanReceiveRpcXml)                      {                          RpcIQ methodResponse = new RpcIQ(new XmlDocument());                          methodResponse.From = this.Stream.JID;                          methodResponse.To = iq.From;                          methodResponse.Type = IQType.result;                          methodResponse.ID = iq.ID; // Make IQ ID behaving like a transaction ID                          methodResponse.Instruction.SetXmlRpcPayload(this.InvokeXmlRpc(rpcXmlString));                            this.BeginIQ(methodResponse' new IqCB(this.GotRpcCall)' null);                            iq.Handled = true;                      }                      break;                    case IQType.result:                      if (this.CanSendRpcXml && this.xmlRpcContexts.ContainsKey(iq.ID))                      {                          byte[] outputByteArray = Encoding.UTF8.GetBytes(rpcXmlString);                          MemoryStream outputStream = new MemoryStream(outputByteArray);                            HttpListenerResponse response = this.xmlRpcContexts[iq.ID].Response;                            response.ContentLength64 = outputStream.Length;                            Util.CopyStream(outputStream' response.OutputStream);                            response.OutputStream.Flush();                            this.xmlRpcContexts.Remove(iq.ID);                            iq.Handled = true;                      }                      break;              }
Missing Default,Jabber.Client,RpcManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RpcManager.cs,MethodCallSerializerThreadStart,The following switch statement is missing a default case: switch (match.Groups["key"].Value)                          {                              case "to":                                  to = Uri.UnescapeDataString(match.Groups["val"].Value);                                  break;                          }
Missing Default,Jabber.Client,RosterManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RosterManager.Designer.cs,cli_OnPresence,The following switch statement is missing a default case: switch (typ)              {                  case PresenceType.available:                  case PresenceType.unavailable:                  case PresenceType.error:                  case PresenceType.probe:                      return;                  case PresenceType.subscribe:                      switch (m_autoAllow)                      {                          case AutoSubscriptionHanding.AllowAll:                              ReplyAllow(pres);                              return;                          case AutoSubscriptionHanding.DenyAll:                              ReplyDeny(pres);                              return;                          case AutoSubscriptionHanding.NONE:                              if (OnSubscription != null)                                  OnSubscription(this' this[pres.From]' pres);                              return;                          case AutoSubscriptionHanding.AllowIfSubscribed:                              Item ri = this[pres.From];                              if (ri != null)                              {                                  switch (ri.Subscription)                                  {                                      case Subscription.to:                                          ReplyAllow(pres);                                          return;                                      case Subscription.from:                                      case Subscription.both:                                          // Almost an assert                                          throw new InvalidOperationException("Server sent a presence subscribe for an already-subscribed contact");                                      case Subscription.none:                                          if (ri.Ask == Ask.subscribe)                                          {                                              ReplyAllow(pres);                                              return;                                          }                                          break;                                  }                              }                              if (OnSubscription != null)                                  OnSubscription(this' ri' pres);                              break;                      }                      break;                  case PresenceType.subscribed:                      // This is the new ack case.                      Presence sub_ack = new Presence(m_stream.Document);                      sub_ack.To = pres.From;                      sub_ack.Type = PresenceType.subscribe;                      Write(sub_ack);                      break;                  case PresenceType.unsubscribe:                      // ack.  we'll likely get an unsubscribed soon' anyway.                      Presence un_ack = new Presence(m_stream.Document);                      un_ack.To = pres.From;                      un_ack.Type = PresenceType.unsubscribed;                      Write(un_ack);                      break;                  case PresenceType.unsubscribed:                      bool remove = true;                      if (OnUnsubscription != null)                          OnUnsubscription(this' pres' ref remove);                        if (remove)                          Remove(pres.From);                      break;              }
Missing Default,Jabber.Client,RosterManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RosterManager.Designer.cs,cli_OnPresence,The following switch statement is missing a default case: switch (m_autoAllow)                      {                          case AutoSubscriptionHanding.AllowAll:                              ReplyAllow(pres);                              return;                          case AutoSubscriptionHanding.DenyAll:                              ReplyDeny(pres);                              return;                          case AutoSubscriptionHanding.NONE:                              if (OnSubscription != null)                                  OnSubscription(this' this[pres.From]' pres);                              return;                          case AutoSubscriptionHanding.AllowIfSubscribed:                              Item ri = this[pres.From];                              if (ri != null)                              {                                  switch (ri.Subscription)                                  {                                      case Subscription.to:                                          ReplyAllow(pres);                                          return;                                      case Subscription.from:                                      case Subscription.both:                                          // Almost an assert                                          throw new InvalidOperationException("Server sent a presence subscribe for an already-subscribed contact");                                      case Subscription.none:                                          if (ri.Ask == Ask.subscribe)                                          {                                              ReplyAllow(pres);                                              return;                                          }                                          break;                                  }                              }                              if (OnSubscription != null)                                  OnSubscription(this' ri' pres);                              break;                      }
Missing Default,Jabber.Client,RosterManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RosterManager.Designer.cs,cli_OnPresence,The following switch statement is missing a default case: switch (ri.Subscription)                                  {                                      case Subscription.to:                                          ReplyAllow(pres);                                          return;                                      case Subscription.from:                                      case Subscription.both:                                          // Almost an assert                                          throw new InvalidOperationException("Server sent a presence subscribe for an already-subscribed contact");                                      case Subscription.none:                                          if (ri.Ask == Ask.subscribe)                                          {                                              ReplyAllow(pres);                                              return;                                          }                                          break;                                  }
Missing Default,Jabber.Connection,CapsManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CapsManager.Designer.cs,GetHasher,The following switch statement is missing a default case: switch (name)              {              case null:                  return null;              case "sha-1":                  return SHA1.Create();              case "sha-256":                  return SHA256.Create();              case "sha-512":                  return SHA512.Create();              case "sha-384":                  return SHA384.Create();              case "md5":                  return MD5.Create();              }
Missing Default,Jabber.Connection,XmppStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,OnElement,The following switch statement is missing a default case: switch (tag.Name)                  {                      case "proceed":                          if (!StartTLS())                              return;                            SendNewStreamHeader();                          break;                      case "failure":                          FireOnError(new AuthenticationFailedException());                          return;                  }
Missing Default,Jabber.Connection,XmppStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,OnElement,The following switch statement is missing a default case: switch (tag.Name)                  {                      case "compressed":                          if (!StartCompression())                              return;                            SendNewStreamHeader();                          break;                      case "failure":                          CompressionFailure fail = tag as CompressionFailure;                          FireOnError(new CompressionFailedException(fail.Error));                          return;                  }
Missing Default,Jabber.Connection,Room,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\ConferenceManager.cs,m_stream_OnProtocol,The following switch statement is missing a default case: switch (rp.LocalName)              {                  case "presence":                      Presence p = (Presence)rp;                      if (p.Error != null)                      {                          m_state = STATE.error;                          if (OnPresenceError != null)                              OnPresenceError(this' p);                          return;                      }                        Presence oldPresence = (m_participants[from] != null) ? ((RoomParticipant)m_participants[from]).Presence : null;                        ParticipantCollection.Modification mod = ParticipantCollection.Modification.NONE;                      RoomParticipant party = m_participants.Modify(p' out mod);                        // if this is ours                      if (p.From == m_jid)                      {                          switch (m_state)                          {                              case STATE.join:                                  OnJoinPresence(p);                                  break;                              case STATE.leaving:                                  OnLeavePresence(p);                                  break;                              case STATE.running:                                  if (p.Type == PresenceType.unavailable)                                      OnLeavePresence(p);                                  else                                      OnPresenceChange(this' party' oldPresence);                                  break;                          }                      }                      else                      {                          switch (mod)                          {                              case ParticipantCollection.Modification.NONE:                                  if (OnParticipantPresenceChange != null)                                      OnParticipantPresenceChange(this' party' oldPresence);                                  break;                              case ParticipantCollection.Modification.JOIN:                                  if (OnParticipantJoin != null)                                      OnParticipantJoin(this' party);                                  break;                              case ParticipantCollection.Modification.LEAVE:                                  if (OnParticipantLeave != null)                                      OnParticipantLeave(this' party);                                  break;                          }                      }                      break;                  case "message":                      Message m = (Message)rp;                      if (m.Type == MessageType.groupchat)                      {                          if (m.Subject != null)                          {                              if (OnSubjectChange != null)                                  OnSubjectChange(this' m);                              m_subject = m;                          }                          else if (m.From == m_jid)                          {                              if (OnSelfMessage != null)                                  OnSelfMessage(this' m);                          }                          else                          {                              if (OnRoomMessage != null)                                  OnRoomMessage(this' m);                          }                      }                      else                      {                          if (m.From.Resource == null)                          {                              // room notification of some kind                              if (OnAdminMessage != null)                                  OnAdminMessage(this' m);                          }                          else                          {                              if (OnPrivateMessage != null)                                  OnPrivateMessage(this' m);                          }                      }                      break;                  case "iq":                      if (OnIQ != null)                          OnIQ(this' (IQ)rp);                      break;              }
Missing Default,Jabber.Connection,Room,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\ConferenceManager.cs,m_stream_OnProtocol,The following switch statement is missing a default case: switch (m_state)                          {                              case STATE.join:                                  OnJoinPresence(p);                                  break;                              case STATE.leaving:                                  OnLeavePresence(p);                                  break;                              case STATE.running:                                  if (p.Type == PresenceType.unavailable)                                      OnLeavePresence(p);                                  else                                      OnPresenceChange(this' party' oldPresence);                                  break;                          }
Missing Default,Jabber.Connection,Room,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\ConferenceManager.cs,m_stream_OnProtocol,The following switch statement is missing a default case: switch (mod)                          {                              case ParticipantCollection.Modification.NONE:                                  if (OnParticipantPresenceChange != null)                                      OnParticipantPresenceChange(this' party' oldPresence);                                  break;                              case ParticipantCollection.Modification.JOIN:                                  if (OnParticipantJoin != null)                                      OnParticipantJoin(this' party);                                  break;                              case ParticipantCollection.Modification.LEAVE:                                  if (OnParticipantLeave != null)                                      OnParticipantLeave(this' party);                                  break;                          }
Missing Default,Jabber.Connection,PubSubNode,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\PubSubManager.cs,NeedsAsking,The following switch statement is missing a default case: switch (state)              {              case STATE.Start:              case STATE.Pending:                  return true;              case STATE.Asking:              case STATE.Running:                  return false;              case STATE.Error:                  Debug.WriteLine("Retrying create after error.  Hope you've changed perms or something in the mean time.");                  return true;              }
Missing Default,Jabber.Connection,PubSubNode,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\PubSubManager.cs,GotSubscribed,The following switch statement is missing a default case: switch (subType)              {              case PubSubSubscriptionType.NONE_SPECIFIED:              case PubSubSubscriptionType.subscribed:                  break;              case PubSubSubscriptionType.pending:                  FireError(Op.SUBSCRIBE' "Subscription pending authorization"' iq);                  return;              case PubSubSubscriptionType.unconfigured:                  FireError(Op.SUBSCRIBE' "Subscription configuration required.  Not implemented yet."' iq);                  return;              }
Missing Default,Jabber.Stun,StunAttribute,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunAttribute.cs,StunAttribute,The following switch statement is missing a default case: switch (type)              {                  case StunAttributeType.Software:                  case StunAttributeType.Realm:                  case StunAttributeType.Nonce:                  case StunAttributeType.ErrorCode:                      if (value.Length > 763)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 763 bytes for the given type as described in RFC 5389");                      break;                    case StunAttributeType.Username:                      if (value.Length > 513)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 513 bytes for the given type as described in RFC 5389");                      break;              }
Missing Default,Jabber.Stun,StunAttribute,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunAttribute.cs,StunAttribute,The following switch statement is missing a default case: switch (type)              {                  case StunAttributeType.Realm:                  case StunAttributeType.Username:                      String saslPrepValue = new SASLprep().Prepare(StunMessage.Encoder.GetString(value));                        value = StunMessage.Encoder.GetBytes(saslPrepValue);                      break;              }
Missing Default,Jabber.Stun,StunClient,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,ReceiveCallback,The following switch statement is missing a default case: switch (receivedMsg.MethodClass)                      {                          case StunMethodClass.SuccessResponse:                              if (!this.IsPendingTransaction(receivedMsg.TransactionID' out transactionObject))                                  return;                                if (this.OnReceivedSuccessResponse != null)                                  this.OnReceivedSuccessResponse(this' receivedMsg' transactionObject.Key' transactionObject.Value);                              break;                            case StunMethodClass.Indication:                              if (this.OnReceivedIndication != null)                                  this.OnReceivedIndication(this' receivedMsg);                              break;                            case StunMethodClass.Error:                              if (!this.IsPendingTransaction(receivedMsg.TransactionID' out transactionObject))                                  return;                                if (this.OnReceivedError != null)                                  this.OnReceivedError(this' receivedMsg' transactionObject.Key' transactionObject.Value);                              break;                      }
Missing Default,Jabber.Stun,TurnManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,StunClient_OnReceivedSuccessResponse,The following switch statement is missing a default case: switch (receivedMsg.MethodType)              {                  case StunMethodType.Allocate:                      TurnAllocation allocation = new TurnAllocation()                      {                          Username = sentMsg.Stun.Username.ValueString'                          Password = transactionObject as String'                          Realm = sentMsg.Stun.Realm.ValueString'                          Nonce = sentMsg.Stun.Nonce.ValueString'                          RelayedMappedAddress = receivedMsg.Turn.XorRelayedAddress'                          MappedAddress = receivedMsg.Stun.XorMappedAddress'                          StartTime = DateTime.Now'                          LifeTime = StunUtilities.ReverseBytes(BitConverter.ToUInt32(receivedMsg.Turn.LifeTime.Value' 0))                      };                        if (this.Allocations.ContainsKey(receivedMsg.Turn.XorRelayedAddress))                          this.Allocations[receivedMsg.Turn.XorRelayedAddress] = allocation;                      else                      {                          this.Allocations.Add(receivedMsg.Turn.XorRelayedAddress' allocation);                            if (this.OnAllocateSucceed != null)                              this.OnAllocateSucceed(this' allocation' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.CreatePermission:                      TurnPermission permission = new TurnPermission()                      {                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 300                      };                      TurnAllocation permAllocation = transactionObject as TurnAllocation;                        if (permAllocation.Permissions.ContainsKey(sentMsg.Turn.XorPeerAddress))                          permAllocation.Permissions[sentMsg.Turn.XorPeerAddress] = permission;                      else                      {                          permAllocation.Permissions.Add(sentMsg.Turn.XorPeerAddress' permission);                            if (this.OnCreatePermissionSucceed != null)                              this.OnCreatePermissionSucceed(this' permAllocation' permission' sentMsg' receivedMsg);                      }                        break;                    case StunMethodType.ChannelBind:                      TurnChannel channel = new TurnChannel()                      {                          Channel = sentMsg.Turn.ChannelNumber'                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 600                      };                      TurnAllocation channelAllocation = transactionObject as TurnAllocation;                        if (channelAllocation.Channels.ContainsKey(sentMsg.Turn.ChannelNumber))                          channelAllocation.Channels[sentMsg.Turn.ChannelNumber] = channel;                      else                      {                          channelAllocation.Channels.Add(sentMsg.Turn.ChannelNumber' channel);                            if (this.OnChannelBindSucceed != null)                              this.OnChannelBindSucceed(this' transactionObject as TurnAllocation' channel' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.ConnectionBind:                      if (this.OnConnectionBindSucceed != null)                          this.OnConnectionBindSucceed(this' transactionObject as Socket' receivedMsg);                      break;              }
Missing Default,Jabber.Stun,TurnManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,StunClient_OnReceivedIndication,The following switch statement is missing a default case: switch (receivedMsg.MethodType)              {                  case StunMethodType.ConnectionAttempt:                      if (this.OnConnectionAttemptReceived != null)                          this.OnConnectionAttemptReceived(this' receivedMsg);                      break;                    case StunMethodType.Data:                      if (this.OnDataReceived != null)                          this.OnDataReceived(this' receivedMsg);                      break;              }
Missing Default,Jabber.Stun,TurnManager,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,StunClient_OnReceivedError,The following switch statement is missing a default case: switch (receivedMsg.MethodType)              {                  case StunMethodType.Allocate:                      if (receivedMsg.Stun.ErrorCode.ErrorType == ErrorCodeType.Unauthorized)                      {                          String[] credentials = transactionObject as String[];                            if (credentials != null)                              this.AllocateRetry(receivedMsg' credentials[0]' credentials[1]);                          else                              if (this.OnAllocateFailed != null)                                  this.OnAllocateFailed(this' receivedMsg' sentMsg' transactionObject);                      }                      break;              }
Missing Default,Jabber.Protocol,AsynchElementStream,C:\repos\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The following switch statement is missing a default case: switch (tok)                      {                      case TOK.EMPTY_ELEMENT_NO_ATTS:                      case TOK.EMPTY_ELEMENT_WITH_ATTS:                          StartTag(b' off' ct' tok);                          EndTag(b' off' ct' tok);                          break;                      case TOK.START_TAG_NO_ATTS:                      case TOK.START_TAG_WITH_ATTS:                          StartTag(b' off' ct' tok);                          break;                      case TOK.END_TAG:                          EndTag(b' off' ct' tok);                          break;                      case TOK.DATA_CHARS:                      case TOK.DATA_NEWLINE:                          AddText(utf.GetString(b' off' ct.TokenEnd - off));                          break;                      case TOK.CHAR_REF:                      case TOK.MAGIC_ENTITY_REF:                          AddText(new string(new char[] { ct.RefChar1 }));                          break;                      case TOK.CHAR_PAIR_REF:                          AddText(new string(new char[] {ct.RefChar1'                                                                ct.RefChar2}));                          break;                      case TOK.COMMENT:                          if (m_elem != null)                          {                              // <!-- 4                              //  --> 3                              int start = off + 4*m_enc.MinBytesPerChar;                              int end = ct.TokenEnd - off -                                      7*m_enc.MinBytesPerChar;                              string text = utf.GetString(b' start' end);                              m_elem.AppendChild(m_doc.CreateComment(text));                          }                          break;                      case TOK.CDATA_SECT_OPEN:                          m_cdata = true;                          break;                      case TOK.CDATA_SECT_CLOSE:                          m_cdata = false;                          break;                      case TOK.XML_DECL:                          // thou shalt use UTF8' and XML version 1.                          // i shall ignore evidence to the contrary...                            // TODO: Throw an exception if these assuptions are                          // wrong                          break;                      case TOK.ENTITY_REF:                      case TOK.PI:                          throw new System.NotImplementedException("Token type not implemented: " + tok);                      }
Missing Default,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getEncoding,The following switch statement is missing a default case: switch (enc)              {                  case UTF8_ENCODING:                      if (utf8Encoding == null)                          utf8Encoding = new UTF8Encoding();                      return utf8Encoding;                      /*                  case UTF16_LITTLE_ENDIAN_ENCODING:                      if (utf16LittleEndianEncoding == null)                          utf16LittleEndianEncoding = new UTF16LittleEndianEncoding();                      return utf16LittleEndianEncoding;                  case UTF16_BIG_ENDIAN_ENCODING:                      if (utf16BigEndianEncoding == null)                          utf16BigEndianEncoding = new UTF16BigEndianEncoding();                      return utf16BigEndianEncoding;                  case INTERNAL_ENCODING:                      if (internalEncoding == null)                          internalEncoding = new InternalEncoding();                      return internalEncoding;                  case ISO8859_1_ENCODING:                      if (iso8859_1Encoding == null)                          iso8859_1Encoding = new ISO8859_1Encoding();                      return iso8859_1Encoding;                  case ASCII_ENCODING:                      if (asciiEncoding == null)                          asciiEncoding = new ASCIIEncoding();                      return asciiEncoding;                      */              }
Missing Default,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanDecl,The following switch statement is missing a default case: switch (byteType(buf' off + minBPC))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_PERCNT:                              throw new InvalidTokenException(off);                      }
Missing Default,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setRefChar,The following switch statement is missing a default case: switch (charTypeTable[num >> 8][num & 0xFF])                  {                      case BT_NONXML:                      case BT_LEAD4:                      case BT_MALFORM:                          throw new InvalidTokenException(token.TokenEnd - minBPC);                  }
Missing Default,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following switch statement is missing a default case: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Missing Default,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following switch statement is missing a default case: switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }
Missing Default,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following switch statement is missing a default case: switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }
Missing Default,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following switch statement is missing a default case: switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }
Missing Default,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getEncoding,The following switch statement is missing a default case: switch (name.ToUpper())              {                  case "UTF-8":                      return getEncoding(UTF8_ENCODING);                      /*                  case "UTF-16":                      return getUTF16Encoding();                  case "ISO-8859-1":                      return getEncoding(ISO8859_1_ENCODING);                  case "US-ASCII":                      return getEncoding(ASCII_ENCODING);                      */              }
Missing Default,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following switch statement is missing a default case: switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }
Missing Default,XpNet,Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following switch statement is missing a default case: switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }
Missing Default,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The following switch statement is missing a default case: switch (utf8TypeTable[b & 0xFF])                      {                          case BT_LEAD2:                              /* 5' 6 */                              targetBuf[targetStart++]                                  = (char)(((b & 0x1F) << 6) | (sourceBuf[sourceStart++] & 0x3F));                              break;                          case BT_LEAD3:                              /* 4' 6' 6 */                              c = (b & 0xF) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              targetBuf[targetStart++] = (char)c;                              break;                          case BT_LEAD4:                              /* 3' 6' 6' 6 */                              c = (b & 0x7) << 18;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              c -= 0x10000;                              targetBuf[targetStart++] = (char)((c >> 10) | 0xD800);                              targetBuf[targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);                              break;                      }
Missing Default,XpNet,UTF8Encoding,C:\repos\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,movePosition,The following switch statement is missing a default case: switch (b)                      {                          case (byte)'\n':                              lineNumber += 1;                              colDiff = off;                              break;                          case (byte)'\r':                              lineNumber += 1;                              if (off != end && buf[off] == '\n')                                  off++;                              colDiff = off;                              break;                      }
