Implementation smell,Namespace,Class,File,Method,Description
Long Method,Bedrock.Net,HttpSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,OnRead,The method has 113 lines of code.
Long Method,Bedrock.Net,XEP25Socket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,The method has 163 lines of code.
Long Method,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The method has 130 lines of code.
Long Method,Jabber.Connection,XmppStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,ProcessFeatures,The method has 106 lines of code.
Long Method,Jabber.Connection,XmppStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,OnElement,The method has 140 lines of code.
Long Method,Jabber.Connection,Room,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\ConferenceManager.cs,m_stream_OnProtocol,The method has 102 lines of code.
Long Method,Jabber.Protocol,AsynchElementStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The method has 107 lines of code.
Long Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The method has 129 lines of code.
Long Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The method has 235 lines of code.
Long Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The method has 145 lines of code.
Long Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The method has 248 lines of code.
Complex Method,Bedrock.Net,Address,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Address.cs,PickSRV,Cyclomatic complexity of the method is 10
Complex Method,Bedrock.Net,Address,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Address.cs,LookupTXT,Cyclomatic complexity of the method is 8
Complex Method,Bedrock.Net,AsyncSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,ChooseClientCertificate,Cyclomatic complexity of the method is 8
Complex Method,Bedrock.Net,AsyncSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,OnConnectResolved,Cyclomatic complexity of the method is 8
Complex Method,Bedrock.Net,HttpSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,OnRead,Cyclomatic complexity of the method is 21
Complex Method,Bedrock.Net,ShttpProxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\ShttpProxy.cs,OnRead,Cyclomatic complexity of the method is 12
Complex Method,Bedrock.Net,XEP124Socket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP124Socket.cs,ProcessThread,Cyclomatic complexity of the method is 11
Complex Method,Bedrock.Net,XEP124Socket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP124Socket.cs,OnRead,Cyclomatic complexity of the method is 14
Complex Method,Bedrock.Net,XEP25Socket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,Cyclomatic complexity of the method is 23
Complex Method,Bedrock.Util,GetOpt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\GetOptBase.cs,Process,Cyclomatic complexity of the method is 11
Complex Method,Jabber.Client,BookmarkManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\BookmarkManager.Designer.cs,GotBookmarks,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Client,JabberClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,Presence,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Client,JabberClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,OnGetRegister,Cyclomatic complexity of the method is 17
Complex Method,Jabber.Client,JabberClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,OnGetAuth,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Client,JabberClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,OnElement,Cyclomatic complexity of the method is 9
Complex Method,Jabber.Client,JingleIceManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleIceManager.cs,CheckConnectivity,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Client,JingleManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleManager.cs,GotIQ,Cyclomatic complexity of the method is 19
Complex Method,Jabber.Client,JingleManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleManager.cs,SessionRequest,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Client,JingleManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleManager.cs,SessionTerminate,Cyclomatic complexity of the method is 18
Complex Method,Jabber.Client,RosterManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RosterManager.Designer.cs,GotIQ,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Client,RosterManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RosterManager.Designer.cs,cli_OnPresence,Cyclomatic complexity of the method is 16
Complex Method,Jabber.Connection,CapsManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CapsManager.Designer.cs,CalculateVer,Cyclomatic complexity of the method is 10
Complex Method,Jabber.Connection,DiscoManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\DiscoManager.Designer.cs,GotAgents,Cyclomatic complexity of the method is 16
Complex Method,Jabber.Connection,PubSubManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\PubSubManager.Designer.cs,OnDefaults,Cyclomatic complexity of the method is 9
Complex Method,Jabber.Connection,XmppStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,ProcessFeatures,Cyclomatic complexity of the method is 14
Complex Method,Jabber.Connection,XmppStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,OnElement,Cyclomatic complexity of the method is 25
Complex Method,Jabber.Connection,Room,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\ConferenceManager.cs,m_stream_OnProtocol,Cyclomatic complexity of the method is 26
Complex Method,Jabber.Connection,PubSubNode,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\PubSubManager.cs,GotCreated,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Connection,PubSubNode,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\PubSubManager.cs,GotSubscribed,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Connection,PubSubNode,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\PubSubManager.cs,OnConfigure,Cyclomatic complexity of the method is 9
Complex Method,Jabber.Protocol.IQ,PubSubIQ,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\PubSub.cs,PubSubIQ,Cyclomatic complexity of the method is 10
Complex Method,Jabber.Server,JabberService,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Server\JabberService.Designer.cs,OnElement,Cyclomatic complexity of the method is 12
Complex Method,Jabber.Stun,HolePuncher,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\HolePuncher.cs,TcpPunchThreadStart,Cyclomatic complexity of the method is 12
Complex Method,Jabber.Stun,StunClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,ReceiveCallback,Cyclomatic complexity of the method is 13
Complex Method,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,StunClient_OnReceivedSuccessResponse,Cyclomatic complexity of the method is 11
Complex Method,Bedrock.Collections,SkipList,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Collections\SkipList.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,Bedrock.Collections,SkipList,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Collections\SkipList.cs,Remove,Cyclomatic complexity of the method is 8
Complex Method,Bedrock.Collections,Tree,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Collections\Tree.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,Bedrock.Collections,Tree,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Collections\Tree.cs,Remove,Cyclomatic complexity of the method is 12
Complex Method,Bedrock.Collections,Tree,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Collections\Tree.cs,swapPosition,Cyclomatic complexity of the method is 15
Complex Method,Bedrock.Collections,Tree,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Collections\Tree.cs,fixAfterInsertion,Cyclomatic complexity of the method is 9
Complex Method,Bedrock.Collections,Tree,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Collections\Tree.cs,fixAfterDeletion,Cyclomatic complexity of the method is 9
Complex Method,Jabber.Connection.SASL,MD5Processor,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\MD5Processor.cs,validateStartDirectives,Cyclomatic complexity of the method is 8
Complex Method,Jabber.Connection.SASL,SASLProcessor,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\SASLProcessor.cs,createProcessor,Cyclomatic complexity of the method is 8
Complex Method,Jabber,JID,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\JID.cs,Parse,Cyclomatic complexity of the method is 13
Complex Method,Jabber,JID,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\JID.cs,Escape,Cyclomatic complexity of the method is 13
Complex Method,Jabber,JID,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\JID.cs,CompareTo,Cyclomatic complexity of the method is 10
Complex Method,Jabber.Protocol,AsynchElementStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,Cyclomatic complexity of the method is 15
Complex Method,Jabber.Protocol,AsynchElementStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,StartTag,Cyclomatic complexity of the method is 10
Complex Method,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,CloneNode,Cyclomatic complexity of the method is 10
Complex Method,Jabber.Protocol.Stream,Mechanism,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Stream\SASL.cs,GetMechanismType,Cyclomatic complexity of the method is 23
Complex Method,Jabber.Protocol.Stream,Mechanism,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Stream\SASL.cs,GetMechanism,Cyclomatic complexity of the method is 23
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,Cyclomatic complexity of the method is 14
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanDecl,Cyclomatic complexity of the method is 10
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,targetIsXml,Cyclomatic complexity of the method is 9
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,Cyclomatic complexity of the method is 38
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,Cyclomatic complexity of the method is 19
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,Cyclomatic complexity of the method is 9
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,Cyclomatic complexity of the method is 28
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,Cyclomatic complexity of the method is 11
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanCharRef,Cyclomatic complexity of the method is 8
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,Cyclomatic complexity of the method is 11
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,Cyclomatic complexity of the method is 26
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,Cyclomatic complexity of the method is 58
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,Cyclomatic complexity of the method is 48
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,Cyclomatic complexity of the method is 21
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,Cyclomatic complexity of the method is 9
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,Cyclomatic complexity of the method is 25
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,Cyclomatic complexity of the method is 24
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,Cyclomatic complexity of the method is 13
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,Cyclomatic complexity of the method is 66
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,Cyclomatic complexity of the method is 21
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,Cyclomatic complexity of the method is 20
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,Cyclomatic complexity of the method is 22
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getPublicId,Cyclomatic complexity of the method is 11
Complex Method,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,Cyclomatic complexity of the method is 8
Complex Method,XpNet,UTF8Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,movePosition,Cyclomatic complexity of the method is 8
Long Parameter List,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,linux_res_query,The method has 5 parameters. Parameters: dname' cls' type' header' headerlen
Long Parameter List,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,linux_dn_expand,The method has 5 parameters. Parameters: msg' endorig' comp_dn' exp_dn' length
Long Parameter List,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,bsd_res_query,The method has 5 parameters. Parameters: dname' cls' type' header' headerlen
Long Parameter List,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,bsd_dn_expand,The method has 5 parameters. Parameters: msg' endorig' comp_dn' exp_dn' length
Long Parameter List,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,res_query,The method has 5 parameters. Parameters: dname' cls' type' header' headerlen
Long Parameter List,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,dn_expand,The method has 5 parameters. Parameters: msg' endorig' comp_dn' exp_dn' length
Long Parameter List,Bedrock.Net,AsyncSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,ChooseClientCertificate,The method has 5 parameters. Parameters: sender' targetHost' localCertificates' remoteCertificate' acceptableIssuers
Long Parameter List,Bedrock.Net,HttpSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,Execute,The method has 6 parameters. Parameters: method' URL' body' offset' len' contentType
Long Parameter List,Bedrock.Net,HttpSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,ParseAt,The method has 5 parameters. Parameters: buf' i' last' check' checkoffset
Long Parameter List,Bedrock.Net,PendingRequest,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,PendingRequest,The method has 6 parameters. Parameters: method' URL' body' offset' len' contentType
Long Parameter List,Jabber.Client,JingleManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleManager.cs,SessionRequest,The method has 6 parameters. Parameters: to' action' sid' contentName' description' transport
Long Parameter List,Jabber.Connection,DiscoManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\DiscoManager.Designer.cs,BeginGetFeatures,The method has 5 parameters. Parameters: jid' node' handler' state' cache
Long Parameter List,Jabber.Connection,DiscoManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\DiscoManager.Designer.cs,BeginGetItems,The method has 5 parameters. Parameters: jid' node' handler' state' cache
Long Parameter List,Jabber.Protocol.IQ,JingleIce,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The method has 10 parameters. Parameters: localPriority' component' foundation' generation' id' network' ip' port' protocol' type
Long Parameter List,Jabber.Protocol.IQ,JingleIce,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The method has 12 parameters. Parameters: localPriority' component' foundation' generation' id' network' ip' port' protocol' type' relatedAddress' relatedPort
Long Parameter List,Jabber.Server,XdbTracker,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Server\XdbTracker.cs,BeginXdbSet,The method has 5 parameters. Parameters: root' owner' ns' cb' cbArg
Long Parameter List,Jabber.Server,XdbTracker,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Server\XdbTracker.cs,BeginXdb,The method has 6 parameters. Parameters: root' xtype' owner' ns' cb' cbArg
Long Parameter List,Jabber.Server,XdbTracker,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Server\XdbTracker.cs,BeginXdb,The method has 7 parameters. Parameters: root' xtype' owner' ns' action' cb' cbArg
Long Parameter List,Jabber.Stun,StunClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,StunClient,The method has 5 parameters. Parameters: hostEP' stunServerEP' protocolType' clientCertificate' remoteCertificateValidation
Long Parameter List,Bedrock.IO,ReadEventStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ReadEventStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Bedrock.IO,ReadEventStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ReadEventStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Bedrock.IO,ZlibStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ZlibStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Bedrock.IO,ZlibStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ZlibStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Jabber.Connection.SASL,SSPIHelper,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\KerbProcessor.cs,AcquireCredentialsHandle,The method has 9 parameters. Parameters: pszPrincipal' pszPackage' fCredentialUse' PAuthenticationID' pAuthData' pGetKeyFn' pvGetKeyArgument' phCredential' ptsExpiry
Long Parameter List,Jabber.Connection.SASL,SSPIHelper,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\KerbProcessor.cs,AcquireCredentialsHandle,The method has 9 parameters. Parameters: pszPrincipal' pszPackage' fCredentialUse' PAuthenticationID' pAuthData' pGetKeyFn' pvGetKeyArgument' phCredential' ptsExpiry
Long Parameter List,Jabber.Connection.SASL,SSPIHelper,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\KerbProcessor.cs,InitializeSecurityContext,The method has 12 parameters. Parameters: phCredential' phContext' pszTargetName' fContextReq' Reserved1' TargetDataRep' pInput' Reserved2' phNewContext' pOutput' pfContextAttr' ptsExpiry
Long Parameter List,Jabber.Connection.SASL,SSPIHelper,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\KerbProcessor.cs,InitializeSecurityContext,The method has 12 parameters. Parameters: phCredential' phContext' pszTargetName' fContextReq' Reserved1' TargetDataRep' SecBufferDesc' Reserved2' phNewContext' pOutput' pfContextAttr' ptsExpiry
Long Parameter List,Jabber.Protocol,XMLParseException,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,XMLParseException,The method has 5 parameters. Parameters: innerException' stream' buf' offset' length
Long Parameter List,Jabber.Protocol.X,Data,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\X\Data.cs,AddField,The method has 5 parameters. Parameters: var' typ' label' val' desc
Long Parameter List,XpNet,ContentToken,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\ContentToken.cs,appendAttribute,The method has 5 parameters. Parameters: nameStart' nameEnd' valueStart' valueEnd' normalized
Long Parameter List,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,convert,The method has 5 parameters. Parameters: sourceBuf' sourceStart' sourceEnd' targetBuf' targetStart
Long Parameter List,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The method has 5 parameters. Parameters: nameStart' buf' off' end' token
Long Parameter List,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The method has 5 parameters. Parameters: open' buf' off' end' token
Long Parameter List,XpNet,UTF8Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The method has 5 parameters. Parameters: sourceBuf' sourceStart' sourceEnd' targetBuf' targetStart
Long Identifier,Jabber.Connection,Options,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.cs,,The length of the parameter NESTED_GROUPS_DEFAULT_DELIMITER is 31.
Long Identifier,Jabber.Connection,Options,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.cs,,The length of the parameter AUTO_STORE_NESTED_GROUPS_DELIMITER is 34.
Long Identifier,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,GetMappedAddressFrom,The length of the parameter remoteCertificateValidationHandler is 34.
Long Identifier,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,TurnManager,The length of the parameter remoteCertificateValidationHandler is 34.
Long Identifier,Jabber.Connection.SASL,SSPIHelper,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\KerbProcessor.cs,,The length of the parameter ISC_REQ_MANUAL_CRED_VALIDATION is 30.
Long Statement,Jabber.Client,JingleIceManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleIceManager.cs,CreateTurnSession,The length of the statement  "            TurnManager turnManager = new TurnManager(this.StunServerEP' ProtocolType.Tcp' this.TurnClientCertificate' this.TurnRemoteCertificateValidation); " is 145.
Long Statement,Jabber.Client,JingleIceManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleIceManager.cs,CreateTurnSession,The length of the statement  "            turnManager.OnConnectionAttemptReceived += new StunIndicationReceptionHandler(this.turnManager_OnConnectionAttemptReceived); " is 124.
Long Statement,Jabber.Client,JingleIceManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleIceManager.cs,turnManager_OnAllocateSucceed,The length of the statement  "                    this.OnIceCandidatesGathering(this' jingleIce' (sender as TurnManager).HostEP' this.turnSessions[this.StartingSessionSid].UseTurnOnly' allocation); " is 147.
Long Statement,Jabber.Client,PresenceManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\PresenceManager.Designer.cs,AddPresence,The length of the statement  "                "Do not call AddPresence by hand.  I can tell you are doing that because you didn't put a from address on your presence packet' and all presences from the server have a from address."); " is 185.
Long Statement,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The length of the statement  "            this.btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 145.
Long Statement,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The length of the statement  "            this.btnAllow.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 144.
Long Statement,Jabber.Connection,XmppStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,OnInvalidCertificate,The length of the statement  "            return (bool)m_invoker.Invoke(new RemoteCertificateValidationCallback(ShowCertificatePrompt)' new object[]{ sock' certificate' chain' sslPolicyErrors }); " is 153.
Long Statement,Jabber.Stun,StunClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,Connect,The length of the statement  "                throw new ArgumentException("StunClient socket is not null' you must close it before doing any new connection"' "this.Socket"); " is 127.
Long Statement,Jabber.Stun,StunClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,Connect,The length of the statement  "                localCertificateSelection = (sender' targetHost' localCertificates' remoteCertificate' acceptableIssuers) => localCertificates[0]; " is 130.
Long Statement,Jabber.Stun,StunClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,Connect,The length of the statement  "                IAsyncResult ar = this.SslStream.BeginAuthenticateAsClient(this.ServerEP.Address.ToString()' clientCertificates' SslProtocols.Tls' true' null' null); " is 149.
Long Statement,Jabber.Stun,StunClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,BeginSendMessage,The length of the statement  "                this.PendingTransactions.Add(msgToSend.TransactionID' new KeyValuePair<StunMessage' Object>(msgToSend' transactionObject)); " is 123.
Long Statement,Jabber.Stun,StunClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,BeginSendMessage,The length of the statement  "                this.Socket.BeginSend(msgToSend' 0' msgToSend.Bytes.Length' SocketFlags.None' new AsyncCallback(this.SendCallback)' null); " is 122.
Long Statement,Jabber.Stun,StunMessage,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,AddMessageIntegrity,The length of the statement  "                    throw new ArgumentException("USERNAME attribute is mandatory for long-term credentials MESSAGE-INTEGRITY creation"' "this.Username"); " is 133.
Long Statement,Jabber.Stun,StunMessage,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,AddMessageIntegrity,The length of the statement  "                    throw new ArgumentException("REALM attribute is mandatory for long-term credentials MESSAGE-INTEGRITY creation"' "this.Realm"); " is 127.
Long Statement,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,GetMappedAddressFrom,The length of the statement  "            StunClient cli = new StunClient(hostEP' serverEP' ProtocolType.Tcp' clientCertificate' remoteCertificateValidationHandler); " is 123.
Long Statement,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,AllocateRetry,The length of the statement  "            msg.Turn.RequestedTransport = new StunAttribute(StunAttributeType.RequestedTransport' BitConverter.GetBytes(StunMessage.CODE_POINT_TCP)); " is 137.
Long Statement,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,RefreshAllocation,The length of the statement  "            msg.Turn.LifeTime = new StunAttribute(StunAttributeType.LifeTime' BitConverter.GetBytes(StunUtilities.ReverseBytes(lifeTime))); " is 127.
Long Statement,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,CreatePermission,The length of the statement  "            StunMessage msg = new StunMessage(StunMethodType.CreatePermission' StunMethodClass.Request' StunUtilities.NewTransactionId); " is 124.
Long Statement,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,ConnectionBind,The length of the statement  "            this.TurnTcpManager.OnAllocateSucceed += (object sender' TurnAllocation allocation' StunMessage sentMsg' StunMessage receivedMsg) => " is 132.
Long Statement,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,ConnectionBind,The length of the statement  "                    StunMessage msg = new StunMessage(StunMethodType.ConnectionBind' StunMethodClass.Request' StunUtilities.NewTransactionId); " is 122.
Long Statement,Bedrock.IO,ZlibStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ZlibStream.cs,BeginWrite,The length of the statement  "                    ZlibStreamAsyncResult res = new ZlibStreamAsyncResult(state' new CompressionFailedException("Compress failed: " + err)); " is 120.
Long Statement,Bedrock.IO,ZlibStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ZlibStream.cs,BeginWrite,The length of the statement  "                return m_stream.BeginWrite(m_outbuf' 0' bufsize - m_out.avail_out' new AsyncCallback(IntermediateWrite)' new ZlibState(callback' state)); " is 137.
Long Statement,Bedrock.IO,ZlibStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\IO\ZlibStream.cs,IntermediateWrite,The length of the statement  "                    ZlibStreamAsyncResult res = new ZlibStreamAsyncResult(state.state' new CompressionFailedException("Compress failed: " + err)); " is 126.
Long Statement,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,CreateChildElement,The length of the statement  "            Debug.Assert(constructor != null' "Type " + typeof(T).ToString() + " does not have a constructor taking an XmlDocument"); " is 121.
Long Statement,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,CloneNode,The length of the statement  "            XmlElement el = (Element)ci.Invoke(new object[] { this.Prefix' new XmlQualifiedName(this.LocalName' this.NamespaceURI)' doc }); " is 127.
Complex Conditional,Bedrock.Net,ShttpProxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\ShttpProxy.cs,OnConnect,The conditional expression  "Username != null && Username.Length > 0 && Password != null && Password.Length > 0"  is complex.
Complex Conditional,Bedrock.Net,XEP124Socket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP124Socket.cs,OnConnect,The conditional expression  "!m_running &&                      m_sockA != null && m_sockA.Connected &&                      m_sockB != null && m_sockB.Connected"  is complex.
Complex Conditional,Jabber.Client,PingManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\PingManager.cs,GotIQ,The conditional expression  "!iq.Handled &&                  iq.Query != null && iq.Type == IQType.get &&                  iq.Query.NamespaceURI == URI.PING"  is complex.
Complex Conditional,Jabber.Client,JabberClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,FireOnIQ,The conditional expression  "this.SupportNestedGroups && !iq.Handled &&                  iq.Query != null && iq.Type == IQType.result &&                  iq.Query.NamespaceURI == URI.PRIVATE &&                  iq.GetChildElement<Private>().GetChildElement<RosterDelimiter>() != null"  is complex.
Complex Conditional,Jabber.Client,JabberClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,FireOnIQ,The conditional expression  "!iq.Handled && iq.HasAttribute("from") &&   // Belt.  Suspenders.  Don't respond to roster pushes.                      (iq.Type == IQType.get || iq.Type == IQType.set)"  is complex.
Complex Conditional,Jabber.Client,RosterManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RosterManager.Designer.cs,GotIQ,The conditional expression  "iq.Query == null ||                  iq.Query.NamespaceURI != URI.ROSTER ||                  (iq.Type != IQType.result && iq.Type != IQType.set)"  is complex.
Complex Conditional,Jabber.Connection,XmppStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,ProcessFeatures,The conditional expression  "(bool)this[Options.AUTO_TLS] &&                  m_features.StartTLS != null &&                  !m_sslOn &&                  m_stanzas.SupportsTLS"  is complex.
Complex Conditional,Jabber.Connection,XmppStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,ProcessFeatures,The conditional expression  "(bool)this[Options.AUTO_COMPRESS] &&                  comp != null &&                  comp.HasMethod("zlib") &&                  !m_compressionOn &&                  m_stanzas.SupportsCompression"  is complex.
Complex Conditional,Jabber.Connection,XmppStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,FireOnError,The conditional expression  "(State == ClosingState.Instance || State == ClosedState.Instance) &&                  (e is IOException || e.InnerException is IOException)"  is complex.
Complex Conditional,StringPrep.Steps,NFKCStep,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\StringPrep\Steps\NFKCStep.cs,Comp,The conditional expression  "(i > 0) &&                      ((last_cc == 0) || (last_cc != cc)) &&                      Compose.Combine(result[last_start]' result[i]' out c)"  is complex.
Complex Conditional,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The conditional expression  "end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';')"  is complex.
Complex Conditional,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The conditional expression  "end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';')"  is complex.
Complex Conditional,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The conditional expression  "normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open)))"  is complex.
Empty Catch Block,Bedrock.Net,Address,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Address.cs,LookupTXT,The method has an empty catch block.
Empty Catch Block,Bedrock.Net,AsyncSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,Close,The method has an empty catch block.
Empty Catch Block,Bedrock.Net,XEP25Socket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,The method has an empty catch block.
Empty Catch Block,Jabber.Stun,StunClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,Jabber,JID,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\JID.cs,TryParse,The method has an empty catch block.
Empty Catch Block,Jabber.Protocol,AsynchElementStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The method has an empty catch block.
Empty Catch Block,Jabber.Protocol,AsynchElementStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The method has an empty catch block.
Magic Number,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,GETSHORT,The following statement contains a magic number: ushort s = (ushort)(((ushort)t_cp[0] << 8) | ((ushort)t_cp[1]));
Magic Number,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: byte[] buffer = new byte[1024];
Magic Number,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: byte[] name = new byte[256];
Magic Number,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: size = dn_expand(pBuffer' end' pos' name' 256);
Magic Number,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: pos += size + 4;
Magic Number,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: size = dn_expand(pBuffer' end' pos' name' 256);
Magic Number,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: pos += 6;
Magic Number,Bedrock.Net,UnixDnsResolver,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\UnixDnsResolver.cs,ResolveSRV,The following statement contains a magic number: size = dn_expand(pBuffer' end' pos' name' 256);
Magic Number,Bedrock.Net,AsyncSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\AsyncSocket.cs,OnConnectResolved,The following statement contains a magic number: m_sock.SetSocketOption(SocketOptionLevel.Socket'                      SocketOptionName.ReceiveBuffer'                      4 * m_buf.Length);
Magic Number,Bedrock.Net,BaseSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\BaseSocket.cs,Accept,The following statement contains a magic number: Accept(addr' 5);
Magic Number,Bedrock.Net,HttpSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,Execute,The following statement contains a magic number: Monitor.Wait(m_lock' (int)(m_connectRetrySec * 1000));
Magic Number,Bedrock.Net,HttpSocket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\HttpSocket.cs,Send,The following statement contains a magic number: MemoryStream ms = new MemoryStream(req.Length + 256);
Magic Number,Bedrock.Net,ShttpProxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\ShttpProxy.cs,OnRead,The following statement contains a magic number: switch (m_state)              {              case States.WaitingForAuth:                  m_headerstream.Write(buf' offset' length);                  int state = 0;                  int line = 0;                  foreach (byte b in buf)                  {                      // Look for \r\n\r\n for end of response header                      switch (state)                      {                      case 0:                          if (b == '\r')                              state++;                          break;                      case 1:                          if (b == '\n')                          {                              byte[] hs = m_headerstream.ToArray();                              string s = System.Text.Encoding.UTF8.GetString(hs);                              Debug.Write("PRECV: " + s);                              m_headers.Add(s);                              m_headerstream.SetLength(0);                              state++;                              line++;                          }                          else                              state = 0;                          break;                      case 2:                          if (b == '\r')                              state++;                          else                              state = 0;                          break;                      case 3:                          if (b == '\n')                          {                              Debug.WriteLine("End of proxy headers");                              string line0 = (string)m_headers[0];                              if (line0.IndexOf("200") == -1)                              {                                  Debug.WriteLine("200 response not detected.  Closing.");                                  m_state = States.Error;                                  this.Close();                              }                              else                              {                                  Debug.WriteLine("Proxy connected");                                  m_listener.OnConnect(sock); // tell the real listener that we're connected.                                  m_state = States.Running;                              }                              // they'll call RequestRead()' so we can return false here.                              return false;                          }                          else                              state = 0;                          break;                      }                  }                  return true;              case States.Error:                  throw new InvalidOperationException("Cannot read after error");              default:                  return base.OnRead(sock' buf' offset' length);              }
Magic Number,Bedrock.Net,ShttpProxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\ShttpProxy.cs,OnRead,The following statement contains a magic number: switch (m_state)              {              case States.WaitingForAuth:                  m_headerstream.Write(buf' offset' length);                  int state = 0;                  int line = 0;                  foreach (byte b in buf)                  {                      // Look for \r\n\r\n for end of response header                      switch (state)                      {                      case 0:                          if (b == '\r')                              state++;                          break;                      case 1:                          if (b == '\n')                          {                              byte[] hs = m_headerstream.ToArray();                              string s = System.Text.Encoding.UTF8.GetString(hs);                              Debug.Write("PRECV: " + s);                              m_headers.Add(s);                              m_headerstream.SetLength(0);                              state++;                              line++;                          }                          else                              state = 0;                          break;                      case 2:                          if (b == '\r')                              state++;                          else                              state = 0;                          break;                      case 3:                          if (b == '\n')                          {                              Debug.WriteLine("End of proxy headers");                              string line0 = (string)m_headers[0];                              if (line0.IndexOf("200") == -1)                              {                                  Debug.WriteLine("200 response not detected.  Closing.");                                  m_state = States.Error;                                  this.Close();                              }                              else                              {                                  Debug.WriteLine("Proxy connected");                                  m_listener.OnConnect(sock); // tell the real listener that we're connected.                                  m_state = States.Running;                              }                              // they'll call RequestRead()' so we can return false here.                              return false;                          }                          else                              state = 0;                          break;                      }                  }                  return true;              case States.Error:                  throw new InvalidOperationException("Cannot read after error");              default:                  return base.OnRead(sock' buf' offset' length);              }
Magic Number,Bedrock.Net,SocketWatcher,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\SocketWatcher.cs,CreateListenSocket,The following statement contains a magic number: return CreateListenSocket(listener' addr' 5' SSL);
Magic Number,Bedrock.Net,SocketWatcher,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\SocketWatcher.cs,CreateListenSocket,The following statement contains a magic number: return CreateListenSocket(listener' addr' 5' false);
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,HandleRequestResponse,The following statement contains a magic number: reply != 90
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: byte [] buffer = new Byte[14];
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[0] = 4;
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[2] = (byte)(port >> 8);
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[2] = (byte)(port >> 8);
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[3] = (byte)port;
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[4] = addr[3];
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[4] = addr[3];
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[5] = addr[2];
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[5] = addr[2];
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[6] = addr[1];
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[7] = addr[0];
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[8] = (byte)'i';
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[9] = (byte)'d';
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[10] = (byte)'e';
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[11] = (byte)'n';
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[12] = (byte)'t';
Magic Number,Bedrock.Net,Socks4Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer[13] = 0;
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: byte [] buffer = new Byte[7 + n];
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[0] = 5;
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[2] = 0;
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[3] = 3;
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[3] = 3;
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[4] = (byte)n;
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: host.CopyTo(buffer' 5);
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[5+n] = (byte)(RemoteAddress.Port >> 8);
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[5+n] = (byte)(RemoteAddress.Port >> 8);
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer[6+n] = (byte)RemoteAddress.Port;
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: ver != 5
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method)              {                  case 2:                      /*                       * +----+------+----------+------+----------+                       * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                       * +----+------+----------+------+----------+                       * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                       * +----+------+----------+------+----------+                       */                      m_state = States.WaitingForAuth;                      byte [] buffer = new Byte[3 + Username.Length + Password.Length];                      buffer[0] = 1; // version of this subnegotiation.                      buffer[1] = (byte)Username.Length;                      Encoding.ASCII.GetBytes(Username' 0' Username.Length' buffer' 2);                      int pw_offset = 2 + Username.Length;                      buffer[pw_offset] = (byte)Password.Length;                      Encoding.ASCII.GetBytes(Password' 0' Password.Length' buffer' pw_offset + 1);                      Debug.WriteLine("sending plain auth to proxy");                      Write(buffer);                      return true;                  case 0:                      RequestProxyConnection();                      return true;                  default:                      Debug.WriteLine("bogus auth method: " + method);                      return false;              }
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method)              {                  case 2:                      /*                       * +----+------+----------+------+----------+                       * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                       * +----+------+----------+------+----------+                       * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                       * +----+------+----------+------+----------+                       */                      m_state = States.WaitingForAuth;                      byte [] buffer = new Byte[3 + Username.Length + Password.Length];                      buffer[0] = 1; // version of this subnegotiation.                      buffer[1] = (byte)Username.Length;                      Encoding.ASCII.GetBytes(Username' 0' Username.Length' buffer' 2);                      int pw_offset = 2 + Username.Length;                      buffer[pw_offset] = (byte)Password.Length;                      Encoding.ASCII.GetBytes(Password' 0' Password.Length' buffer' pw_offset + 1);                      Debug.WriteLine("sending plain auth to proxy");                      Write(buffer);                      return true;                  case 0:                      RequestProxyConnection();                      return true;                  default:                      Debug.WriteLine("bogus auth method: " + method);                      return false;              }
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method)              {                  case 2:                      /*                       * +----+------+----------+------+----------+                       * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                       * +----+------+----------+------+----------+                       * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                       * +----+------+----------+------+----------+                       */                      m_state = States.WaitingForAuth;                      byte [] buffer = new Byte[3 + Username.Length + Password.Length];                      buffer[0] = 1; // version of this subnegotiation.                      buffer[1] = (byte)Username.Length;                      Encoding.ASCII.GetBytes(Username' 0' Username.Length' buffer' 2);                      int pw_offset = 2 + Username.Length;                      buffer[pw_offset] = (byte)Password.Length;                      Encoding.ASCII.GetBytes(Password' 0' Password.Length' buffer' pw_offset + 1);                      Debug.WriteLine("sending plain auth to proxy");                      Write(buffer);                      return true;                  case 0:                      RequestProxyConnection();                      return true;                  default:                      Debug.WriteLine("bogus auth method: " + method);                      return false;              }
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method)              {                  case 2:                      /*                       * +----+------+----------+------+----------+                       * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                       * +----+------+----------+------+----------+                       * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                       * +----+------+----------+------+----------+                       */                      m_state = States.WaitingForAuth;                      byte [] buffer = new Byte[3 + Username.Length + Password.Length];                      buffer[0] = 1; // version of this subnegotiation.                      buffer[1] = (byte)Username.Length;                      Encoding.ASCII.GetBytes(Username' 0' Username.Length' buffer' 2);                      int pw_offset = 2 + Username.Length;                      buffer[pw_offset] = (byte)Password.Length;                      Encoding.ASCII.GetBytes(Password' 0' Password.Length' buffer' pw_offset + 1);                      Debug.WriteLine("sending plain auth to proxy");                      Write(buffer);                      return true;                  case 0:                      RequestProxyConnection();                      return true;                  default:                      Debug.WriteLine("bogus auth method: " + method);                      return false;              }
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,HandleRequestResponse,The following statement contains a magic number: ver != 5
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: byte [] buffer = new Byte[4];
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: buffer[0] = 5;
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: buffer[1] = 2;
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: buffer[2] = 0;
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: buffer[3] = 2;
Magic Number,Bedrock.Net,Socks5Proxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: buffer[3] = 2;
Magic Number,Bedrock.Net,XEP124Socket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP124Socket.cs,OnRead,The following statement contains a magic number: m_listener.OnRead(this' buf' start' offset + length - start - 7)
Magic Number,Bedrock.Net,XEP25Socket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,GenKeys,The following statement contains a magic number: byte[] seed = new byte[32];
Magic Number,Bedrock.Net,XEP25Socket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,The following statement contains a magic number: CookieContainer cookies = new CookieContainer(5);
Magic Number,Bedrock.Net,XEP25Socket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,The following statement contains a magic number: byte[] readbuf = new byte[1024];
Magic Number,Bedrock.Net,XEP25Socket,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\XEP25Socket.cs,PollThread,The following statement contains a magic number: Monitor.Wait(m_lock' (int)(m_curPoll * 1000.0));
Magic Number,Bedrock.Util,IdleTime,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\IdleTime.Designer.cs,GetIdleTime,The following statement contains a magic number: return (Environment.TickCount - lii.dwTime) / 1000.0;
Magic Number,Bedrock.Util,IdleTime,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\IdleTime.Designer.cs,IdleTime,The following statement contains a magic number: m_timer = new System.Timers.Timer(DEFAULT_POLL * 1000.0);
Magic Number,Bedrock.Util,IdleTime,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\IdleTime.Designer.cs,Idle,The following statement contains a magic number: TimeSpan span = new TimeSpan((long)(idle * 1000L));
Magic Number,Bedrock.Util,GetOpt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\GetOptBase.cs,UsageExit,The following statement contains a magic number: Environment.Exit(64);
Magic Number,Bedrock.Util,GetOpt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\GetOptBase.cs,UsageGUIExit,The following statement contains a magic number: Environment.Exit(64);
Magic Number,Bedrock.Util,SourceSafeAttribute,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Util\Version.cs,Parse,The following statement contains a magic number: m_date = m_date.AddHours(12);
Magic Number,Jabber.Client,JabberClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,Presence,The following statement contains a magic number: (priority < -128) || (priority > 127)
Magic Number,Jabber.Client,JabberClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JabberClient.Designer.cs,Presence,The following statement contains a magic number: (priority < -128) || (priority > 127)
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label1.Location = new System.Drawing.Point(12' 9);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label1.Location = new System.Drawing.Point(12' 9);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label1.Size = new System.Drawing.Size(77' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label1.Size = new System.Drawing.Size(77' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label1.TabIndex = 2;
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label2.Location = new System.Drawing.Point(12' 36);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label2.Location = new System.Drawing.Point(12' 36);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label2.Size = new System.Drawing.Size(63' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label2.Size = new System.Drawing.Size(63' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label2.TabIndex = 3;
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label3.Location = new System.Drawing.Point(12' 64);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label3.Location = new System.Drawing.Point(12' 64);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label3.Size = new System.Drawing.Size(55' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label3.Size = new System.Drawing.Size(55' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: label3.TabIndex = 4;
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(0' 134);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(500' 44);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(500' 44);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(413' 9);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(413' 9);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 2;
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnAllow.Location = new System.Drawing.Point(332' 9);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnAllow.Location = new System.Drawing.Point(332' 9);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnAllow.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnAllow.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblSubject.Location = new System.Drawing.Point(126' 9);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblSubject.Location = new System.Drawing.Point(126' 9);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblSubject.Size = new System.Drawing.Size(43' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblSubject.Size = new System.Drawing.Size(43' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblSubject.TabIndex = 5;
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblBegin.Location = new System.Drawing.Point(126' 36);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblBegin.Location = new System.Drawing.Point(126' 36);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblBegin.Size = new System.Drawing.Size(34' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblBegin.Size = new System.Drawing.Size(34' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblBegin.TabIndex = 6;
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblEnd.Location = new System.Drawing.Point(126' 64);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblEnd.Location = new System.Drawing.Point(126' 64);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblEnd.Size = new System.Drawing.Size(26' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblEnd.Size = new System.Drawing.Size(26' 13);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.lblEnd.TabIndex = 7;
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Location = new System.Drawing.Point(14' 90);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Location = new System.Drawing.Point(14' 90);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Size = new System.Drawing.Size(75' 23);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.TabIndex = 8;
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(500' 178);
Magic Number,Jabber.Connection,CertificatePrompt,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CertificatePrompt.Designer.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(500' 178);
Magic Number,Jabber.Connection,BindingStanzaStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\BindingStanzaStream.cs,CreateSocket,The following statement contains a magic number: port = 80;
Magic Number,Jabber.Connection,SocketStanzaStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SocketStanzaStream.cs,DoKeepAlive,The following statement contains a magic number: m_sock.Write(new byte[] { 32 });
Magic Number,Jabber.Protocol.IQ,JingleIce,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Debug.Assert(port > 1024);
Magic Number,Jabber.Protocol.IQ,JingleIce,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Protocol.IQ,JingleIce,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Protocol.IQ,JingleIce,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Protocol.IQ,JingleIce,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Protocol.IQ,JingleIce,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Protocol.IQ,JingleIce,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\IQ\JingleIce.cs,AddCandidate,The following statement contains a magic number: Double priority = Math.Pow(2' 24) * (Int32)type +                                Math.Pow(2' 8) * localPriority +                                Math.Pow(2' 0) * (256 - component);
Magic Number,Jabber.Stun.Attributes,MappedAddress,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\Attributes\AddressAttributes.cs,MappedAddress,The following statement contains a magic number: this.Value = new byte[8];
Magic Number,Jabber.Stun.Attributes,XorMappedAddress,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\Attributes\AddressAttributes.cs,XorMappedAddress,The following statement contains a magic number: this.Value = new byte[8];
Magic Number,Jabber.Stun.Attributes,UnknownAttributes,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\Attributes\UnknownAttributes.cs,UnknownAttributes,The following statement contains a magic number: byte[] unknownAttrBytes = StunUtilities.SubArray(this.Value' offset' 2);
Magic Number,Jabber.Stun.Attributes,UnknownAttributes,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\Attributes\UnknownAttributes.cs,UnknownAttributes,The following statement contains a magic number: offset += 2;
Magic Number,Jabber.Stun,HolePuncher,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\HolePuncher.cs,TcpPunchThreadStart,The following statement contains a magic number: result.AsyncWaitHandle.WaitOne(3000' true);
Magic Number,Jabber.Stun,HolePuncher,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\HolePuncher.cs,TcpPunchThreadStart,The following statement contains a magic number: nbTries == 3 || client.Client.Connected
Magic Number,Jabber.Stun,StunAttribute,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunAttribute.cs,StunAttribute,The following statement contains a magic number: switch (type)              {                  case StunAttributeType.Software:                  case StunAttributeType.Realm:                  case StunAttributeType.Nonce:                  case StunAttributeType.ErrorCode:                      if (value.Length > 763)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 763 bytes for the given type as described in RFC 5389");                      break;                    case StunAttributeType.Username:                      if (value.Length > 513)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 513 bytes for the given type as described in RFC 5389");                      break;              }
Magic Number,Jabber.Stun,StunAttribute,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunAttribute.cs,StunAttribute,The following statement contains a magic number: switch (type)              {                  case StunAttributeType.Software:                  case StunAttributeType.Realm:                  case StunAttributeType.Nonce:                  case StunAttributeType.ErrorCode:                      if (value.Length > 763)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 763 bytes for the given type as described in RFC 5389");                      break;                    case StunAttributeType.Username:                      if (value.Length > 513)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 513 bytes for the given type as described in RFC 5389");                      break;              }
Magic Number,Jabber.Stun,StunMessage,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ComputeHMAC,The following statement contains a magic number: UInt16 dummyLength = StunUtilities.ReverseBytes((UInt16)(thisCopy.MessageLength + 24));
Magic Number,Jabber.Stun,StunMessage,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ComputeHMAC,The following statement contains a magic number: BitConverter.GetBytes(dummyLength).CopyTo(thisCopyBytes' 2);
Magic Number,Jabber.Stun,StunMessage,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: UInt16 valueLength = BitConverter.ToUInt16(StunUtilities.SubArray(attributes' offset + 2' 2)' 0);
Magic Number,Jabber.Stun,StunMessage,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: UInt16 valueLength = BitConverter.ToUInt16(StunUtilities.SubArray(attributes' offset + 2' 2)' 0);
Magic Number,Jabber.Stun,StunMessage,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: UInt16 attributeLength = (UInt16)(StunUtilities.ReverseBytes(valueLength) + 4);
Magic Number,Jabber.Stun,StunMessage,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: attributeLength = (UInt16)(attributeLength + (4 - attributeLength % 4));
Magic Number,Jabber.Stun,StunMessage,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: attributeLength = (UInt16)(attributeLength + (4 - attributeLength % 4));
Magic Number,Jabber.Stun,StunMessage,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunMessage.cs,ImportAttributes,The following statement contains a magic number: attributeLength % 4 != 0
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,PadTo32Bits,The following statement contains a magic number: Int32 neededPadding = value.Length % 4;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,PadTo32Bits,The following statement contains a magic number: switch (neededPadding)              {                  case 0:                  default:                      return value;                    case 1:                      result = new byte[value.Length + 3];                        value.CopyTo(result' 0);                      new byte[] { 0' 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 2:                      result = new byte[value.Length + 2];                        value.CopyTo(result' 0);                      new byte[] { 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 3:                      result = new byte[value.Length + 1];                        value.CopyTo(result' 0);                      new byte[] { 0 }.CopyTo(result' value.Length);                        return result;              }
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,PadTo32Bits,The following statement contains a magic number: switch (neededPadding)              {                  case 0:                  default:                      return value;                    case 1:                      result = new byte[value.Length + 3];                        value.CopyTo(result' 0);                      new byte[] { 0' 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 2:                      result = new byte[value.Length + 2];                        value.CopyTo(result' 0);                      new byte[] { 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 3:                      result = new byte[value.Length + 1];                        value.CopyTo(result' 0);                      new byte[] { 0 }.CopyTo(result' value.Length);                        return result;              }
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,PadTo32Bits,The following statement contains a magic number: switch (neededPadding)              {                  case 0:                  default:                      return value;                    case 1:                      result = new byte[value.Length + 3];                        value.CopyTo(result' 0);                      new byte[] { 0' 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 2:                      result = new byte[value.Length + 2];                        value.CopyTo(result' 0);                      new byte[] { 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 3:                      result = new byte[value.Length + 1];                        value.CopyTo(result' 0);                      new byte[] { 0 }.CopyTo(result' value.Length);                        return result;              }
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,PadTo32Bits,The following statement contains a magic number: switch (neededPadding)              {                  case 0:                  default:                      return value;                    case 1:                      result = new byte[value.Length + 3];                        value.CopyTo(result' 0);                      new byte[] { 0' 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 2:                      result = new byte[value.Length + 2];                        value.CopyTo(result' 0);                      new byte[] { 0' 0 }.CopyTo(result' value.Length);                        return result;                    case 3:                      result = new byte[value.Length + 1];                        value.CopyTo(result' 0);                      new byte[] { 0 }.CopyTo(result' value.Length);                        return result;              }
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (UInt16)((value & 0xFFU) << 8 | (value & 0xFF00U) >> 8);
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (UInt16)((value & 0xFFU) << 8 | (value & 0xFF00U) >> 8);
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |                     (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |                     (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |                     (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |                     (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,StunUtilities,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunUtilities.cs,ReverseBytes,The following statement contains a magic number: return (value & 0x00000000000000FFUL) << 56 | (value & 0x000000000000FF00UL) << 40 |                     (value & 0x0000000000FF0000UL) << 24 | (value & 0x00000000FF000000UL) << 8 |                     (value & 0x000000FF00000000UL) >> 8 | (value & 0x0000FF0000000000UL) >> 24 |                     (value & 0x00FF000000000000UL) >> 40 | (value & 0xFF00000000000000UL) >> 56;
Magic Number,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,StunClient_OnReceivedSuccessResponse,The following statement contains a magic number: switch (receivedMsg.MethodType)              {                  case StunMethodType.Allocate:                      TurnAllocation allocation = new TurnAllocation()                      {                          Username = sentMsg.Stun.Username.ValueString'                          Password = transactionObject as String'                          Realm = sentMsg.Stun.Realm.ValueString'                          Nonce = sentMsg.Stun.Nonce.ValueString'                          RelayedMappedAddress = receivedMsg.Turn.XorRelayedAddress'                          MappedAddress = receivedMsg.Stun.XorMappedAddress'                          StartTime = DateTime.Now'                          LifeTime = StunUtilities.ReverseBytes(BitConverter.ToUInt32(receivedMsg.Turn.LifeTime.Value' 0))                      };                        if (this.Allocations.ContainsKey(receivedMsg.Turn.XorRelayedAddress))                          this.Allocations[receivedMsg.Turn.XorRelayedAddress] = allocation;                      else                      {                          this.Allocations.Add(receivedMsg.Turn.XorRelayedAddress' allocation);                            if (this.OnAllocateSucceed != null)                              this.OnAllocateSucceed(this' allocation' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.CreatePermission:                      TurnPermission permission = new TurnPermission()                      {                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 300                      };                      TurnAllocation permAllocation = transactionObject as TurnAllocation;                        if (permAllocation.Permissions.ContainsKey(sentMsg.Turn.XorPeerAddress))                          permAllocation.Permissions[sentMsg.Turn.XorPeerAddress] = permission;                      else                      {                          permAllocation.Permissions.Add(sentMsg.Turn.XorPeerAddress' permission);                            if (this.OnCreatePermissionSucceed != null)                              this.OnCreatePermissionSucceed(this' permAllocation' permission' sentMsg' receivedMsg);                      }                        break;                    case StunMethodType.ChannelBind:                      TurnChannel channel = new TurnChannel()                      {                          Channel = sentMsg.Turn.ChannelNumber'                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 600                      };                      TurnAllocation channelAllocation = transactionObject as TurnAllocation;                        if (channelAllocation.Channels.ContainsKey(sentMsg.Turn.ChannelNumber))                          channelAllocation.Channels[sentMsg.Turn.ChannelNumber] = channel;                      else                      {                          channelAllocation.Channels.Add(sentMsg.Turn.ChannelNumber' channel);                            if (this.OnChannelBindSucceed != null)                              this.OnChannelBindSucceed(this' transactionObject as TurnAllocation' channel' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.ConnectionBind:                      if (this.OnConnectionBindSucceed != null)                          this.OnConnectionBindSucceed(this' transactionObject as Socket' receivedMsg);                      break;              }
Magic Number,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,StunClient_OnReceivedSuccessResponse,The following statement contains a magic number: switch (receivedMsg.MethodType)              {                  case StunMethodType.Allocate:                      TurnAllocation allocation = new TurnAllocation()                      {                          Username = sentMsg.Stun.Username.ValueString'                          Password = transactionObject as String'                          Realm = sentMsg.Stun.Realm.ValueString'                          Nonce = sentMsg.Stun.Nonce.ValueString'                          RelayedMappedAddress = receivedMsg.Turn.XorRelayedAddress'                          MappedAddress = receivedMsg.Stun.XorMappedAddress'                          StartTime = DateTime.Now'                          LifeTime = StunUtilities.ReverseBytes(BitConverter.ToUInt32(receivedMsg.Turn.LifeTime.Value' 0))                      };                        if (this.Allocations.ContainsKey(receivedMsg.Turn.XorRelayedAddress))                          this.Allocations[receivedMsg.Turn.XorRelayedAddress] = allocation;                      else                      {                          this.Allocations.Add(receivedMsg.Turn.XorRelayedAddress' allocation);                            if (this.OnAllocateSucceed != null)                              this.OnAllocateSucceed(this' allocation' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.CreatePermission:                      TurnPermission permission = new TurnPermission()                      {                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 300                      };                      TurnAllocation permAllocation = transactionObject as TurnAllocation;                        if (permAllocation.Permissions.ContainsKey(sentMsg.Turn.XorPeerAddress))                          permAllocation.Permissions[sentMsg.Turn.XorPeerAddress] = permission;                      else                      {                          permAllocation.Permissions.Add(sentMsg.Turn.XorPeerAddress' permission);                            if (this.OnCreatePermissionSucceed != null)                              this.OnCreatePermissionSucceed(this' permAllocation' permission' sentMsg' receivedMsg);                      }                        break;                    case StunMethodType.ChannelBind:                      TurnChannel channel = new TurnChannel()                      {                          Channel = sentMsg.Turn.ChannelNumber'                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 600                      };                      TurnAllocation channelAllocation = transactionObject as TurnAllocation;                        if (channelAllocation.Channels.ContainsKey(sentMsg.Turn.ChannelNumber))                          channelAllocation.Channels[sentMsg.Turn.ChannelNumber] = channel;                      else                      {                          channelAllocation.Channels.Add(sentMsg.Turn.ChannelNumber' channel);                            if (this.OnChannelBindSucceed != null)                              this.OnChannelBindSucceed(this' transactionObject as TurnAllocation' channel' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.ConnectionBind:                      if (this.OnConnectionBindSucceed != null)                          this.OnConnectionBindSucceed(this' transactionObject as Socket' receivedMsg);                      break;              }
Magic Number,Jabber.Stun,TurnAllocation,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnObjects.cs,StartAutoRefresh,The following statement contains a magic number: this.refreshTimer.Interval = (this.LifeTime * 1000) - 60000;
Magic Number,Jabber.Stun,TurnAllocation,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnObjects.cs,StartAutoRefresh,The following statement contains a magic number: this.refreshTimer.Interval = (this.LifeTime * 1000) - 60000;
Magic Number,Jabber.Stun,TurnAllocation,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnObjects.cs,AutoRefresh,The following statement contains a magic number: this.refreshTimer.Interval = (this.LifeTime * 1000) - 60000;
Magic Number,Jabber.Stun,TurnAllocation,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnObjects.cs,AutoRefresh,The following statement contains a magic number: this.refreshTimer.Interval = (this.LifeTime * 1000) - 60000;
Magic Number,Bedrock.Collections,LinkedList,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Collections\LinkedList.cs,GetNode,The following statement contains a magic number: index < m_size/2
Magic Number,Jabber.Connection.SASL,MD5Processor,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\MD5Processor.cs,generateResponseString,The following statement contains a magic number: int v = r.Next(1024);
Magic Number,Jabber.Connection.SASL,MD5Processor,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\MD5Processor.cs,generateResponseString,The following statement contains a magic number: m_ncString = m_nc.ToString().PadLeft(8''0');
Magic Number,Jabber.Connection.SASL,MD5Processor,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\SASL\MD5Processor.cs,generateResponseString,The following statement contains a magic number: ms.Write(H1'0'16);
Magic Number,Jabber.Protocol,AsynchElementStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: switch (tok)                      {                      case TOK.EMPTY_ELEMENT_NO_ATTS:                      case TOK.EMPTY_ELEMENT_WITH_ATTS:                          StartTag(b' off' ct' tok);                          EndTag(b' off' ct' tok);                          break;                      case TOK.START_TAG_NO_ATTS:                      case TOK.START_TAG_WITH_ATTS:                          StartTag(b' off' ct' tok);                          break;                      case TOK.END_TAG:                          EndTag(b' off' ct' tok);                          break;                      case TOK.DATA_CHARS:                      case TOK.DATA_NEWLINE:                          AddText(utf.GetString(b' off' ct.TokenEnd - off));                          break;                      case TOK.CHAR_REF:                      case TOK.MAGIC_ENTITY_REF:                          AddText(new string(new char[] { ct.RefChar1 }));                          break;                      case TOK.CHAR_PAIR_REF:                          AddText(new string(new char[] {ct.RefChar1'                                                                ct.RefChar2}));                          break;                      case TOK.COMMENT:                          if (m_elem != null)                          {                              // <!-- 4                              //  --> 3                              int start = off + 4*m_enc.MinBytesPerChar;                              int end = ct.TokenEnd - off -                                      7*m_enc.MinBytesPerChar;                              string text = utf.GetString(b' start' end);                              m_elem.AppendChild(m_doc.CreateComment(text));                          }                          break;                      case TOK.CDATA_SECT_OPEN:                          m_cdata = true;                          break;                      case TOK.CDATA_SECT_CLOSE:                          m_cdata = false;                          break;                      case TOK.XML_DECL:                          // thou shalt use UTF8' and XML version 1.                          // i shall ignore evidence to the contrary...                            // TODO: Throw an exception if these assuptions are                          // wrong                          break;                      case TOK.ENTITY_REF:                      case TOK.PI:                          throw new System.NotImplementedException("Token type not implemented: " + tok);                      }
Magic Number,Jabber.Protocol,AsynchElementStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: switch (tok)                      {                      case TOK.EMPTY_ELEMENT_NO_ATTS:                      case TOK.EMPTY_ELEMENT_WITH_ATTS:                          StartTag(b' off' ct' tok);                          EndTag(b' off' ct' tok);                          break;                      case TOK.START_TAG_NO_ATTS:                      case TOK.START_TAG_WITH_ATTS:                          StartTag(b' off' ct' tok);                          break;                      case TOK.END_TAG:                          EndTag(b' off' ct' tok);                          break;                      case TOK.DATA_CHARS:                      case TOK.DATA_NEWLINE:                          AddText(utf.GetString(b' off' ct.TokenEnd - off));                          break;                      case TOK.CHAR_REF:                      case TOK.MAGIC_ENTITY_REF:                          AddText(new string(new char[] { ct.RefChar1 }));                          break;                      case TOK.CHAR_PAIR_REF:                          AddText(new string(new char[] {ct.RefChar1'                                                                ct.RefChar2}));                          break;                      case TOK.COMMENT:                          if (m_elem != null)                          {                              // <!-- 4                              //  --> 3                              int start = off + 4*m_enc.MinBytesPerChar;                              int end = ct.TokenEnd - off -                                      7*m_enc.MinBytesPerChar;                              string text = utf.GetString(b' start' end);                              m_elem.AppendChild(m_doc.CreateComment(text));                          }                          break;                      case TOK.CDATA_SECT_OPEN:                          m_cdata = true;                          break;                      case TOK.CDATA_SECT_CLOSE:                          m_cdata = false;                          break;                      case TOK.XML_DECL:                          // thou shalt use UTF8' and XML version 1.                          // i shall ignore evidence to the contrary...                            // TODO: Throw an exception if these assuptions are                          // wrong                          break;                      case TOK.ENTITY_REF:                      case TOK.PI:                          throw new System.NotImplementedException("Token type not implemented: " + tok);                      }
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,GetByteAttr,The following statement contains a magic number: return 255;
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,SetByteAttr,The following statement contains a magic number: val == 255
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));
Magic Number,Jabber.Protocol,Element,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime(int.Parse(dt.Substring(0' 4))'                                      int.Parse(dt.Substring(4' 2))'                                      int.Parse(dt.Substring(6' 2))'                                      int.Parse(dt.Substring(9'2))'                                      int.Parse(dt.Substring(12'2))'                                      int.Parse(dt.Substring(15'2)));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(BAD_REQUEST' new CodeType(400' ErrorType.modify));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(CONFLICT' new CodeType(409' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(FEATURE_NOT_IMPLEMENTED' new CodeType(501' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(FORBIDDEN' new CodeType(403' ErrorType.auth));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(GONE' new CodeType(302' ErrorType.modify));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(INTERNAL_SERVER_ERROR' new CodeType(500' ErrorType.wait));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(ITEM_NOT_FOUND' new CodeType(404' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(JID_MALFORMED' new CodeType(400' ErrorType.modify));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(NOT_ACCEPTABLE' new CodeType(406' ErrorType.modify));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(NOT_ALLOWED' new CodeType(405' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(NOT_AUTHORIZED' new CodeType(401' ErrorType.auth));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(PAYMENT_REQUIRED' new CodeType(402' ErrorType.auth));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(RECIPIENT_UNAVAILABLE' new CodeType(404' ErrorType.wait));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(REDIRECT' new CodeType(302' ErrorType.modify));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(REGISTRATION_REQUIRED' new CodeType(407' ErrorType.auth));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(REMOTE_SERVER_NOT_FOUND' new CodeType(404' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(REMOTE_SERVER_TIMEOUT' new CodeType(504' ErrorType.wait));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(RESOURCE_CONSTRAINT' new CodeType(500' ErrorType.wait));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(SERVICE_UNAVAILABLE' new CodeType(503' ErrorType.cancel));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(SUBSCRIPTION_REQUIRED' new CodeType(407' ErrorType.auth));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(UNDEFINED_CONDITION' new CodeType(500' ErrorType.NONE));
Magic Number,Jabber.Protocol.Client,Error,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Error.cs,Error,The following statement contains a magic number: s_errors.Add(UNEXPECTED_REQUEST' new CodeType(400' ErrorType.wait));
Magic Number,Jabber.Protocol.Client,Presence,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Presence.cs,IntShow,The following statement contains a magic number: switch (show)              {              case "dnd":                  return 0;              case "xa":                  return 1;              case "away":                  return 2;              case "chat":                  return 4;              default:                  return 3;              }
Magic Number,Jabber.Protocol.Client,Presence,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Presence.cs,IntShow,The following statement contains a magic number: switch (show)              {              case "dnd":                  return 0;              case "xa":                  return 1;              case "away":                  return 2;              case "chat":                  return 4;              default:                  return 3;              }
Magic Number,Jabber.Protocol.Client,Presence,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\Presence.cs,IntShow,The following statement contains a magic number: switch (show)              {              case "dnd":                  return 0;              case "xa":                  return 1;              case "away":                  return 2;              case "chat":                  return 4;              default:                  return 3;              }
Magic Number,Jabber.Protocol.Client,IQException,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Client\ProtocolException.cs,IQException,The following statement contains a magic number: m_code = 504;
Magic Number,Jabber.Protocol.Stream,Stream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\Stream\Stream.cs,Stream,The following statement contains a magic number: byte[] buf = new byte[4];
Magic Number,StringPrep.Unicode,Combining,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\StringPrep\Unicode\Combining.cs,Class,The following statement contains a magic number: int page = c >> 8;
Magic Number,StringPrep.Unicode,Combining,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\StringPrep\Unicode\Combining.cs,Class,The following statement contains a magic number: CombiningData.Pages[page] == 255
Magic Number,StringPrep.Unicode,Compose,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\StringPrep\Unicode\Compose.cs,Index,The following statement contains a magic number: int p = c >> 8;
Magic Number,StringPrep.Unicode,Compose,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\StringPrep\Unicode\Compose.cs,Index,The following statement contains a magic number: ComposeData.Table[p] == 255
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType(buf' off))                      {                          case BT_LEAD2:                              if (end - off < 2)                                  throw new PartialCharException(off);                              check2(buf' off);                              off += 2;                              break;                          case BT_LEAD3:                              if (end - off < 3)                                  throw new PartialCharException(off);                              check3(buf' off);                              off += 3;                              break;                          case BT_LEAD4:                              if (end - off < 4)                                  throw new PartialCharException(off);                              check4(buf' off);                              off += 4;                              break;                          case BT_NONXML:                          case BT_MALFORM:                              throw new InvalidTokenException(off);                          case BT_MINUS:                              if ((off += minBPC) == end)                                  throw new PartialTokenException();                              if (charMatches(buf' off' '-'))                              {                                  if ((off += minBPC) == end)                                      throw new PartialTokenException();                                  checkCharMatches(buf' off' '>');                                  token.TokenEnd = off + minBPC;                                  return TOK.COMMENT;                              }                              break;                          default:                              off += minBPC;                              break;                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,targetIsXml,The following statement contains a magic number: end - off != minBPC*3
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          bool isXml = targetIsXml(buf' target' off);                          token.NameEnd = off;                          off += minBPC;                          while (off != end)                          {                              switch (byteType(buf' off))                              {                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_QUEST:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      if (charMatches(buf' off' '>'))                                      {                                          token.TokenEnd = off + minBPC;                                          if (isXml)                                              return TOK.XML_DECL;                                          else                                              return TOK.PI;                                      }                                      break;                                  default:                                      off += minBPC;                                      break;                              }                          }                          throw new PartialTokenException();                      case BT_QUEST:                          token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return (targetIsXml(buf' target' token.NameEnd)                              ? TOK.XML_DECL                              : TOK.PI);                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanCdataSection,The following statement contains a magic number: end - off < 6 * minBPC
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      token.TokenEnd = off + minBPC;                      return TOK.CDATA_SECT_CLOSE;                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          for (off += minBPC; off != end; off += minBPC)                          {                              switch (byteType(buf' off))                              {                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.TokenEnd = off + minBPC;                                      return TOK.END_TAG;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          throw new PartialTokenException();                      case BT_GT:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.END_TAG;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c)                  {                      case '0': case '1': case '2': case '3': case '4':                      case '5': case '6': case '7': case '8': case '9':                          num = c - '0';                          break;                      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                          num = c - ('A' - 10);                          break;                      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                          num = c - ('a' - 10);                          break;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c)                  {                      case '0': case '1': case '2': case '3': case '4':                      case '5': case '6': case '7': case '8': case '9':                          num = c - '0';                          break;                      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                          num = c - ('A' - 10);                          break;                      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                          num = c - ('a' - 10);                          break;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c)                      {                          case '0': case '1': case '2': case '3': case '4':                          case '5': case '6': case '7': case '8': case '9':                              num = (num << 4) + c - '0';                              break;                          case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':                              num = (num << 4) + c - ('A' - 10);                              break;                          case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':                              num = (num << 4) + c - ('a' - 10);                              break;                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                          default:                              throw new InvalidTokenException(off);                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanCharRef,The following statement contains a magic number: switch (c)                      {                          case '0':                          case '1':                          case '2':                          case '3':                          case '4':                          case '5':                          case '6':                          case '7':                          case '8':                          case '9':                              num = num * 10 + (c - '0');                              if (num < 0x110000)                                  break;                              /* fall through */                              goto default;                          default:                              throw new InvalidTokenException(off);                          case ';':                              token.TokenEnd = off + minBPC;                              return setRefChar(num' token);                      }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setRefChar,The following statement contains a magic number: switch (charTypeTable[num >> 8][num & 0xFF])                  {                      case BT_NONXML:                      case BT_LEAD4:                      case BT_MALFORM:                          throw new InvalidTokenException(token.TokenEnd - minBPC);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_NUM:                      return scanCharRef(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          NameEnd = off;                          for (;;)                          {                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_EQUALS:                                      goto loop;                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop: ;                          /* fall through */                          goto case BT_EQUALS;                      case BT_EQUALS:                      {                          if (NameEnd < 0)                              NameEnd = off;                          int open;                          for (;;)                          {                                off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              open = byteType(buf' off);                              if (open == BT_QUOT || open == BT_APOS)                                  break;                              switch (open)                              {                                  case BT_S:                                  case BT_LF:                                  case BT_CR:                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          off += minBPC;                          int valueStart = off;                          bool normalized = true;                          int t;                          /* in attribute value */                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                              if (t == open)                                  break;                              switch (t)                              {                                  case BT_NONXML:                                  case BT_MALFORM:                                      throw new InvalidTokenException(off);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      check2(buf' off);                                      off += 2;                                      break;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      check3(buf' off);                                      off += 3;                                      break;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      check4(buf' off);                                      off += 4;                                      break;                                  case BT_AMP:                                  {                                      normalized = false;                                      int saveNameEnd = token.NameEnd;                                      scanRef(buf' off + minBPC' end' token);                                      token.NameEnd = saveNameEnd;                                      off = token.TokenEnd;                                      break;                                  }                                  case BT_S:                                      if (normalized                                          && (off == valueStart                                          || byteToAscii(buf' off) != ' '                                          || (off + minBPC != end                                          && (byteToAscii(buf' off + minBPC) == ' '                                          || byteType(buf' off + minBPC) == open))))                                          normalized = false;                                      off += minBPC;                                      break;                                  case BT_LT:                                      throw new InvalidTokenException(off);                                  case BT_LF:                                  case BT_CR:                                      normalized = false;                                      /* fall through */                                      goto default;                                  default:                                      off += minBPC;                                      break;                              }                          }                          token.appendAttribute(nameStart' NameEnd' valueStart'                              off'                              normalized);                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          t = byteType(buf' off);                          switch (t)                          {                              case BT_S:                              case BT_CR:                              case BT_LF:                                  off += minBPC;                                  if (off == end)                                      throw new PartialTokenException();                                  t = byteType(buf' off);                                  break;                              case BT_GT:                              case BT_SOL:                                  break;                              default:                                  throw new InvalidTokenException(off);                          }                          /* off points to closing quote */                          for (;;)                          {                              switch (t)                              {                                  case BT_NMSTRT:                                      nameStart = off;                                      off += minBPC;                                      goto skipToName;                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 2;                                      goto skipToName;                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 3;                                      goto skipToName;                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      nameStart = off;                                      off += 4;                                      goto skipToName;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      break;                                  case BT_GT:                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.START_TAG_WITH_ATTS;                                  case BT_SOL:                                      off += minBPC;                                      if (off == end)                                          throw new PartialTokenException();                                      checkCharMatches(buf' off' '>');                                      token.checkAttributeUniqueness(buf);                                      token.TokenEnd = off + minBPC;                                      return TOK.EMPTY_ELEMENT_WITH_ATTS;                                  default:                                      throw new InvalidTokenException(off);                              }                              off += minBPC;                              if (off == end)                                  throw new PartialTokenException();                              t = byteType(buf' off);                          }                            skipToName:                              NameEnd = -1;                          break;                      }                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_EXCL:                      if ((off += minBPC) == end)                          throw new PartialTokenException();                  switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }                      throw new InvalidTokenException(off);                  case BT_QUEST:                      return scanPi(buf' off + minBPC' end' token);                  case BT_SOL:                      return scanEndTag(buf' off + minBPC' end' token);                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.NameEnd = off;                          off += minBPC;                          for (;;)                          {                              if (off == end)                                  throw new PartialTokenException();                              switch (byteType(buf' off))                              {                                  case BT_NMSTRT:                                      return scanAtts(off' buf' off + minBPC' end' token);                                  case BT_LEAD2:                                      if (end - off < 2)                                          throw new PartialCharException(off);                                      if (byteType2(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 2' end' token);                                  case BT_LEAD3:                                      if (end - off < 3)                                          throw new PartialCharException(off);                                      if (byteType3(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 3' end' token);                                  case BT_LEAD4:                                      if (end - off < 4)                                          throw new PartialCharException(off);                                      if (byteType4(buf' off) != BT_NMSTRT)                                          throw new InvalidTokenException(off);                                      return scanAtts(off' buf' off + 4' end' token);                                  case BT_GT:                                  case BT_SOL:                                      goto loop;                                  case BT_S:                                  case BT_CR:                                  case BT_LF:                                      off += minBPC;                                      break;                                  default:                                      throw new InvalidTokenException(off);                              }                          }                          loop:                              break;                      case BT_GT:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.START_TAG_NO_ATTS;                      case BT_SOL:                          if (token.NameEnd < 0)                              token.NameEnd = off;                          off += minBPC;                          if (off == end)                              throw new PartialTokenException();                          checkCharMatches(buf' off' '>');                          token.TokenEnd = off + minBPC;                          return TOK.EMPTY_ELEMENT_NO_ATTS;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_LT:                      return scanLt(buf' off + minBPC' end' token);                  case BT_AMP:                      return scanRef(buf' off + minBPC' end' token);                  case BT_CR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                      if (byteType(buf' off) == BT_LF)                          off += minBPC;                      token.TokenEnd = off;                      return TOK.DATA_NEWLINE;                  case BT_LF:                      token.TokenEnd = off + minBPC;                      return TOK.DATA_NEWLINE;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' ']'))                          break;                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.DATA_CHARS);                      if (!charMatches(buf' off' '>'))                      {                          off -= minBPC;                          break;                      }                      throw new InvalidTokenException(off);                  case BT_NONXML:                  case BT_MALFORM:                      throw new InvalidTokenException(off);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      check2(buf' off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      check3(buf' off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      check4(buf' off);                      off += 4;                      break;                  default:                      off += minBPC;                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              return off;                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              return off;                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              return off;                          check4(buf' off);                          off += 4;                          break;                      case BT_RSQB:                      case BT_AMP:                      case BT_LT:                      case BT_NONXML:                      case BT_MALFORM:                      case BT_CR:                      case BT_LF:                          return off;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  case BT_S:                  case BT_LF:                  case BT_CR:                  case BT_PERCNT:                      token.TokenEnd = off;                      return TOK.PERCENT;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_SEMI:                          token.NameEnd = off;                          token.TokenEnd = off + minBPC;                          return TOK.PARAM_ENTITY_REF;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_NMSTRT:                      off += minBPC;                      break;                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                      if (byteType2(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 2;                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                      if (byteType3(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 3;                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                      if (byteType4(buf' off) != BT_NMSTRT)                          throw new InvalidTokenException(off);                      off += 4;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_RPAR:                      case BT_GT:                      case BT_PERCNT:                      case BT_VERBAR:                          token.TokenEnd = off;                          return TOK.POUND_NAME;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t)                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialTokenException();                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialTokenException();                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialTokenException();                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_QUOT:                      case BT_APOS:                          off += minBPC;                          if (t != open)                              break;                          if (off == end)                              throw new ExtensibleTokenException(TOK.LITERAL);                      switch (byteType(buf' off))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_GT:                          case BT_PERCNT:                          case BT_LSQB:                              token.TokenEnd = off;                              return TOK.LITERAL;                          default:                              throw new InvalidTokenException(off);                      }                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off)              {                  case 0:                      break;                  case 1:                      if (buf[off] > 127)                          return null;                      break;                  default:                      int b0 = buf[off] & 0xFF;                      int b1 = buf[off + 1] & 0xFF;                  switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }                      break;              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))              {                  case BT_QUOT:                      return scanLit(BT_QUOT' buf' off + minBPC' end' token);                  case BT_APOS:                      return scanLit(BT_APOS' buf' off + minBPC' end' token);                  case BT_LT:                  {                      off += minBPC;                      if (off == end)                          throw new PartialTokenException();                      switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }                      throw new InvalidTokenException(off);                  }                  case BT_CR:                      if (off + minBPC == end)                          throw new ExtensibleTokenException(TOK.PROLOG_S);                      /* fall through */                      goto case BT_S;                  case BT_S:                  case BT_LF:                      for (;;)                      {                          off += minBPC;                          if (off == end)                              break;                          switch (byteType(buf' off))                          {                              case BT_S:                              case BT_LF:                                  break;                              case BT_CR:                                  /* don't split CR/LF pair */                                  if (off + minBPC != end)                                      break;                                  /* fall through */                                  goto default;                              default:                                  token.TokenEnd = off;                                  return TOK.PROLOG_S;                          }                      }                      token.TokenEnd = off;                      return TOK.PROLOG_S;                  case BT_PERCNT:                      return scanPercent(buf' off + minBPC' end' token);                  case BT_COMMA:                      token.TokenEnd = off + minBPC;                      return TOK.COMMA;                  case BT_LSQB:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_BRACKET;                  case BT_RSQB:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_BRACKET);                      if (charMatches(buf' off' ']'))                      {                          if (off + minBPC == end)                              throw new PartialTokenException();                          if (charMatches(buf' off + minBPC' '>'))                          {                              token.TokenEnd = off + 2*minBPC;                              return TOK.COND_SECT_CLOSE;                          }                      }                      token.TokenEnd = off;                      return TOK.CLOSE_BRACKET;                  case BT_LPAR:                      token.TokenEnd = off + minBPC;                      return TOK.OPEN_PAREN;                  case BT_RPAR:                      off += minBPC;                      if (off == end)                          throw new ExtensibleTokenException(TOK.CLOSE_PAREN);                  switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }                      throw new InvalidTokenException(off);                  case BT_VERBAR:                      token.TokenEnd = off + minBPC;                      return TOK.OR;                  case BT_GT:                      token.TokenEnd = off + minBPC;                      return TOK.DECL_CLOSE;                  case BT_NUM:                      return scanPoundName(buf' off + minBPC' end' token);                  case BT_LEAD2:                      if (end - off < 2)                          throw new PartialCharException(off);                  switch (byteType2(buf' off))                  {                      case BT_NMSTRT:                          off += 2;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 2;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD3:                      if (end - off < 3)                          throw new PartialCharException(off);                  switch (byteType3(buf' off))                  {                      case BT_NMSTRT:                          off += 3;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 3;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_LEAD4:                      if (end - off < 4)                          throw new PartialCharException(off);                  switch (byteType4(buf' off))                  {                      case BT_NMSTRT:                          off += 4;                          tok = TOK.NAME;                          break;                      case BT_NAME:                          off += 4;                          tok = TOK.NMTOKEN;                          break;                      default:                          throw new InvalidTokenException(off);                  }                      break;                  case BT_NMSTRT:                      tok = TOK.NAME;                      off += minBPC;                      break;                  case BT_NAME:                  case BT_MINUS:                      tok = TOK.NMTOKEN;                      off += minBPC;                      break;                  default:                      throw new InvalidTokenException(off);              }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_NMSTRT:                      case BT_NAME:                      case BT_MINUS:                          off += minBPC;                          break;                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          if (!isNameChar2(buf' off))                              throw new InvalidTokenException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          if (!isNameChar3(buf' off))                              throw new InvalidTokenException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          if (!isNameChar4(buf' off))                              throw new InvalidTokenException(off);                          off += 4;                          break;                      case BT_GT:                      case BT_RPAR:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_LSQB:                      case BT_PERCNT:                      case BT_S:                      case BT_CR:                      case BT_LF:                          token.TokenEnd = off;                          return tok;                      case BT_PLUS:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_PLUS;                      case BT_AST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_ASTERISK;                      case BT_QUEST:                          if (tok != TOK.NAME)                              throw new InvalidTokenException(off);                          token.TokenEnd = off + minBPC;                          return TOK.NAME_QUESTION;                      default:                          throw new InvalidTokenException(off);                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LT:                          /* this is for inside entity references */                          throw new InvalidTokenException(off);                      case BT_S:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.ATTRIBUTE_VALUE_S;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          off += 4;                          break;                      case BT_AMP:                          if (off == start)                              return scanRef(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_PERCNT:                          if (off == start)                              return scanPercent(buf' off + minBPC' end' token);                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_LF:                          if (off == start)                          {                              token.TokenEnd = off + minBPC;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      case BT_CR:                          if (off == start)                          {                              off += minBPC;                              if (off == end)                                  throw new ExtensibleTokenException(TOK.DATA_NEWLINE);                              if (byteType(buf' off) == BT_LF)                                  off += minBPC;                              token.TokenEnd = off;                              return TOK.DATA_NEWLINE;                          }                          token.TokenEnd = off;                          return TOK.DATA_CHARS;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType(buf' off))                  {                      case BT_LEAD2:                          if (end - off < 2)                              throw new PartialCharException(off);                          check2(buf' off);                          off += 2;                          break;                      case BT_LEAD3:                          if (end - off < 3)                              throw new PartialCharException(off);                          check3(buf' off);                          off += 3;                          break;                      case BT_LEAD4:                          if (end - off < 4)                              throw new PartialCharException(off);                          check4(buf' off);                          off += 4;                          break;                      case BT_NONXML:                      case BT_MALFORM:                          throw new InvalidTokenException(off);                      case BT_LT:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '!'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' '['))                              break;                          level++;                          off += minBPC;                          break;                      case BT_RSQB:                          off += minBPC;                          if (off == end)                              goto loop;                          if (!charMatches(buf' off' ']'))                              break;                          off += minBPC;                          if (off == end)                              goto loop;                          if (charMatches(buf' off' '>'))                          {                              if (level == 0)                                  return off + minBPC;                              level--;                          }                          else if (charMatches(buf' off' ']'))                              break;                          off += minBPC;                          break;                      default:                          off += minBPC;                          break;                  }
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: int hi = c >> 8;
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: charTypeTable[hi] = new int[256];
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: i < 256
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: shared = new int[256];
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: i < 256
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setCharType,The following statement contains a magic number: charTypeTable[min >> 8] = shared;
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: charTypeTable = new int[256][];
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: int[] other = new int[256];
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: i < 256
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: i < 256
Magic Number,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,Encoding,The following statement contains a magic number: System.Array.Copy(asciiTypeTable' 0' charTypeTable[0]' 0' 128);
Magic Number,XpNet,UTF8Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy(asciiTypeTable'  0' utf8TypeTable'   0' 128);
Magic Number,XpNet,UTF8Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy(utf8HiTypeTable' 0' utf8TypeTable' 128' 128);
Magic Number,XpNet,UTF8Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy(utf8HiTypeTable' 0' utf8TypeTable' 128' 128);
Magic Number,XpNet,UTF8Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,byteType2,The following statement contains a magic number: int[] page = charTypeTable[(buf[off] >> 2) & 0x7];
Magic Number,XpNet,UTF8Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,byteType2,The following statement contains a magic number: return page[((buf[off] & 3) << 6) | (buf[off + 1] & 0x3F)];
Magic Number,XpNet,UTF8Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,byteType2,The following statement contains a magic number: return page[((buf[off] & 3) << 6) | (buf[off + 1] & 0x3F)];
Missing Default,Bedrock.Net,ShttpProxy,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Bedrock\Net\ShttpProxy.cs,OnRead,The following switch statement is missing a default case: switch (state)                      {                      case 0:                          if (b == '\r')                              state++;                          break;                      case 1:                          if (b == '\n')                          {                              byte[] hs = m_headerstream.ToArray();                              string s = System.Text.Encoding.UTF8.GetString(hs);                              Debug.Write("PRECV: " + s);                              m_headers.Add(s);                              m_headerstream.SetLength(0);                              state++;                              line++;                          }                          else                              state = 0;                          break;                      case 2:                          if (b == '\r')                              state++;                          else                              state = 0;                          break;                      case 3:                          if (b == '\n')                          {                              Debug.WriteLine("End of proxy headers");                              string line0 = (string)m_headers[0];                              if (line0.IndexOf("200") == -1)                              {                                  Debug.WriteLine("200 response not detected.  Closing.");                                  m_state = States.Error;                                  this.Close();                              }                              else                              {                                  Debug.WriteLine("Proxy connected");                                  m_listener.OnConnect(sock); // tell the real listener that we're connected.                                  m_state = States.Running;                              }                              // they'll call RequestRead()' so we can return false here.                              return false;                          }                          else                              state = 0;                          break;                      }
Missing Default,Jabber.Client,JingleIceManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleIceManager.cs,CheckConnectivity,The following switch statement is missing a default case: switch (remoteCandidate.Type)                      {                          case IceCandidateType.host:                          case IceCandidateType.prflx:                          case IceCandidateType.srflx:                              foreach (JingleIceCandidate localCandidate in this.localCandidates[sid])                              {                                  if (localCandidate.Type == remoteCandidate.Type)                                  {                                      this.holePuncher.AddEP(remoteCandidate.Priority' remoteCandidate.EndPoint);                                      break;                                  }                              }                              break;                            case IceCandidateType.relay:                              if (this.TurnSupported &&                                  jingleSession.Remote.Action == ActionType.session_accept)                              {                                  this.turnSessions[sid].TurnManager.CreatePermission(new XorMappedAddress(remoteCandidate.RelatedEndPoint)'                                                                                      this.turnSessions[sid].TurnAllocation);                              }                              break;                      }
Missing Default,Jabber.Client,JingleManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleManager.cs,GotIQ,The following switch statement is missing a default case: switch (jingle.Action)                      {                          case ActionType.session_initiate:                              this.Stream.Write(iq.GetAcknowledge(this.Stream.Document));                                if (this.AllowSessionInitiateFrom(iq.From))                              {                                  if (!this.Sessions.ContainsKey(jingle.Sid))                                  {                                      JingleSession jingleSession = new JingleSession();                                      jingleSession.SID = jingle.Sid;                                      jingleSession.Remote = jingle;                                        this.Sessions.Add(jingle.Sid' jingleSession);                                  }                                    if (this.OnReceivedSessionInitiate != null)                                      this.OnReceivedSessionInitiate(this' iq);                                    if (!iq.Handled)                                  {                                      this.SessionTerminate(iq.From' jingle.Sid' ReasonType.decline);                                      iq.Handled = true;                                  }                              }                              else                              {                                  this.SessionTerminate(iq.From' jingle.Sid' ReasonType.security_error);                                  iq.Handled = true;                              }                              break;                            case ActionType.session_accept:                              this.Stream.Write(iq.GetAcknowledge(this.Stream.Document));                                if (!this.Sessions.ContainsKey(jingle.Sid))                              {                                  JingleSession jingleSession = new JingleSession();                                  jingleSession.SID = jingle.Sid;                                  jingleSession.Remote = jingle;                                    this.Sessions.Add(jingle.Sid' jingleSession);                                    if (this.OnReceivedSessionAccept != null)                                      this.OnReceivedSessionAccept(this' iq);                                    if (!iq.Handled)                                  {                                      this.SessionTerminate(iq.From' jingle.Sid' ReasonType.cancel);                                      iq.Handled = true;                                  }                              }                              else                              {                                  this.Stream.Write(new UnknownSession(this.Stream.Document));                                  iq.Handled = true;                              }                              break;                            case ActionType.session_info:                              if (this.Sessions.ContainsKey(jingle.Sid))                                  this.Stream.Write(iq.GetAcknowledge(this.Stream.Document));                              else                                  this.Stream.Write(new UnknownSession(this.Stream.Document));                                if (this.OnReceivedSessionInfo != null)                                  this.OnReceivedSessionInfo(this' iq);                                break;                            case ActionType.transport_info:                              if (this.Sessions.ContainsKey(jingle.Sid))                                  this.Stream.Write(iq.GetAcknowledge(this.Stream.Document));                              else                                  this.Stream.Write(new UnknownSession(this.Stream.Document));                                if (this.OnReceivedTransportInfo != null)                                  this.OnReceivedTransportInfo(this' iq);                                break;                      }
Missing Default,Jabber.Client,JingleManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\JingleManager.cs,SessionTerminate,The following switch statement is missing a default case: switch (reasonType)                  {                      case ReasonType.alternative_session:                          reason.Reason = new AlternativeSession(jingleIq.OwnerDocument);                          break;                        case ReasonType.busy:                          reason.Reason = new Busy(jingleIq.OwnerDocument);                          break;                        case ReasonType.cancel:                          reason.Reason = new Cancel(jingleIq.OwnerDocument);                          break;                        case ReasonType.connectivity_error:                          reason.Reason = new ConnectivityError(jingleIq.OwnerDocument);                          break;                        case ReasonType.decline:                          reason.Reason = new JingleDecline(jingleIq.OwnerDocument);                          break;                        case ReasonType.expired:                          reason.Reason = new Expired(jingleIq.OwnerDocument);                          break;                        case ReasonType.failed_application:                          reason.Reason = new FailedApplication(jingleIq.OwnerDocument);                          break;                        case ReasonType.failed_transport:                          reason.Reason = new FailedTransport(jingleIq.OwnerDocument);                          break;                        case ReasonType.general_error:                          reason.Reason = new GeneralError(jingleIq.OwnerDocument);                          break;                        case ReasonType.gone:                          reason.Reason = new Gone(jingleIq.OwnerDocument);                          break;                        case ReasonType.incompatible_parameters:                          reason.Reason = new IncompatibleParameters(jingleIq.OwnerDocument);                          break;                        case ReasonType.media_error:                          reason.Reason = new MediaError(jingleIq.OwnerDocument);                          break;                        case ReasonType.security_error:                          reason.Reason = new SecurityError(jingleIq.OwnerDocument);                          break;                        case ReasonType.success:                          reason.Reason = new Success(jingleIq.OwnerDocument);                          break;                        case ReasonType.timeout:                          reason.Reason = new Timeout(jingleIq.OwnerDocument);                          break;                        case ReasonType.unsupported_applications:                          reason.Reason = new UnsupportedApplications(jingleIq.OwnerDocument);                          break;                        case ReasonType.unsupported_transports:                          reason.Reason = new UnsupportedTransports(jingleIq.OwnerDocument);                          break;                  }
Missing Default,Jabber.Client,RpcManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RpcManager.cs,GotRpcCall,The following switch statement is missing a default case: switch (iq.Type)              {                  case IQType.set:                      if (this.CanReceiveRpcXml)                      {                          RpcIQ methodResponse = new RpcIQ(new XmlDocument());                          methodResponse.From = this.Stream.JID;                          methodResponse.To = iq.From;                          methodResponse.Type = IQType.result;                          methodResponse.ID = iq.ID; // Make IQ ID behaving like a transaction ID                          methodResponse.Instruction.SetXmlRpcPayload(this.InvokeXmlRpc(rpcXmlString));                            this.BeginIQ(methodResponse' new IqCB(this.GotRpcCall)' null);                            iq.Handled = true;                      }                      break;                    case IQType.result:                      if (this.CanSendRpcXml && this.xmlRpcContexts.ContainsKey(iq.ID))                      {                          byte[] outputByteArray = Encoding.UTF8.GetBytes(rpcXmlString);                          MemoryStream outputStream = new MemoryStream(outputByteArray);                            HttpListenerResponse response = this.xmlRpcContexts[iq.ID].Response;                            response.ContentLength64 = outputStream.Length;                            Util.CopyStream(outputStream' response.OutputStream);                            response.OutputStream.Flush();                            this.xmlRpcContexts.Remove(iq.ID);                            iq.Handled = true;                      }                      break;              }
Missing Default,Jabber.Client,RpcManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RpcManager.cs,MethodCallSerializerThreadStart,The following switch statement is missing a default case: switch (match.Groups["key"].Value)                          {                              case "to":                                  to = Uri.UnescapeDataString(match.Groups["val"].Value);                                  break;                          }
Missing Default,Jabber.Client,RosterManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RosterManager.Designer.cs,cli_OnPresence,The following switch statement is missing a default case: switch (typ)              {                  case PresenceType.available:                  case PresenceType.unavailable:                  case PresenceType.error:                  case PresenceType.probe:                      return;                  case PresenceType.subscribe:                      switch (m_autoAllow)                      {                          case AutoSubscriptionHanding.AllowAll:                              ReplyAllow(pres);                              return;                          case AutoSubscriptionHanding.DenyAll:                              ReplyDeny(pres);                              return;                          case AutoSubscriptionHanding.NONE:                              if (OnSubscription != null)                                  OnSubscription(this' this[pres.From]' pres);                              return;                          case AutoSubscriptionHanding.AllowIfSubscribed:                              Item ri = this[pres.From];                              if (ri != null)                              {                                  switch (ri.Subscription)                                  {                                      case Subscription.to:                                          ReplyAllow(pres);                                          return;                                      case Subscription.from:                                      case Subscription.both:                                          // Almost an assert                                          throw new InvalidOperationException("Server sent a presence subscribe for an already-subscribed contact");                                      case Subscription.none:                                          if (ri.Ask == Ask.subscribe)                                          {                                              ReplyAllow(pres);                                              return;                                          }                                          break;                                  }                              }                              if (OnSubscription != null)                                  OnSubscription(this' ri' pres);                              break;                      }                      break;                  case PresenceType.subscribed:                      // This is the new ack case.                      Presence sub_ack = new Presence(m_stream.Document);                      sub_ack.To = pres.From;                      sub_ack.Type = PresenceType.subscribe;                      Write(sub_ack);                      break;                  case PresenceType.unsubscribe:                      // ack.  we'll likely get an unsubscribed soon' anyway.                      Presence un_ack = new Presence(m_stream.Document);                      un_ack.To = pres.From;                      un_ack.Type = PresenceType.unsubscribed;                      Write(un_ack);                      break;                  case PresenceType.unsubscribed:                      bool remove = true;                      if (OnUnsubscription != null)                          OnUnsubscription(this' pres' ref remove);                        if (remove)                          Remove(pres.From);                      break;              }
Missing Default,Jabber.Client,RosterManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RosterManager.Designer.cs,cli_OnPresence,The following switch statement is missing a default case: switch (m_autoAllow)                      {                          case AutoSubscriptionHanding.AllowAll:                              ReplyAllow(pres);                              return;                          case AutoSubscriptionHanding.DenyAll:                              ReplyDeny(pres);                              return;                          case AutoSubscriptionHanding.NONE:                              if (OnSubscription != null)                                  OnSubscription(this' this[pres.From]' pres);                              return;                          case AutoSubscriptionHanding.AllowIfSubscribed:                              Item ri = this[pres.From];                              if (ri != null)                              {                                  switch (ri.Subscription)                                  {                                      case Subscription.to:                                          ReplyAllow(pres);                                          return;                                      case Subscription.from:                                      case Subscription.both:                                          // Almost an assert                                          throw new InvalidOperationException("Server sent a presence subscribe for an already-subscribed contact");                                      case Subscription.none:                                          if (ri.Ask == Ask.subscribe)                                          {                                              ReplyAllow(pres);                                              return;                                          }                                          break;                                  }                              }                              if (OnSubscription != null)                                  OnSubscription(this' ri' pres);                              break;                      }
Missing Default,Jabber.Client,RosterManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Client\RosterManager.Designer.cs,cli_OnPresence,The following switch statement is missing a default case: switch (ri.Subscription)                                  {                                      case Subscription.to:                                          ReplyAllow(pres);                                          return;                                      case Subscription.from:                                      case Subscription.both:                                          // Almost an assert                                          throw new InvalidOperationException("Server sent a presence subscribe for an already-subscribed contact");                                      case Subscription.none:                                          if (ri.Ask == Ask.subscribe)                                          {                                              ReplyAllow(pres);                                              return;                                          }                                          break;                                  }
Missing Default,Jabber.Connection,CapsManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\CapsManager.Designer.cs,GetHasher,The following switch statement is missing a default case: switch (name)              {              case null:                  return null;              case "sha-1":                  return SHA1.Create();              case "sha-256":                  return SHA256.Create();              case "sha-512":                  return SHA512.Create();              case "sha-384":                  return SHA384.Create();              case "md5":                  return MD5.Create();              }
Missing Default,Jabber.Connection,XmppStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,OnElement,The following switch statement is missing a default case: switch (tag.Name)                  {                      case "proceed":                          if (!StartTLS())                              return;                            SendNewStreamHeader();                          break;                      case "failure":                          FireOnError(new AuthenticationFailedException());                          return;                  }
Missing Default,Jabber.Connection,XmppStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\XmppStream.Designer.cs,OnElement,The following switch statement is missing a default case: switch (tag.Name)                  {                      case "compressed":                          if (!StartCompression())                              return;                            SendNewStreamHeader();                          break;                      case "failure":                          CompressionFailure fail = tag as CompressionFailure;                          FireOnError(new CompressionFailedException(fail.Error));                          return;                  }
Missing Default,Jabber.Connection,Room,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\ConferenceManager.cs,m_stream_OnProtocol,The following switch statement is missing a default case: switch (rp.LocalName)              {                  case "presence":                      Presence p = (Presence)rp;                      if (p.Error != null)                      {                          m_state = STATE.error;                          if (OnPresenceError != null)                              OnPresenceError(this' p);                          return;                      }                        Presence oldPresence = (m_participants[from] != null) ? ((RoomParticipant)m_participants[from]).Presence : null;                        ParticipantCollection.Modification mod = ParticipantCollection.Modification.NONE;                      RoomParticipant party = m_participants.Modify(p' out mod);                        // if this is ours                      if (p.From == m_jid)                      {                          switch (m_state)                          {                              case STATE.join:                                  OnJoinPresence(p);                                  break;                              case STATE.leaving:                                  OnLeavePresence(p);                                  break;                              case STATE.running:                                  if (p.Type == PresenceType.unavailable)                                      OnLeavePresence(p);                                  else                                      OnPresenceChange(this' party' oldPresence);                                  break;                          }                      }                      else                      {                          switch (mod)                          {                              case ParticipantCollection.Modification.NONE:                                  if (OnParticipantPresenceChange != null)                                      OnParticipantPresenceChange(this' party' oldPresence);                                  break;                              case ParticipantCollection.Modification.JOIN:                                  if (OnParticipantJoin != null)                                      OnParticipantJoin(this' party);                                  break;                              case ParticipantCollection.Modification.LEAVE:                                  if (OnParticipantLeave != null)                                      OnParticipantLeave(this' party);                                  break;                          }                      }                      break;                  case "message":                      Message m = (Message)rp;                      if (m.Type == MessageType.groupchat)                      {                          if (m.Subject != null)                          {                              if (OnSubjectChange != null)                                  OnSubjectChange(this' m);                              m_subject = m;                          }                          else if (m.From == m_jid)                          {                              if (OnSelfMessage != null)                                  OnSelfMessage(this' m);                          }                          else                          {                              if (OnRoomMessage != null)                                  OnRoomMessage(this' m);                          }                      }                      else                      {                          if (m.From.Resource == null)                          {                              // room notification of some kind                              if (OnAdminMessage != null)                                  OnAdminMessage(this' m);                          }                          else                          {                              if (OnPrivateMessage != null)                                  OnPrivateMessage(this' m);                          }                      }                      break;                  case "iq":                      if (OnIQ != null)                          OnIQ(this' (IQ)rp);                      break;              }
Missing Default,Jabber.Connection,Room,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\ConferenceManager.cs,m_stream_OnProtocol,The following switch statement is missing a default case: switch (m_state)                          {                              case STATE.join:                                  OnJoinPresence(p);                                  break;                              case STATE.leaving:                                  OnLeavePresence(p);                                  break;                              case STATE.running:                                  if (p.Type == PresenceType.unavailable)                                      OnLeavePresence(p);                                  else                                      OnPresenceChange(this' party' oldPresence);                                  break;                          }
Missing Default,Jabber.Connection,Room,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\ConferenceManager.cs,m_stream_OnProtocol,The following switch statement is missing a default case: switch (mod)                          {                              case ParticipantCollection.Modification.NONE:                                  if (OnParticipantPresenceChange != null)                                      OnParticipantPresenceChange(this' party' oldPresence);                                  break;                              case ParticipantCollection.Modification.JOIN:                                  if (OnParticipantJoin != null)                                      OnParticipantJoin(this' party);                                  break;                              case ParticipantCollection.Modification.LEAVE:                                  if (OnParticipantLeave != null)                                      OnParticipantLeave(this' party);                                  break;                          }
Missing Default,Jabber.Connection,PubSubNode,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\PubSubManager.cs,NeedsAsking,The following switch statement is missing a default case: switch (state)              {              case STATE.Start:              case STATE.Pending:                  return true;              case STATE.Asking:              case STATE.Running:                  return false;              case STATE.Error:                  Debug.WriteLine("Retrying create after error.  Hope you've changed perms or something in the mean time.");                  return true;              }
Missing Default,Jabber.Connection,PubSubNode,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Connection\PubSubManager.cs,GotSubscribed,The following switch statement is missing a default case: switch (subType)              {              case PubSubSubscriptionType.NONE_SPECIFIED:              case PubSubSubscriptionType.subscribed:                  break;              case PubSubSubscriptionType.pending:                  FireError(Op.SUBSCRIBE' "Subscription pending authorization"' iq);                  return;              case PubSubSubscriptionType.unconfigured:                  FireError(Op.SUBSCRIBE' "Subscription configuration required.  Not implemented yet."' iq);                  return;              }
Missing Default,Jabber.Stun,StunAttribute,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunAttribute.cs,StunAttribute,The following switch statement is missing a default case: switch (type)              {                  case StunAttributeType.Software:                  case StunAttributeType.Realm:                  case StunAttributeType.Nonce:                  case StunAttributeType.ErrorCode:                      if (value.Length > 763)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 763 bytes for the given type as described in RFC 5389");                      break;                    case StunAttributeType.Username:                      if (value.Length > 513)                          throw new ArgumentOutOfRangeException("value"' "Cannot be greater than 513 bytes for the given type as described in RFC 5389");                      break;              }
Missing Default,Jabber.Stun,StunAttribute,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunAttribute.cs,StunAttribute,The following switch statement is missing a default case: switch (type)              {                  case StunAttributeType.Realm:                  case StunAttributeType.Username:                      String saslPrepValue = new SASLprep().Prepare(StunMessage.Encoder.GetString(value));                        value = StunMessage.Encoder.GetBytes(saslPrepValue);                      break;              }
Missing Default,Jabber.Stun,StunClient,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\StunClient.cs,ReceiveCallback,The following switch statement is missing a default case: switch (receivedMsg.MethodClass)                      {                          case StunMethodClass.SuccessResponse:                              if (!this.IsPendingTransaction(receivedMsg.TransactionID' out transactionObject))                                  return;                                if (this.OnReceivedSuccessResponse != null)                                  this.OnReceivedSuccessResponse(this' receivedMsg' transactionObject.Key' transactionObject.Value);                              break;                            case StunMethodClass.Indication:                              if (this.OnReceivedIndication != null)                                  this.OnReceivedIndication(this' receivedMsg);                              break;                            case StunMethodClass.Error:                              if (!this.IsPendingTransaction(receivedMsg.TransactionID' out transactionObject))                                  return;                                if (this.OnReceivedError != null)                                  this.OnReceivedError(this' receivedMsg' transactionObject.Key' transactionObject.Value);                              break;                      }
Missing Default,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,StunClient_OnReceivedSuccessResponse,The following switch statement is missing a default case: switch (receivedMsg.MethodType)              {                  case StunMethodType.Allocate:                      TurnAllocation allocation = new TurnAllocation()                      {                          Username = sentMsg.Stun.Username.ValueString'                          Password = transactionObject as String'                          Realm = sentMsg.Stun.Realm.ValueString'                          Nonce = sentMsg.Stun.Nonce.ValueString'                          RelayedMappedAddress = receivedMsg.Turn.XorRelayedAddress'                          MappedAddress = receivedMsg.Stun.XorMappedAddress'                          StartTime = DateTime.Now'                          LifeTime = StunUtilities.ReverseBytes(BitConverter.ToUInt32(receivedMsg.Turn.LifeTime.Value' 0))                      };                        if (this.Allocations.ContainsKey(receivedMsg.Turn.XorRelayedAddress))                          this.Allocations[receivedMsg.Turn.XorRelayedAddress] = allocation;                      else                      {                          this.Allocations.Add(receivedMsg.Turn.XorRelayedAddress' allocation);                            if (this.OnAllocateSucceed != null)                              this.OnAllocateSucceed(this' allocation' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.CreatePermission:                      TurnPermission permission = new TurnPermission()                      {                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 300                      };                      TurnAllocation permAllocation = transactionObject as TurnAllocation;                        if (permAllocation.Permissions.ContainsKey(sentMsg.Turn.XorPeerAddress))                          permAllocation.Permissions[sentMsg.Turn.XorPeerAddress] = permission;                      else                      {                          permAllocation.Permissions.Add(sentMsg.Turn.XorPeerAddress' permission);                            if (this.OnCreatePermissionSucceed != null)                              this.OnCreatePermissionSucceed(this' permAllocation' permission' sentMsg' receivedMsg);                      }                        break;                    case StunMethodType.ChannelBind:                      TurnChannel channel = new TurnChannel()                      {                          Channel = sentMsg.Turn.ChannelNumber'                          PeerAddress = sentMsg.Turn.XorPeerAddress'                          StartTime = DateTime.Now'                          LifeTime = 600                      };                      TurnAllocation channelAllocation = transactionObject as TurnAllocation;                        if (channelAllocation.Channels.ContainsKey(sentMsg.Turn.ChannelNumber))                          channelAllocation.Channels[sentMsg.Turn.ChannelNumber] = channel;                      else                      {                          channelAllocation.Channels.Add(sentMsg.Turn.ChannelNumber' channel);                            if (this.OnChannelBindSucceed != null)                              this.OnChannelBindSucceed(this' transactionObject as TurnAllocation' channel' sentMsg' receivedMsg);                      }                      break;                    case StunMethodType.ConnectionBind:                      if (this.OnConnectionBindSucceed != null)                          this.OnConnectionBindSucceed(this' transactionObject as Socket' receivedMsg);                      break;              }
Missing Default,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,StunClient_OnReceivedIndication,The following switch statement is missing a default case: switch (receivedMsg.MethodType)              {                  case StunMethodType.ConnectionAttempt:                      if (this.OnConnectionAttemptReceived != null)                          this.OnConnectionAttemptReceived(this' receivedMsg);                      break;                    case StunMethodType.Data:                      if (this.OnDataReceived != null)                          this.OnDataReceived(this' receivedMsg);                      break;              }
Missing Default,Jabber.Stun,TurnManager,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Stun\TurnManager.cs,StunClient_OnReceivedError,The following switch statement is missing a default case: switch (receivedMsg.MethodType)              {                  case StunMethodType.Allocate:                      if (receivedMsg.Stun.ErrorCode.ErrorType == ErrorCodeType.Unauthorized)                      {                          String[] credentials = transactionObject as String[];                            if (credentials != null)                              this.AllocateRetry(receivedMsg' credentials[0]' credentials[1]);                          else                              if (this.OnAllocateFailed != null)                                  this.OnAllocateFailed(this' receivedMsg' sentMsg' transactionObject);                      }                      break;              }
Missing Default,Jabber.Protocol,AsynchElementStream,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\Jabber\Protocol\AsynchElementStream.cs,Push,The following switch statement is missing a default case: switch (tok)                      {                      case TOK.EMPTY_ELEMENT_NO_ATTS:                      case TOK.EMPTY_ELEMENT_WITH_ATTS:                          StartTag(b' off' ct' tok);                          EndTag(b' off' ct' tok);                          break;                      case TOK.START_TAG_NO_ATTS:                      case TOK.START_TAG_WITH_ATTS:                          StartTag(b' off' ct' tok);                          break;                      case TOK.END_TAG:                          EndTag(b' off' ct' tok);                          break;                      case TOK.DATA_CHARS:                      case TOK.DATA_NEWLINE:                          AddText(utf.GetString(b' off' ct.TokenEnd - off));                          break;                      case TOK.CHAR_REF:                      case TOK.MAGIC_ENTITY_REF:                          AddText(new string(new char[] { ct.RefChar1 }));                          break;                      case TOK.CHAR_PAIR_REF:                          AddText(new string(new char[] {ct.RefChar1'                                                                ct.RefChar2}));                          break;                      case TOK.COMMENT:                          if (m_elem != null)                          {                              // <!-- 4                              //  --> 3                              int start = off + 4*m_enc.MinBytesPerChar;                              int end = ct.TokenEnd - off -                                      7*m_enc.MinBytesPerChar;                              string text = utf.GetString(b' start' end);                              m_elem.AppendChild(m_doc.CreateComment(text));                          }                          break;                      case TOK.CDATA_SECT_OPEN:                          m_cdata = true;                          break;                      case TOK.CDATA_SECT_CLOSE:                          m_cdata = false;                          break;                      case TOK.XML_DECL:                          // thou shalt use UTF8' and XML version 1.                          // i shall ignore evidence to the contrary...                            // TODO: Throw an exception if these assuptions are                          // wrong                          break;                      case TOK.ENTITY_REF:                      case TOK.PI:                          throw new System.NotImplementedException("Token type not implemented: " + tok);                      }
Missing Default,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getEncoding,The following switch statement is missing a default case: switch (enc)              {                  case UTF8_ENCODING:                      if (utf8Encoding == null)                          utf8Encoding = new UTF8Encoding();                      return utf8Encoding;                      /*                  case UTF16_LITTLE_ENDIAN_ENCODING:                      if (utf16LittleEndianEncoding == null)                          utf16LittleEndianEncoding = new UTF16LittleEndianEncoding();                      return utf16LittleEndianEncoding;                  case UTF16_BIG_ENDIAN_ENCODING:                      if (utf16BigEndianEncoding == null)                          utf16BigEndianEncoding = new UTF16BigEndianEncoding();                      return utf16BigEndianEncoding;                  case INTERNAL_ENCODING:                      if (internalEncoding == null)                          internalEncoding = new InternalEncoding();                      return internalEncoding;                  case ISO8859_1_ENCODING:                      if (iso8859_1Encoding == null)                          iso8859_1Encoding = new ISO8859_1Encoding();                      return iso8859_1Encoding;                  case ASCII_ENCODING:                      if (asciiEncoding == null)                          asciiEncoding = new ASCIIEncoding();                      return asciiEncoding;                      */              }
Missing Default,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanDecl,The following switch statement is missing a default case: switch (byteType(buf' off + minBPC))                      {                          case BT_S:                          case BT_CR:                          case BT_LF:                          case BT_PERCNT:                              throw new InvalidTokenException(off);                      }
Missing Default,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,setRefChar,The following switch statement is missing a default case: switch (charTypeTable[num >> 8][num & 0xFF])                  {                      case BT_NONXML:                      case BT_LEAD4:                      case BT_MALFORM:                          throw new InvalidTokenException(token.TokenEnd - minBPC);                  }
Missing Default,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following switch statement is missing a default case: switch (byteToAscii(buf' off))              {                  case 'a':                      if (end - off < minBPC*4)                          break;                  switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }                      break;                  case 'l':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '<';                          return true;                      }                      break;                  case 'g':                      if (end - off >= minBPC*3                          && charMatches(buf' off + minBPC' 't')                          && charMatches(buf' off + minBPC*2' ';'))                      {                          token.TokenEnd = off + minBPC*3;                          token.RefChar1 = '>';                          return true;                      }                      break;                  case 'q':                      if (end - off >= minBPC*5                          && charMatches(buf' off + minBPC' 'u')                          && charMatches(buf' off + minBPC*2' 'o')                          && charMatches(buf' off + minBPC*3' 't')                          && charMatches(buf' off + minBPC*4' ';'))                      {                          token.TokenEnd = off + minBPC*5;                          token.RefChar1 = '"';                          return true;                      }                      break;              }
Missing Default,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,isMagicEntityRef,The following switch statement is missing a default case: switch (byteToAscii(buf' off + minBPC))                  {                      case 'm':                          if (charMatches(buf' off + minBPC*2' 'p')                              && charMatches(buf' off + minBPC*3' ';'))                          {                              token.TokenEnd = off + minBPC*4;                              token.RefChar1 = '&';                              return true;                          }                          break;                      case 'p':                          if (end - off >= minBPC*5                              && charMatches(buf' off + minBPC*2' 'o')                              && charMatches(buf' off + minBPC*3' 's')                              && charMatches(buf' off + minBPC*4' ';'))                          {                              token.TokenEnd = off + minBPC*5;                              token.RefChar1 = '\'';                              return true;                          }                          break;                  }
Missing Default,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,scanLt,The following switch statement is missing a default case: switch (byteType(buf' off))                  {                      case BT_MINUS:                          return scanComment(buf' off + minBPC' end' token);                      case BT_LSQB:                          return scanCdataSection(buf' off + minBPC' end' token);                  }
Missing Default,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getInitialEncoding,The following switch statement is missing a default case: switch ((b0 << 8) | b1)                  {                      case 0xFEFF:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<';                      case '<': /* not legal; but not a fatal error */                          return getEncoding(UTF16_BIG_ENDIAN_ENCODING);                      case 0xFFFE:                          token.TokenEnd = off + 2;                          /* fall through */                          goto case '<' << 8;                      case '<' << 8:  /* not legal; but not a fatal error */                          return getEncoding(UTF16_LITTLE_ENDIAN_ENCODING);                  }
Missing Default,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,getEncoding,The following switch statement is missing a default case: switch (name.ToUpper())              {                  case "UTF-8":                      return getEncoding(UTF8_ENCODING);                      /*                  case "UTF-16":                      return getUTF16Encoding();                  case "ISO-8859-1":                      return getEncoding(ISO8859_1_ENCODING);                  case "US-ASCII":                      return getEncoding(ASCII_ENCODING);                      */              }
Missing Default,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following switch statement is missing a default case: switch (byteType(buf' off))                      {                          case BT_EXCL:                              return scanDecl(buf' off + minBPC' end' token);                          case BT_QUEST:                              return scanPi(buf' off + minBPC' end' token);                          case BT_NMSTRT:                          case BT_LEAD2:                          case BT_LEAD3:                          case BT_LEAD4:                              token.TokenEnd = off - minBPC;                              throw new EndOfPrologException();                      }
Missing Default,XpNet,Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\Encoding.cs,tokenizeProlog,The following switch statement is missing a default case: switch (byteType(buf' off))                  {                      case BT_AST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_ASTERISK;                      case BT_QUEST:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_QUESTION;                      case BT_PLUS:                          token.TokenEnd = off + minBPC;                          return TOK.CLOSE_PAREN_PLUS;                      case BT_CR:                      case BT_LF:                      case BT_S:                      case BT_GT:                      case BT_COMMA:                      case BT_VERBAR:                      case BT_RPAR:                          token.TokenEnd = off;                          return TOK.CLOSE_PAREN;                  }
Missing Default,XpNet,UTF8Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,convert,The following switch statement is missing a default case: switch (utf8TypeTable[b & 0xFF])                      {                          case BT_LEAD2:                              /* 5' 6 */                              targetBuf[targetStart++]                                  = (char)(((b & 0x1F) << 6) | (sourceBuf[sourceStart++] & 0x3F));                              break;                          case BT_LEAD3:                              /* 4' 6' 6 */                              c = (b & 0xF) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              targetBuf[targetStart++] = (char)c;                              break;                          case BT_LEAD4:                              /* 3' 6' 6' 6 */                              c = (b & 0x7) << 18;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 12;                              c |= (sourceBuf[sourceStart++] & 0x3F) << 6;                              c |= (sourceBuf[sourceStart++] & 0x3F);                              c -= 0x10000;                              targetBuf[targetStart++] = (char)((c >> 10) | 0xD800);                              targetBuf[targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);                              break;                      }
Missing Default,XpNet,UTF8Encoding,D:\research\architectureSmells\repos1\sgissinger_JabberNet-2010\Jabber\XpNet\UTF8Encoding.cs,movePosition,The following switch statement is missing a default case: switch (b)                      {                          case (byte)'\n':                              lineNumber += 1;                              colDiff = off;                              break;                          case (byte)'\r':                              lineNumber += 1;                              if (off != end && buf[off] == '\n')                                  off++;                              colDiff = off;                              break;                      }
