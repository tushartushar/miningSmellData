Implementation smell,Namespace,Class,File,Method,Description
Long Method,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The method has 105 lines of code.
Complex Method,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,Cyclomatic complexity of the method is 8
Long Parameter List,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CollectSelfLinks,The method has 5 parameters. Parameters: resourceType' criteria' results' level' sortItems
Long Statement,Spark.Mongo.Search.Common,DefinitionsFactory,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Common\DefinitionsFactory.cs,ManualCorrectDefinitions,The length of the statement  "            items.Replace(new Definition() { Resource = "Patient"' ParamName = "phonetic"' Query = new ElementQuery("Patient.Name.Family"' "Patient.Name.Given")' Argument = new FuzzyArgument() }); " is 184.
Long Statement,Spark.Mongo.Search.Common,DefinitionsFactory,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Common\DefinitionsFactory.cs,ManualCorrectDefinitions,The length of the statement  "            items.Replace(new Definition() { Resource = "Practitioner"' ParamName = "phonetic"' Query = new ElementQuery("Practitioner.Name.Family"' "Practitioner.Name.Given")' Argument = new FuzzyArgument() }); " is 199.
Long Statement,Spark.Mongo.Search.Indexer,MongoIndexMapper,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Indexer\MongoIndexMapper.cs,EntryToDocument,The length of the statement  "            List<IndexValue> notNestedValues = indexValue.Values.Where(exp => (exp is IndexValue) && ((IndexValue)exp).Name != "contained").Select(exp => (IndexValue)exp).ToList(); " is 168.
Long Statement,Spark.Mongo.Search.Indexer,MongoIndexMapper,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Indexer\MongoIndexMapper.cs,EntryToDocument,The length of the statement  "            List<IndexValue> containedValues = indexValue.Values.Where(exp => (exp is IndexValue) && ((IndexValue)exp).Name == "contained").Select(exp => (IndexValue)exp).ToList(); " is 168.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,CacheQueryMethods,The length of the statement  "            return typeof(CriteriaMongoExtensions).GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static).Where(m => m.Name.EndsWith("FixedQuery")).ToList(); " is 169.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,ToFilter,The length of the statement  "            throw new ArgumentException(String.Format("Resource {0} has no parameter with the name {1}."' resourceType' param.ParamName)); " is 126.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,CreateFilter,The length of the statement  "                        throw new NotSupportedException(String.Format("SearchParamType {0} on parameter {1} not supported."' parameter.Type' parameter.Name)); " is 134.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,GetTargetedReferenceTypes,The length of the statement  "            var allowedResourceTypes = parameter.Target.Select(t => EnumUtility.GetLiteral(t)).ToList();// ModelInfo.SupportedResources; //TODO: restrict to parameter.ReferencedResources. This means not making this static' because you want to use IFhirModel. " is 246.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,GetTargetedReferenceTypes,The length of the statement  "            return searchResourceTypes.Where(rt => InternalField.All.Contains(nextParameter) || UniversalField.All.Contains(nextParameter) || ModelInfo.SearchParameters.Exists(sp => rt.Equals(sp.Resource) && nextParameter.Equals(sp.Name))).ToList(); " is 237.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,StringQuery,The length of the statement  "                    return M.Query.Or(M.Query.NotExists(parameterName)' M.Query.EQ(parameterName' BsonNull.Value)); //With only M.Query.NotExists' that would exclude resources that have this field with an explicit null in it. " is 205.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,StringQuery,The length of the statement  "                    return M.Query.NE(parameterName' BsonNull.Value); //We don't use M.Query.Exists' because that would include resources that have this field with an explicit null in it. " is 167.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,StringQuery,The length of the statement  "                    throw new ArgumentException(String.Format("Invalid operator {0} on string parameter {1}"' optor.ToString()' parameterName)); " is 124.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,NumberQuery,The length of the statement  "                    throw new ArgumentException(String.Format("Invalid operator {0} on number parameter {1}"' optor.ToString()' parameterName)); " is 124.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,QuantityQuery,The length of the statement  "            //$elemMatch only works on array values. But the MongoIndexMapper only creates an array if there are multiple values for a given parameter. " is 139.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,QuantityQuery,The length of the statement  "            List<IMongoQuery> noArrayQueries = new List<IMongoQuery>() { M.Query.Not(M.Query.Type(parameterName' BsonType.Array)) }; " is 120.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,TokenQuery,The length of the statement  "            //$elemMatch only works on array values. But the MongoIndexMapper only creates an array if there are multiple values for a given parameter. " is 139.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,TokenQuery,The length of the statement  "                    return M.Query.And(M.Query.EQ(parameterName' BsonNull.Value)' M.Query.EQ(textfield' BsonNull.Value)); //We don't use M.Query.NotExists' because that would exclude resources that have this field with an explicit null in it. " is 222.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,TokenQuery,The length of the statement  "                    return M.Query.Or(M.Query.NE(parameterName' BsonNull.Value)' M.Query.EQ(textfield' BsonNull.Value)); //We don't use M.Query.Exists' because that would include resources that have this field with an explicit null in it. " is 218.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,TokenQuery,The length of the statement  "                    throw new ArgumentException(String.Format("Invalid operator {0} on token parameter {1}"' optor.ToString()' parameterName)); " is 123.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,UriQuery,The length of the statement  "                    throw new NotImplementedException(String.Format("Modifier {0} on Uri parameter {1} not supported yet."' modifier' parameterName)); " is 130.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,DateQuery,The length of the statement  "                    return M.Query.EQ(parameterName' null); //We don't use M.Query.NotExists' because that would exclude resources that have this field with an explicit null in it. " is 160.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,DateQuery,The length of the statement  "                    return M.Query.NE(parameterName' null); //We don't use M.Query.Exists' because that would include resources that have this field with an explicit null in it. " is 157.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,DateQuery,The length of the statement  "                    throw new ArgumentException(String.Format("Invalid operator {0} on date parameter {1}"' optor.ToString()' parameterName)); " is 122.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,CompositeQuery,The length of the statement  "                    throw new ArgumentException(String.Format("Parameter {0} requires exactly {1} composite values' not the currently provided {2} values."' parameterDef.Name' subParams.Count()' components.Count())); " is 196.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,CompositeQuery,The length of the statement  "            throw new ArgumentException(String.Format("Invalid operator {0} on composite parameter {1}"' optor.ToString()' parameterDef.Name)); " is 131.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,KeysToSearchResults,The length of the statement  "                    //Uri rid = new Uri(id' UriKind.Relative); // NB. these MUST be relative paths. If not' the data at time of input was wrong  " is 123.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CollectKeys,The length of the statement  "            //All chained criteria are 'closed' or 'rolled up' to something like subject IN (id1' id2' id3)' so now we AND them with the rest of the criteria. " is 146.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CollectSelfLinks,The length of the statement  "            //All chained criteria are 'closed' or 'rolled up' to something like subject IN (id1' id2' id3)' so now we AND them with the rest of the criteria. " is 146.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CreateMongoQuery,The length of the statement  "                            results.AddIssue(String.Format("Parameter [{0}] was ignored for the reason: {1}."' crit.Key.ToString()' ex.Message)' OperationOutcome.IssueSeverity.Warning); " is 157.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CloseChainedCriteria,The length of the statement  "                        //CK: We don't pass the SearchResults on to the (recursive) CloseCriterium. We catch any exceptions only on the highest level. " is 126.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CloseChainedCriteria,The length of the statement  "                        results.AddIssue(String.Format("Parameter [{0}] was ignored for the reason: {1}."' c.ToString()' ex.Message)' OperationOutcome.IssueSeverity.Warning); " is 150.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CloseCriterium,The length of the statement  "                    var keys = CollectKeys(target' new List<Criterium> { innerCriterium }' ++level);               //Recursive call to CollectKeys! " is 127.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CloseCriterium,The length of the statement  "                //It is possible that some of the targets don't support the current parameter. But if none do' there is a serious problem. " is 122.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CloseCriterium,The length of the statement  "                throw new ArgumentException(String.Format("None of the possible target resources support querying for parameter {0}"' crit.ParamName)); " is 135.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The length of the statement  "                //                var critSp_ = _fhirModel.FindSearchParameter(resourceType' crit.ParamName); HIER VERDER: kunnen meerdere searchParameters zijn' hoewel dat alleen bij subcriteria van chains het geval is... " is 206.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The length of the statement  "                if (critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null) " is 159.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The length of the statement  "                    //Because we cannot express an OR construct in Criterium' we have choose one situation for all identifiers. We inspect the first' to determine which situation is appropriate. " is 174.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,GetReverseIncludes,The length of the statement  "            BsonValue[] internal_ids = keys.Select(k => BsonString.Create(String.Format("{0}/{1}"' k.TypeName' k.ResourceId))).ToArray(); " is 125.
Long Statement,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,EnrichCriteriaWithSearchParameters,The length of the statement  "                    results.AddIssue(String.Format("Parameter with name {0} is not supported for resource type {1}."' crit.ParamName' resourceType)' OperationOutcome.IssueSeverity.Warning); " is 169.
Long Statement,Spark.Mongo.Store.Extensions,HistoryStore,C:\repos\furore-fhir_spark\src\Spark.Mongo\Store\Extensions\HistoryExtension.cs,CreateSnapshot,The length of the statement  "            Snapshot snapshot = Snapshot.Create(Bundle.BundleType.History' link' keys' "history" ' count' includes' reverseIncludes); " is 121.
Complex Conditional,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The conditional expression  "critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null"  is complex.
Empty Catch Block,Spark.Mongo.Store,MongoStoreAdministration,C:\repos\furore-fhir_spark\src\Spark.Mongo\Store\MongoStoreAdministration.cs,TryDropCollection,The method has an empty catch block.
Magic Number,Spark.Mongo.Search.Indexer,BsonIndexDocumentBuilder,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Indexer\BsonIndexDocumentBuilder.cs,Cast,The following statement contains a magic number: if (s.Count() == 2)              {                  string system = s[0];                  string code = s[1];                  if (string.IsNullOrEmpty(system))                  {                      return this.RootId + "#" + code;                  }              }
Magic Number,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: foreach (var crit in criteria)              {                  var critSp = crit.FindSearchParamDefinition(resourceType);                  //                var critSp_ = _fhirModel.FindSearchParameter(resourceType' crit.ParamName); HIER VERDER: kunnen meerdere searchParameters zijn' hoewel dat alleen bij subcriteria van chains het geval is...                  if (critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null)                  {                      var subCrit = new Criterium();                      subCrit.Operator = crit.Operator;                      string modifier = crit.Modifier;                        //operand can be one of three things:                      //1. just the id: 10014 (in the index as internal_justid)' with no modifier                      //2. just the id' but with a modifier that contains the type: Patient:10014                      //3. full id: [http://localhost:xyz/fhir/]Patient/10014 (in the index as internal_id):                      //  - might start with a host: http://localhost:xyz/fhir/Patient/100014                      //  - the type in the modifier (if present) is no longer relevant                      //And above that' you might have multiple identifiers with an IN operator. So we have to cater for that as well.                      //Because we cannot express an OR construct in Criterium' we have choose one situation for all identifiers. We inspect the first' to determine which situation is appropriate.                        //step 1: get the operand value' or - in the case of a Choice - the first operand value.                      string operand = null;                      if (crit.Operand is ChoiceValue)                      {                          ChoiceValue choiceOperand = (crit.Operand as ChoiceValue);                          if (!choiceOperand.Choices.Any())                          {                              continue; //Choice operator without choices: ignore it.                          }                          else                          {                              operand = (choiceOperand.Choices.First() as UntypedValue).Value;                          }                      }                      else                      {                          operand = (crit.Operand as UntypedValue).Value;                      }                        //step 2: determine which situation is accurate                      int situation = 3;                      if (!operand.Contains("/")) //Situation 1 or 2                      {                          if (String.IsNullOrWhiteSpace(modifier)) // no modifier' so no info about the referenced type at all                          {                              situation = 1;                          }                          else //modifier contains the referenced type                          {                              situation = 2;                          }                      }                        //step 3: create a subcriterium appropriate for every situation.                       switch (situation)                      {                          case 1:                              subCrit.ParamName = InternalField.JUSTID;                              subCrit.Operand = crit.Operand;                              break;                          case 2:                              subCrit.ParamName = InternalField.ID;                              if (crit.Operand is ChoiceValue)                              {                                  subCrit.Operand = new ChoiceValue(                                      (crit.Operand as ChoiceValue).Choices.Select(choice =>                                          new UntypedValue(modifier + "/" + (choice as UntypedValue).Value))                                          .ToList());                              }                              else                              {                                  subCrit.Operand = new UntypedValue(modifier + "/" + operand);                              }                              break;                          default: //remove the base of the url if there is one and it matches this server                              subCrit.ParamName = InternalField.ID;                              if (crit.Operand is ChoiceValue)                              {                                  subCrit.Operand = new ChoiceValue(                                      (crit.Operand as ChoiceValue).Choices.Select(choice =>                                      {                                          Uri uriOperand;                                          Uri.TryCreate((choice as UntypedValue).Value' UriKind.RelativeOrAbsolute' out uriOperand);                                          var refUri = _localhost.RemoveBase(uriOperand); //Drop the first part if it points to our own server.                                          return new UntypedValue(refUri.ToString().TrimStart(new char[] { '/' }));                                      }));                              }                              else                              {                                  Uri uriOperand;                                  Uri.TryCreate(operand' UriKind.RelativeOrAbsolute' out uriOperand);                                  var refUri = _localhost.RemoveBase(uriOperand); //Drop the first part if it points to our own server.                                  subCrit.Operand = new UntypedValue(refUri.ToString().TrimStart(new char[] { '/' }));                              }                              break;                      }                        var superCrit = new Criterium();                      superCrit.ParamName = crit.ParamName;                      superCrit.Modifier = crit.Modifier;                      superCrit.Operator = Operator.CHAIN;                      superCrit.Operand = subCrit;                      superCrit.SearchParameters.AddRange(crit.SearchParameters);                        result.Add(superCrit);                  }                  else result.Add(crit);              }
Magic Number,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: foreach (var crit in criteria)              {                  var critSp = crit.FindSearchParamDefinition(resourceType);                  //                var critSp_ = _fhirModel.FindSearchParameter(resourceType' crit.ParamName); HIER VERDER: kunnen meerdere searchParameters zijn' hoewel dat alleen bij subcriteria van chains het geval is...                  if (critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null)                  {                      var subCrit = new Criterium();                      subCrit.Operator = crit.Operator;                      string modifier = crit.Modifier;                        //operand can be one of three things:                      //1. just the id: 10014 (in the index as internal_justid)' with no modifier                      //2. just the id' but with a modifier that contains the type: Patient:10014                      //3. full id: [http://localhost:xyz/fhir/]Patient/10014 (in the index as internal_id):                      //  - might start with a host: http://localhost:xyz/fhir/Patient/100014                      //  - the type in the modifier (if present) is no longer relevant                      //And above that' you might have multiple identifiers with an IN operator. So we have to cater for that as well.                      //Because we cannot express an OR construct in Criterium' we have choose one situation for all identifiers. We inspect the first' to determine which situation is appropriate.                        //step 1: get the operand value' or - in the case of a Choice - the first operand value.                      string operand = null;                      if (crit.Operand is ChoiceValue)                      {                          ChoiceValue choiceOperand = (crit.Operand as ChoiceValue);                          if (!choiceOperand.Choices.Any())                          {                              continue; //Choice operator without choices: ignore it.                          }                          else                          {                              operand = (choiceOperand.Choices.First() as UntypedValue).Value;                          }                      }                      else                      {                          operand = (crit.Operand as UntypedValue).Value;                      }                        //step 2: determine which situation is accurate                      int situation = 3;                      if (!operand.Contains("/")) //Situation 1 or 2                      {                          if (String.IsNullOrWhiteSpace(modifier)) // no modifier' so no info about the referenced type at all                          {                              situation = 1;                          }                          else //modifier contains the referenced type                          {                              situation = 2;                          }                      }                        //step 3: create a subcriterium appropriate for every situation.                       switch (situation)                      {                          case 1:                              subCrit.ParamName = InternalField.JUSTID;                              subCrit.Operand = crit.Operand;                              break;                          case 2:                              subCrit.ParamName = InternalField.ID;                              if (crit.Operand is ChoiceValue)                              {                                  subCrit.Operand = new ChoiceValue(                                      (crit.Operand as ChoiceValue).Choices.Select(choice =>                                          new UntypedValue(modifier + "/" + (choice as UntypedValue).Value))                                          .ToList());                              }                              else                              {                                  subCrit.Operand = new UntypedValue(modifier + "/" + operand);                              }                              break;                          default: //remove the base of the url if there is one and it matches this server                              subCrit.ParamName = InternalField.ID;                              if (crit.Operand is ChoiceValue)                              {                                  subCrit.Operand = new ChoiceValue(                                      (crit.Operand as ChoiceValue).Choices.Select(choice =>                                      {                                          Uri uriOperand;                                          Uri.TryCreate((choice as UntypedValue).Value' UriKind.RelativeOrAbsolute' out uriOperand);                                          var refUri = _localhost.RemoveBase(uriOperand); //Drop the first part if it points to our own server.                                          return new UntypedValue(refUri.ToString().TrimStart(new char[] { '/' }));                                      }));                              }                              else                              {                                  Uri uriOperand;                                  Uri.TryCreate(operand' UriKind.RelativeOrAbsolute' out uriOperand);                                  var refUri = _localhost.RemoveBase(uriOperand); //Drop the first part if it points to our own server.                                  subCrit.Operand = new UntypedValue(refUri.ToString().TrimStart(new char[] { '/' }));                              }                              break;                      }                        var superCrit = new Criterium();                      superCrit.ParamName = crit.ParamName;                      superCrit.Modifier = crit.Modifier;                      superCrit.Operator = Operator.CHAIN;                      superCrit.Operand = subCrit;                      superCrit.SearchParameters.AddRange(crit.SearchParameters);                        result.Add(superCrit);                  }                  else result.Add(crit);              }
Magic Number,Spark.Search.Mongo,MongoSearcher,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: foreach (var crit in criteria)              {                  var critSp = crit.FindSearchParamDefinition(resourceType);                  //                var critSp_ = _fhirModel.FindSearchParameter(resourceType' crit.ParamName); HIER VERDER: kunnen meerdere searchParameters zijn' hoewel dat alleen bij subcriteria van chains het geval is...                  if (critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null)                  {                      var subCrit = new Criterium();                      subCrit.Operator = crit.Operator;                      string modifier = crit.Modifier;                        //operand can be one of three things:                      //1. just the id: 10014 (in the index as internal_justid)' with no modifier                      //2. just the id' but with a modifier that contains the type: Patient:10014                      //3. full id: [http://localhost:xyz/fhir/]Patient/10014 (in the index as internal_id):                      //  - might start with a host: http://localhost:xyz/fhir/Patient/100014                      //  - the type in the modifier (if present) is no longer relevant                      //And above that' you might have multiple identifiers with an IN operator. So we have to cater for that as well.                      //Because we cannot express an OR construct in Criterium' we have choose one situation for all identifiers. We inspect the first' to determine which situation is appropriate.                        //step 1: get the operand value' or - in the case of a Choice - the first operand value.                      string operand = null;                      if (crit.Operand is ChoiceValue)                      {                          ChoiceValue choiceOperand = (crit.Operand as ChoiceValue);                          if (!choiceOperand.Choices.Any())                          {                              continue; //Choice operator without choices: ignore it.                          }                          else                          {                              operand = (choiceOperand.Choices.First() as UntypedValue).Value;                          }                      }                      else                      {                          operand = (crit.Operand as UntypedValue).Value;                      }                        //step 2: determine which situation is accurate                      int situation = 3;                      if (!operand.Contains("/")) //Situation 1 or 2                      {                          if (String.IsNullOrWhiteSpace(modifier)) // no modifier' so no info about the referenced type at all                          {                              situation = 1;                          }                          else //modifier contains the referenced type                          {                              situation = 2;                          }                      }                        //step 3: create a subcriterium appropriate for every situation.                       switch (situation)                      {                          case 1:                              subCrit.ParamName = InternalField.JUSTID;                              subCrit.Operand = crit.Operand;                              break;                          case 2:                              subCrit.ParamName = InternalField.ID;                              if (crit.Operand is ChoiceValue)                              {                                  subCrit.Operand = new ChoiceValue(                                      (crit.Operand as ChoiceValue).Choices.Select(choice =>                                          new UntypedValue(modifier + "/" + (choice as UntypedValue).Value))                                          .ToList());                              }                              else                              {                                  subCrit.Operand = new UntypedValue(modifier + "/" + operand);                              }                              break;                          default: //remove the base of the url if there is one and it matches this server                              subCrit.ParamName = InternalField.ID;                              if (crit.Operand is ChoiceValue)                              {                                  subCrit.Operand = new ChoiceValue(                                      (crit.Operand as ChoiceValue).Choices.Select(choice =>                                      {                                          Uri uriOperand;                                          Uri.TryCreate((choice as UntypedValue).Value' UriKind.RelativeOrAbsolute' out uriOperand);                                          var refUri = _localhost.RemoveBase(uriOperand); //Drop the first part if it points to our own server.                                          return new UntypedValue(refUri.ToString().TrimStart(new char[] { '/' }));                                      }));                              }                              else                              {                                  Uri uriOperand;                                  Uri.TryCreate(operand' UriKind.RelativeOrAbsolute' out uriOperand);                                  var refUri = _localhost.RemoveBase(uriOperand); //Drop the first part if it points to our own server.                                  subCrit.Operand = new UntypedValue(refUri.ToString().TrimStart(new char[] { '/' }));                              }                              break;                      }                        var superCrit = new Criterium();                      superCrit.ParamName = crit.ParamName;                      superCrit.Modifier = crit.Modifier;                      superCrit.Operator = Operator.CHAIN;                      superCrit.Operand = subCrit;                      superCrit.SearchParameters.AddRange(crit.SearchParameters);                        result.Add(superCrit);                  }                  else result.Add(crit);              }
Magic Number,Spark.Search.Mongo,Soundex,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Utils\Soundex.cs,For,The following statement contains a magic number: const int length = 4;
Magic Number,Spark.Search.Mongo,Soundex,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Utils\Soundex.cs,For,The following statement contains a magic number: for (var i = 1; i < word.Length; i++)              {                  var n = GetCharNumberForLetter(word[i]);                    if (i == 1 && n == GetCharNumberForLetter(soundex[0]))                      continue;                    if (soundex.Length > 2 && previousWasHOrW && n == soundex[soundex.Length - 2])                      continue;                    if (soundex.Length > 0 && n == soundex[soundex.Length - 1])                      continue;                    soundex.Append(n);                    previousWasHOrW = "HW".Contains(word[i]);              }
Magic Number,Spark.Search.Mongo,Soundex,C:\repos\furore-fhir_spark\src\Spark.Mongo\Search\Utils\Soundex.cs,For,The following statement contains a magic number: for (var i = 1; i < word.Length; i++)              {                  var n = GetCharNumberForLetter(word[i]);                    if (i == 1 && n == GetCharNumberForLetter(soundex[0]))                      continue;                    if (soundex.Length > 2 && previousWasHOrW && n == soundex[soundex.Length - 2])                      continue;                    if (soundex.Length > 0 && n == soundex[soundex.Length - 1])                      continue;                    soundex.Append(n);                    previousWasHOrW = "HW".Contains(word[i]);              }
