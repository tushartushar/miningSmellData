Implementation smell,Namespace,Class,File,Method,Description
Long Method,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The method has 92 lines of code.
Complex Method,Spark.Mongo.Search.Common,ArgumentFactory,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Common\Arguments.cs,Create,Cyclomatic complexity of the method is 7
Complex Method,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,CreateFilter,Cyclomatic complexity of the method is 12
Complex Method,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,StringQuery,Cyclomatic complexity of the method is 9
Complex Method,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,NumberQuery,Cyclomatic complexity of the method is 15
Complex Method,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,ExpressionQuery,Cyclomatic complexity of the method is 9
Complex Method,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,QuantityQuery,Cyclomatic complexity of the method is 9
Complex Method,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,TokenQuery,Cyclomatic complexity of the method is 13
Complex Method,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,UriQuery,Cyclomatic complexity of the method is 13
Complex Method,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,DateQuery,Cyclomatic complexity of the method is 10
Complex Method,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,Cyclomatic complexity of the method is 20
Long Parameter List,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,CreateFilter,The method has 4 parameters.
Long Parameter List,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,StringQuery,The method has 4 parameters.
Long Parameter List,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,QuantityQuery,The method has 4 parameters.
Long Parameter List,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,TokenQuery,The method has 4 parameters.
Long Parameter List,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,UriQuery,The method has 4 parameters.
Long Parameter List,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,DateQuery,The method has 4 parameters.
Long Parameter List,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,CompositeQuery,The method has 4 parameters.
Long Parameter List,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CollectKeys,The method has 4 parameters.
Long Parameter List,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CollectSelfLinks,The method has 5 parameters.
Long Parameter List,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CreateMongoQuery,The method has 4 parameters.
Long Parameter List,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CloseChainedCriteria,The method has 4 parameters.
Long Parameter List,Spark.Mongo.Store.Extensions,HistoryStore,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Store\Extensions\HistoryExtension.cs,CreateSnapshot,The method has 4 parameters.
Long Statement,Spark.Mongo.Search.Indexer,BsonIndexDocumentBuilder,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Indexer\BsonIndexDocumentBuilder.cs,WriteMetaData,The length of the statement  "		var fdt = resource.Meta.LastUpdated.HasValue ? new FhirDateTime (resource.Meta.LastUpdated.Value) : FhirDateTime.Now (); " is 120.
Long Statement,Spark.Mongo.Search.Indexer,MongoIndexMapper,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Indexer\MongoIndexMapper.cs,EntryToDocument,The length of the statement  "	List<IndexValue> notNestedValues = indexValue.Values.Where (exp => (exp is IndexValue) && ((IndexValue)exp).Name != "contained").Select (exp => (IndexValue)exp).ToList (); " is 171.
Long Statement,Spark.Mongo.Search.Indexer,MongoIndexMapper,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Indexer\MongoIndexMapper.cs,EntryToDocument,The length of the statement  "	List<IndexValue> containedValues = indexValue.Values.Where (exp => (exp is IndexValue) && ((IndexValue)exp).Name == "contained").Select (exp => (IndexValue)exp).ToList (); " is 171.
Long Statement,Spark.Store.Mongo,SparkBsonHelper,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Store\BsonHelper.cs,AddMetaData,The length of the statement  "	document [Field.WHEN] = (resource != null && resource.Meta != null && resource.Meta.LastUpdated.HasValue) ? resource.Meta.LastUpdated.Value.UtcDateTime : DateTime.UtcNow; " is 170.
Long Statement,Spark.Store.Mongo,MongoFhirStoreOther,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Store\MongoFhirStoreOther.cs,Supercede,The length of the statement  "	IMongoQuery query = MongoDB.Driver.Builders.Query.And (MongoDB.Driver.Builders.Query.In (Field.REFERENCE' pks)' MongoDB.Driver.Builders.Query.EQ (Field.STATE' Value.CURRENT)); " is 175.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,CacheQueryMethods,The length of the statement  "	return typeof(CriteriaMongoExtensions).GetMethods (BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static).Where (m => m.Name.EndsWith ("FixedQuery")).ToList (); " is 173.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,ToFilter,The length of the statement  "	throw new ArgumentException (String.Format ("Resource {0} has no parameter with the name {1}."' resourceType' param.ParamName)); " is 128.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,CreateFilter,The length of the statement  "			throw new NotSupportedException (String.Format ("SearchParamType {0} on parameter {1} not supported."' parameter.Type' parameter.Name)); " is 136.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,GetTargetedReferenceTypes,The length of the statement  "	// ModelInfo.SupportedResources; //TODO: restrict to parameter.ReferencedResources. This means not making this static' because you want to use IFhirModel. " is 154.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,GetTargetedReferenceTypes,The length of the statement  "	return searchResourceTypes.Where (rt => InternalField.All.Contains (nextParameter) || UniversalField.All.Contains (nextParameter) || ModelInfo.SearchParameters.Exists (sp => rt.Equals (sp.Resource) && nextParameter.Equals (sp.Name))).ToList (); " is 244.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,StringQuery,The length of the statement  "		throw new ArgumentException (String.Format ("Invalid operator {0} on string parameter {1}"' optor.ToString ()' parameterName)); " is 127.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,NumberQuery,The length of the statement  "		throw new ArgumentException (String.Format ("Invalid number value {0} on number parameter {1}"' operand' parameterName)); " is 121.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,NumberQuery,The length of the statement  "		throw new ArgumentException (String.Format ("Invalid number value {0} on number parameter {1}"' operand' parameterName)); " is 121.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,NumberQuery,The length of the statement  "		throw new ArgumentException (String.Format ("Invalid operator {0} on number parameter {1}"' optor.ToString ()' parameterName)); " is 127.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,QuantityQuery,The length of the statement  "	//$elemMatch only works on array values. But the MongoIndexMapper only creates an array if there are multiple values for a given parameter. " is 139.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,TokenQuery,The length of the statement  "	//$elemMatch only works on array values. But the MongoIndexMapper only creates an array if there are multiple values for a given parameter. " is 139.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,TokenQuery,The length of the statement  "	//We don't use M.Query.NotExists' because that would exclude resources that have this field with an explicit null in it. " is 120.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,TokenQuery,The length of the statement  "		throw new ArgumentException (String.Format ("Invalid operator {0} on token parameter {1}"' optor.ToString ()' parameterName)); " is 126.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,UriQuery,The length of the statement  "		throw new NotImplementedException (String.Format ("Modifier {0} on Uri parameter {1} not supported yet."' modifier' parameterName)); " is 132.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,DateQuery,The length of the statement  "	//We don't use M.Query.NotExists' because that would exclude resources that have this field with an explicit null in it. " is 120.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,DateQuery,The length of the statement  "		throw new ArgumentException (String.Format ("Invalid operator {0} on date parameter {1}"' optor.ToString ()' parameterName)); " is 125.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,CompositeQuery,The length of the statement  "			throw new ArgumentException (String.Format ("Parameter {0} requires exactly {1} composite values' not the currently provided {2} values."' parameterDef.Name' subParams.Count ()' components.Count ())); " is 200.
Long Statement,Spark.Search.Mongo,CriteriaMongoExtensions,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\CriteriaMongoExtensions.cs,CompositeQuery,The length of the statement  "	throw new ArgumentException (String.Format ("Invalid operator {0} on composite parameter {1}"' optor.ToString ()' parameterDef.Name)); " is 134.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,KeysToSearchResults,The length of the statement  "			//Uri rid = new Uri(id' UriKind.Relative); // NB. these MUST be relative paths. If not' the data at time of input was wrong  " is 123.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CollectKeys,The length of the statement  "	//All chained criteria are 'closed' or 'rolled up' to something like subject IN (id1' id2' id3)' so now we AND them with the rest of the criteria. " is 146.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CollectSelfLinks,The length of the statement  "	//All chained criteria are 'closed' or 'rolled up' to something like subject IN (id1' id2' id3)' so now we AND them with the rest of the criteria. " is 146.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CreateMongoQuery,The length of the statement  "					results.AddIssue (String.Format ("Parameter [{0}] was ignored for the reason: {1}."' crit.Key.ToString ()' ex.Message)' OperationOutcome.IssueSeverity.Warning); " is 160.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CloseChainedCriteria,The length of the statement  "				//CK: We don't pass the SearchResults on to the (recursive) CloseCriterium. We catch any exceptions only on the highest level. " is 126.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CloseChainedCriteria,The length of the statement  "				results.AddIssue (String.Format ("Parameter [{0}] was ignored for the reason: {1}."' c.ToString ()' ex.Message)' OperationOutcome.IssueSeverity.Warning); " is 153.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CloseCriterium,The length of the statement  "		//It is possible that some of the targets don't support the current parameter. But if none do' there is a serious problem. " is 122.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,CloseCriterium,The length of the statement  "		throw new ArgumentException (String.Format ("None of the possible target resources support querying for parameter {0}"' crit.ParamName)); " is 137.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The length of the statement  "		//                var critSp_ = _fhirModel.FindSearchParameter(resourceType' crit.ParamName); HIER VERDER: kunnen meerdere searchParameters zijn' hoewel dat alleen bij subcriteria van chains het geval is... " is 206.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The length of the statement  "		if (critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null) { " is 161.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The length of the statement  "			//Because we cannot express an OR construct in Criterium' we have choose one situation for all identifiers. We inspect the first' to determine which situation is appropriate. " is 174.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The length of the statement  "					subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => new UntypedValue (modifier + "/" + (choice as UntypedValue).Value)).ToList ()); " is 170.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeSortItem,The length of the statement  "	ModelInfo.SearchParamDefinition definition = _fhirModel.FindSearchParameter (resourceType' sortItem.Item1).GetOriginalDefinition (); " is 132.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,GetReverseIncludes,The length of the statement  "	BsonValue[] internal_ids = keys.Select (k => BsonString.Create (String.Format ("{0}/{1}"' k.TypeName' k.ResourceId))).ToArray (); " is 129.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,GetReverseIncludes,The length of the statement  "				riQueries.Add (M.Query.And (M.Query.EQ (InternalField.RESOURCE' ri.ResourceType)' M.Query.In (ri.SearchPath' internal_ids))); " is 125.
Long Statement,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,EnrichCriteriaWithSearchParameters,The length of the statement  "			results.AddIssue (String.Format ("Parameter with name {0} is not supported for resource type {1}."' crit.ParamName' resourceType)' OperationOutcome.IssueSeverity.Warning); " is 171.
Long Statement,Spark.Mongo.Store.Extensions,HistoryStore,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Store\Extensions\HistoryExtension.cs,FetchPrimaryKeys,The length of the statement  "	MongoCursor<BsonDocument> cursor = collection.Find (query).SetSortOrder (MongoDB.Driver.Builders.SortBy.Descending (Field.WHEN)); " is 129.
Long Statement,Spark.Mongo.Store.Extensions,HistoryStore,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Store\Extensions\HistoryExtension.cs,CreateSnapshot,The length of the statement  "	Snapshot snapshot = Snapshot.Create (Bundle.BundleType.History' link' keys' "history"' count' includes' reverseIncludes); " is 121.
Long Statement,Spark.Mongo.Store,MongoStoreBuilder,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Store\MongoStoreBuilder.cs,GetFhirIndex,The length of the statement  "	return new MongoFhirIndex (indexStore' new MongoIndexer (indexStore' new Definitions ())' new MongoSearcher (indexStore' localhost' new FhirModel ())); " is 151.
Complex Conditional,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The conditional expression  "critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null"  is complex.
Empty Catch Block,Spark.Mongo.Store,MongoStoreAdministration,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Store\MongoStoreAdministration.cs,TryDropCollection,The method has an empty catch block.
Magic Number,Spark.Mongo.Search.Indexer,BsonIndexDocumentBuilder,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Indexer\BsonIndexDocumentBuilder.cs,Cast,The following statement contains a magic number: if (s.Count () == 2) {  	string system = s [0];  	string code = s [1];  	if (string.IsNullOrEmpty (system)) {  		return this.RootId + "#" + code;  	}  }  
Magic Number,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: foreach (var crit in criteria) {  	var critSp = crit.FindSearchParamDefinition (resourceType);  	//                var critSp_ = _fhirModel.FindSearchParameter(resourceType' crit.ParamName); HIER VERDER: kunnen meerdere searchParameters zijn' hoewel dat alleen bij subcriteria van chains het geval is...  	if (critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null) {  		var subCrit = new Criterium ();  		subCrit.Operator = crit.Operator;  		string modifier = crit.Modifier;  		//operand can be one of three things:  		//1. just the id: 10014 (in the index as internal_justid)' with no modifier  		//2. just the id' but with a modifier that contains the type: Patient:10014  		//3. full id: [http://localhost:xyz/fhir/]Patient/10014 (in the index as internal_id):  		//  - might start with a host: http://localhost:xyz/fhir/Patient/100014  		//  - the type in the modifier (if present) is no longer relevant  		//And above that' you might have multiple identifiers with an IN operator. So we have to cater for that as well.  		//Because we cannot express an OR construct in Criterium' we have choose one situation for all identifiers. We inspect the first' to determine which situation is appropriate.  		//step 1: get the operand value' or - in the case of a Choice - the first operand value.  		string operand = null;  		if (crit.Operand is ChoiceValue) {  			ChoiceValue choiceOperand = (crit.Operand as ChoiceValue);  			if (!choiceOperand.Choices.Any ()) {  				continue;  				//Choice operator without choices: ignore it.  			} else {  				operand = (choiceOperand.Choices.First () as UntypedValue).Value;  			}  		} else {  			operand = (crit.Operand as UntypedValue).Value;  		}  		//step 2: determine which situation is accurate  		int situation = 3;  		if (!operand.Contains ("/"))//Situation 1 or 2  		 {  			if (String.IsNullOrWhiteSpace (modifier))// no modifier' so no info about the referenced type at all  			 {  				situation = 1;  			} else//modifier contains the referenced type  			 {  				situation = 2;  			}  		}  		//step 3: create a subcriterium appropriate for every situation.   		switch (situation) {  		case 1:  			subCrit.ParamName = InternalField.JUSTID;  			subCrit.Operand = crit.Operand;  			break;  		case 2:  			subCrit.ParamName = InternalField.ID;  			if (crit.Operand is ChoiceValue) {  				subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => new UntypedValue (modifier + "/" + (choice as UntypedValue).Value)).ToList ());  			} else {  				subCrit.Operand = new UntypedValue (modifier + "/" + operand);  			}  			break;  		default:  			//remove the base of the url if there is one and it matches this server  			subCrit.ParamName = InternalField.ID;  			if (crit.Operand is ChoiceValue) {  				subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => {  					Uri uriOperand;  					Uri.TryCreate ((choice as UntypedValue).Value' UriKind.RelativeOrAbsolute' out uriOperand);  					var refUri = _localhost.RemoveBase (uriOperand);  					//Drop the first part if it points to our own server.  					return new UntypedValue (refUri.ToString ().TrimStart (new char[] {  						'/'  					}));  				}));  			} else {  				Uri uriOperand;  				Uri.TryCreate (operand' UriKind.RelativeOrAbsolute' out uriOperand);  				var refUri = _localhost.RemoveBase (uriOperand);  				//Drop the first part if it points to our own server.  				subCrit.Operand = new UntypedValue (refUri.ToString ().TrimStart (new char[] {  					'/'  				}));  			}  			break;  		}  		var superCrit = new Criterium ();  		superCrit.ParamName = crit.ParamName;  		superCrit.Modifier = crit.Modifier;  		superCrit.Operator = Operator.CHAIN;  		superCrit.Operand = subCrit;  		superCrit.SearchParameters.AddRange (crit.SearchParameters);  		result.Add (superCrit);  	} else  		result.Add (crit);  }  
Magic Number,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: foreach (var crit in criteria) {  	var critSp = crit.FindSearchParamDefinition (resourceType);  	//                var critSp_ = _fhirModel.FindSearchParameter(resourceType' crit.ParamName); HIER VERDER: kunnen meerdere searchParameters zijn' hoewel dat alleen bij subcriteria van chains het geval is...  	if (critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null) {  		var subCrit = new Criterium ();  		subCrit.Operator = crit.Operator;  		string modifier = crit.Modifier;  		//operand can be one of three things:  		//1. just the id: 10014 (in the index as internal_justid)' with no modifier  		//2. just the id' but with a modifier that contains the type: Patient:10014  		//3. full id: [http://localhost:xyz/fhir/]Patient/10014 (in the index as internal_id):  		//  - might start with a host: http://localhost:xyz/fhir/Patient/100014  		//  - the type in the modifier (if present) is no longer relevant  		//And above that' you might have multiple identifiers with an IN operator. So we have to cater for that as well.  		//Because we cannot express an OR construct in Criterium' we have choose one situation for all identifiers. We inspect the first' to determine which situation is appropriate.  		//step 1: get the operand value' or - in the case of a Choice - the first operand value.  		string operand = null;  		if (crit.Operand is ChoiceValue) {  			ChoiceValue choiceOperand = (crit.Operand as ChoiceValue);  			if (!choiceOperand.Choices.Any ()) {  				continue;  				//Choice operator without choices: ignore it.  			} else {  				operand = (choiceOperand.Choices.First () as UntypedValue).Value;  			}  		} else {  			operand = (crit.Operand as UntypedValue).Value;  		}  		//step 2: determine which situation is accurate  		int situation = 3;  		if (!operand.Contains ("/"))//Situation 1 or 2  		 {  			if (String.IsNullOrWhiteSpace (modifier))// no modifier' so no info about the referenced type at all  			 {  				situation = 1;  			} else//modifier contains the referenced type  			 {  				situation = 2;  			}  		}  		//step 3: create a subcriterium appropriate for every situation.   		switch (situation) {  		case 1:  			subCrit.ParamName = InternalField.JUSTID;  			subCrit.Operand = crit.Operand;  			break;  		case 2:  			subCrit.ParamName = InternalField.ID;  			if (crit.Operand is ChoiceValue) {  				subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => new UntypedValue (modifier + "/" + (choice as UntypedValue).Value)).ToList ());  			} else {  				subCrit.Operand = new UntypedValue (modifier + "/" + operand);  			}  			break;  		default:  			//remove the base of the url if there is one and it matches this server  			subCrit.ParamName = InternalField.ID;  			if (crit.Operand is ChoiceValue) {  				subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => {  					Uri uriOperand;  					Uri.TryCreate ((choice as UntypedValue).Value' UriKind.RelativeOrAbsolute' out uriOperand);  					var refUri = _localhost.RemoveBase (uriOperand);  					//Drop the first part if it points to our own server.  					return new UntypedValue (refUri.ToString ().TrimStart (new char[] {  						'/'  					}));  				}));  			} else {  				Uri uriOperand;  				Uri.TryCreate (operand' UriKind.RelativeOrAbsolute' out uriOperand);  				var refUri = _localhost.RemoveBase (uriOperand);  				//Drop the first part if it points to our own server.  				subCrit.Operand = new UntypedValue (refUri.ToString ().TrimStart (new char[] {  					'/'  				}));  			}  			break;  		}  		var superCrit = new Criterium ();  		superCrit.ParamName = crit.ParamName;  		superCrit.Modifier = crit.Modifier;  		superCrit.Operator = Operator.CHAIN;  		superCrit.Operand = subCrit;  		superCrit.SearchParameters.AddRange (crit.SearchParameters);  		result.Add (superCrit);  	} else  		result.Add (crit);  }  
Magic Number,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: foreach (var crit in criteria) {  	var critSp = crit.FindSearchParamDefinition (resourceType);  	//                var critSp_ = _fhirModel.FindSearchParameter(resourceType' crit.ParamName); HIER VERDER: kunnen meerdere searchParameters zijn' hoewel dat alleen bij subcriteria van chains het geval is...  	if (critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null) {  		var subCrit = new Criterium ();  		subCrit.Operator = crit.Operator;  		string modifier = crit.Modifier;  		//operand can be one of three things:  		//1. just the id: 10014 (in the index as internal_justid)' with no modifier  		//2. just the id' but with a modifier that contains the type: Patient:10014  		//3. full id: [http://localhost:xyz/fhir/]Patient/10014 (in the index as internal_id):  		//  - might start with a host: http://localhost:xyz/fhir/Patient/100014  		//  - the type in the modifier (if present) is no longer relevant  		//And above that' you might have multiple identifiers with an IN operator. So we have to cater for that as well.  		//Because we cannot express an OR construct in Criterium' we have choose one situation for all identifiers. We inspect the first' to determine which situation is appropriate.  		//step 1: get the operand value' or - in the case of a Choice - the first operand value.  		string operand = null;  		if (crit.Operand is ChoiceValue) {  			ChoiceValue choiceOperand = (crit.Operand as ChoiceValue);  			if (!choiceOperand.Choices.Any ()) {  				continue;  				//Choice operator without choices: ignore it.  			} else {  				operand = (choiceOperand.Choices.First () as UntypedValue).Value;  			}  		} else {  			operand = (crit.Operand as UntypedValue).Value;  		}  		//step 2: determine which situation is accurate  		int situation = 3;  		if (!operand.Contains ("/"))//Situation 1 or 2  		 {  			if (String.IsNullOrWhiteSpace (modifier))// no modifier' so no info about the referenced type at all  			 {  				situation = 1;  			} else//modifier contains the referenced type  			 {  				situation = 2;  			}  		}  		//step 3: create a subcriterium appropriate for every situation.   		switch (situation) {  		case 1:  			subCrit.ParamName = InternalField.JUSTID;  			subCrit.Operand = crit.Operand;  			break;  		case 2:  			subCrit.ParamName = InternalField.ID;  			if (crit.Operand is ChoiceValue) {  				subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => new UntypedValue (modifier + "/" + (choice as UntypedValue).Value)).ToList ());  			} else {  				subCrit.Operand = new UntypedValue (modifier + "/" + operand);  			}  			break;  		default:  			//remove the base of the url if there is one and it matches this server  			subCrit.ParamName = InternalField.ID;  			if (crit.Operand is ChoiceValue) {  				subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => {  					Uri uriOperand;  					Uri.TryCreate ((choice as UntypedValue).Value' UriKind.RelativeOrAbsolute' out uriOperand);  					var refUri = _localhost.RemoveBase (uriOperand);  					//Drop the first part if it points to our own server.  					return new UntypedValue (refUri.ToString ().TrimStart (new char[] {  						'/'  					}));  				}));  			} else {  				Uri uriOperand;  				Uri.TryCreate (operand' UriKind.RelativeOrAbsolute' out uriOperand);  				var refUri = _localhost.RemoveBase (uriOperand);  				//Drop the first part if it points to our own server.  				subCrit.Operand = new UntypedValue (refUri.ToString ().TrimStart (new char[] {  					'/'  				}));  			}  			break;  		}  		var superCrit = new Criterium ();  		superCrit.ParamName = crit.ParamName;  		superCrit.Modifier = crit.Modifier;  		superCrit.Operator = Operator.CHAIN;  		superCrit.Operand = subCrit;  		superCrit.SearchParameters.AddRange (crit.SearchParameters);  		result.Add (superCrit);  	} else  		result.Add (crit);  }  
Magic Number,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: if (critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null) {  	var subCrit = new Criterium ();  	subCrit.Operator = crit.Operator;  	string modifier = crit.Modifier;  	//operand can be one of three things:  	//1. just the id: 10014 (in the index as internal_justid)' with no modifier  	//2. just the id' but with a modifier that contains the type: Patient:10014  	//3. full id: [http://localhost:xyz/fhir/]Patient/10014 (in the index as internal_id):  	//  - might start with a host: http://localhost:xyz/fhir/Patient/100014  	//  - the type in the modifier (if present) is no longer relevant  	//And above that' you might have multiple identifiers with an IN operator. So we have to cater for that as well.  	//Because we cannot express an OR construct in Criterium' we have choose one situation for all identifiers. We inspect the first' to determine which situation is appropriate.  	//step 1: get the operand value' or - in the case of a Choice - the first operand value.  	string operand = null;  	if (crit.Operand is ChoiceValue) {  		ChoiceValue choiceOperand = (crit.Operand as ChoiceValue);  		if (!choiceOperand.Choices.Any ()) {  			continue;  			//Choice operator without choices: ignore it.  		} else {  			operand = (choiceOperand.Choices.First () as UntypedValue).Value;  		}  	} else {  		operand = (crit.Operand as UntypedValue).Value;  	}  	//step 2: determine which situation is accurate  	int situation = 3;  	if (!operand.Contains ("/"))//Situation 1 or 2  	 {  		if (String.IsNullOrWhiteSpace (modifier))// no modifier' so no info about the referenced type at all  		 {  			situation = 1;  		} else//modifier contains the referenced type  		 {  			situation = 2;  		}  	}  	//step 3: create a subcriterium appropriate for every situation.   	switch (situation) {  	case 1:  		subCrit.ParamName = InternalField.JUSTID;  		subCrit.Operand = crit.Operand;  		break;  	case 2:  		subCrit.ParamName = InternalField.ID;  		if (crit.Operand is ChoiceValue) {  			subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => new UntypedValue (modifier + "/" + (choice as UntypedValue).Value)).ToList ());  		} else {  			subCrit.Operand = new UntypedValue (modifier + "/" + operand);  		}  		break;  	default:  		//remove the base of the url if there is one and it matches this server  		subCrit.ParamName = InternalField.ID;  		if (crit.Operand is ChoiceValue) {  			subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => {  				Uri uriOperand;  				Uri.TryCreate ((choice as UntypedValue).Value' UriKind.RelativeOrAbsolute' out uriOperand);  				var refUri = _localhost.RemoveBase (uriOperand);  				//Drop the first part if it points to our own server.  				return new UntypedValue (refUri.ToString ().TrimStart (new char[] {  					'/'  				}));  			}));  		} else {  			Uri uriOperand;  			Uri.TryCreate (operand' UriKind.RelativeOrAbsolute' out uriOperand);  			var refUri = _localhost.RemoveBase (uriOperand);  			//Drop the first part if it points to our own server.  			subCrit.Operand = new UntypedValue (refUri.ToString ().TrimStart (new char[] {  				'/'  			}));  		}  		break;  	}  	var superCrit = new Criterium ();  	superCrit.ParamName = crit.ParamName;  	superCrit.Modifier = crit.Modifier;  	superCrit.Operator = Operator.CHAIN;  	superCrit.Operand = subCrit;  	superCrit.SearchParameters.AddRange (crit.SearchParameters);  	result.Add (superCrit);  } else  	result.Add (crit);  
Magic Number,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: if (critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null) {  	var subCrit = new Criterium ();  	subCrit.Operator = crit.Operator;  	string modifier = crit.Modifier;  	//operand can be one of three things:  	//1. just the id: 10014 (in the index as internal_justid)' with no modifier  	//2. just the id' but with a modifier that contains the type: Patient:10014  	//3. full id: [http://localhost:xyz/fhir/]Patient/10014 (in the index as internal_id):  	//  - might start with a host: http://localhost:xyz/fhir/Patient/100014  	//  - the type in the modifier (if present) is no longer relevant  	//And above that' you might have multiple identifiers with an IN operator. So we have to cater for that as well.  	//Because we cannot express an OR construct in Criterium' we have choose one situation for all identifiers. We inspect the first' to determine which situation is appropriate.  	//step 1: get the operand value' or - in the case of a Choice - the first operand value.  	string operand = null;  	if (crit.Operand is ChoiceValue) {  		ChoiceValue choiceOperand = (crit.Operand as ChoiceValue);  		if (!choiceOperand.Choices.Any ()) {  			continue;  			//Choice operator without choices: ignore it.  		} else {  			operand = (choiceOperand.Choices.First () as UntypedValue).Value;  		}  	} else {  		operand = (crit.Operand as UntypedValue).Value;  	}  	//step 2: determine which situation is accurate  	int situation = 3;  	if (!operand.Contains ("/"))//Situation 1 or 2  	 {  		if (String.IsNullOrWhiteSpace (modifier))// no modifier' so no info about the referenced type at all  		 {  			situation = 1;  		} else//modifier contains the referenced type  		 {  			situation = 2;  		}  	}  	//step 3: create a subcriterium appropriate for every situation.   	switch (situation) {  	case 1:  		subCrit.ParamName = InternalField.JUSTID;  		subCrit.Operand = crit.Operand;  		break;  	case 2:  		subCrit.ParamName = InternalField.ID;  		if (crit.Operand is ChoiceValue) {  			subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => new UntypedValue (modifier + "/" + (choice as UntypedValue).Value)).ToList ());  		} else {  			subCrit.Operand = new UntypedValue (modifier + "/" + operand);  		}  		break;  	default:  		//remove the base of the url if there is one and it matches this server  		subCrit.ParamName = InternalField.ID;  		if (crit.Operand is ChoiceValue) {  			subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => {  				Uri uriOperand;  				Uri.TryCreate ((choice as UntypedValue).Value' UriKind.RelativeOrAbsolute' out uriOperand);  				var refUri = _localhost.RemoveBase (uriOperand);  				//Drop the first part if it points to our own server.  				return new UntypedValue (refUri.ToString ().TrimStart (new char[] {  					'/'  				}));  			}));  		} else {  			Uri uriOperand;  			Uri.TryCreate (operand' UriKind.RelativeOrAbsolute' out uriOperand);  			var refUri = _localhost.RemoveBase (uriOperand);  			//Drop the first part if it points to our own server.  			subCrit.Operand = new UntypedValue (refUri.ToString ().TrimStart (new char[] {  				'/'  			}));  		}  		break;  	}  	var superCrit = new Criterium ();  	superCrit.ParamName = crit.ParamName;  	superCrit.Modifier = crit.Modifier;  	superCrit.Operator = Operator.CHAIN;  	superCrit.Operand = subCrit;  	superCrit.SearchParameters.AddRange (crit.SearchParameters);  	result.Add (superCrit);  } else  	result.Add (crit);  
Magic Number,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: if (critSp != null && critSp.Type == SearchParamType.Reference && crit.Operator != Operator.CHAIN && crit.Modifier != Modifier.MISSING && crit.Operand != null) {  	var subCrit = new Criterium ();  	subCrit.Operator = crit.Operator;  	string modifier = crit.Modifier;  	//operand can be one of three things:  	//1. just the id: 10014 (in the index as internal_justid)' with no modifier  	//2. just the id' but with a modifier that contains the type: Patient:10014  	//3. full id: [http://localhost:xyz/fhir/]Patient/10014 (in the index as internal_id):  	//  - might start with a host: http://localhost:xyz/fhir/Patient/100014  	//  - the type in the modifier (if present) is no longer relevant  	//And above that' you might have multiple identifiers with an IN operator. So we have to cater for that as well.  	//Because we cannot express an OR construct in Criterium' we have choose one situation for all identifiers. We inspect the first' to determine which situation is appropriate.  	//step 1: get the operand value' or - in the case of a Choice - the first operand value.  	string operand = null;  	if (crit.Operand is ChoiceValue) {  		ChoiceValue choiceOperand = (crit.Operand as ChoiceValue);  		if (!choiceOperand.Choices.Any ()) {  			continue;  			//Choice operator without choices: ignore it.  		} else {  			operand = (choiceOperand.Choices.First () as UntypedValue).Value;  		}  	} else {  		operand = (crit.Operand as UntypedValue).Value;  	}  	//step 2: determine which situation is accurate  	int situation = 3;  	if (!operand.Contains ("/"))//Situation 1 or 2  	 {  		if (String.IsNullOrWhiteSpace (modifier))// no modifier' so no info about the referenced type at all  		 {  			situation = 1;  		} else//modifier contains the referenced type  		 {  			situation = 2;  		}  	}  	//step 3: create a subcriterium appropriate for every situation.   	switch (situation) {  	case 1:  		subCrit.ParamName = InternalField.JUSTID;  		subCrit.Operand = crit.Operand;  		break;  	case 2:  		subCrit.ParamName = InternalField.ID;  		if (crit.Operand is ChoiceValue) {  			subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => new UntypedValue (modifier + "/" + (choice as UntypedValue).Value)).ToList ());  		} else {  			subCrit.Operand = new UntypedValue (modifier + "/" + operand);  		}  		break;  	default:  		//remove the base of the url if there is one and it matches this server  		subCrit.ParamName = InternalField.ID;  		if (crit.Operand is ChoiceValue) {  			subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => {  				Uri uriOperand;  				Uri.TryCreate ((choice as UntypedValue).Value' UriKind.RelativeOrAbsolute' out uriOperand);  				var refUri = _localhost.RemoveBase (uriOperand);  				//Drop the first part if it points to our own server.  				return new UntypedValue (refUri.ToString ().TrimStart (new char[] {  					'/'  				}));  			}));  		} else {  			Uri uriOperand;  			Uri.TryCreate (operand' UriKind.RelativeOrAbsolute' out uriOperand);  			var refUri = _localhost.RemoveBase (uriOperand);  			//Drop the first part if it points to our own server.  			subCrit.Operand = new UntypedValue (refUri.ToString ().TrimStart (new char[] {  				'/'  			}));  		}  		break;  	}  	var superCrit = new Criterium ();  	superCrit.ParamName = crit.ParamName;  	superCrit.Modifier = crit.Modifier;  	superCrit.Operator = Operator.CHAIN;  	superCrit.Operand = subCrit;  	superCrit.SearchParameters.AddRange (crit.SearchParameters);  	result.Add (superCrit);  } else  	result.Add (crit);  
Magic Number,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: if (!operand.Contains ("/"))//Situation 1 or 2   {  	if (String.IsNullOrWhiteSpace (modifier))// no modifier' so no info about the referenced type at all  	 {  		situation = 1;  	} else//modifier contains the referenced type  	 {  		situation = 2;  	}  }  
Magic Number,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: if (String.IsNullOrWhiteSpace (modifier))// no modifier' so no info about the referenced type at all   {  	situation = 1;  } else//modifier contains the referenced type   {  	situation = 2;  }  
Magic Number,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: situation = 2;  
Magic Number,Spark.Search.Mongo,MongoSearcher,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Searcher\MongoSearcher.cs,NormalizeNonChainedReferenceCriteria,The following statement contains a magic number: switch (situation) {  case 1:  	subCrit.ParamName = InternalField.JUSTID;  	subCrit.Operand = crit.Operand;  	break;  case 2:  	subCrit.ParamName = InternalField.ID;  	if (crit.Operand is ChoiceValue) {  		subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => new UntypedValue (modifier + "/" + (choice as UntypedValue).Value)).ToList ());  	} else {  		subCrit.Operand = new UntypedValue (modifier + "/" + operand);  	}  	break;  default:  	//remove the base of the url if there is one and it matches this server  	subCrit.ParamName = InternalField.ID;  	if (crit.Operand is ChoiceValue) {  		subCrit.Operand = new ChoiceValue ((crit.Operand as ChoiceValue).Choices.Select (choice => {  			Uri uriOperand;  			Uri.TryCreate ((choice as UntypedValue).Value' UriKind.RelativeOrAbsolute' out uriOperand);  			var refUri = _localhost.RemoveBase (uriOperand);  			//Drop the first part if it points to our own server.  			return new UntypedValue (refUri.ToString ().TrimStart (new char[] {  				'/'  			}));  		}));  	} else {  		Uri uriOperand;  		Uri.TryCreate (operand' UriKind.RelativeOrAbsolute' out uriOperand);  		var refUri = _localhost.RemoveBase (uriOperand);  		//Drop the first part if it points to our own server.  		subCrit.Operand = new UntypedValue (refUri.ToString ().TrimStart (new char[] {  			'/'  		}));  	}  	break;  }  
Magic Number,Spark.Search.Mongo,Soundex,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Utils\Soundex.cs,For,The following statement contains a magic number: for (var i = 1; i < word.Length; i++) {  	var n = GetCharNumberForLetter (word [i]);  	if (i == 1 && n == GetCharNumberForLetter (soundex [0]))  		continue;  	if (soundex.Length > 2 && previousWasHOrW && n == soundex [soundex.Length - 2])  		continue;  	if (soundex.Length > 0 && n == soundex [soundex.Length - 1])  		continue;  	soundex.Append (n);  	previousWasHOrW = "HW".Contains (word [i]);  }  
Magic Number,Spark.Search.Mongo,Soundex,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Utils\Soundex.cs,For,The following statement contains a magic number: for (var i = 1; i < word.Length; i++) {  	var n = GetCharNumberForLetter (word [i]);  	if (i == 1 && n == GetCharNumberForLetter (soundex [0]))  		continue;  	if (soundex.Length > 2 && previousWasHOrW && n == soundex [soundex.Length - 2])  		continue;  	if (soundex.Length > 0 && n == soundex [soundex.Length - 1])  		continue;  	soundex.Append (n);  	previousWasHOrW = "HW".Contains (word [i]);  }  
Magic Number,Spark.Search.Mongo,Soundex,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Utils\Soundex.cs,For,The following statement contains a magic number: if (soundex.Length > 2 && previousWasHOrW && n == soundex [soundex.Length - 2])  	continue;  
Magic Number,Spark.Search.Mongo,Soundex,D:\newReposJune17\furore-fhir_spark\src\Spark.Mongo\Search\Utils\Soundex.cs,For,The following statement contains a magic number: if (soundex.Length > 2 && previousWasHOrW && n == soundex [soundex.Length - 2])  	continue;  
