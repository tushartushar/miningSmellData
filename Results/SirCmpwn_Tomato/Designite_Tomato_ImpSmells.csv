Implementation smell,Namespace,Class,File,Method,Description
Long Method,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The method has 305 lines of code.
Long Method,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Set,The method has 112 lines of code.
Complex Method,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,Cyclomatic complexity of the method is 13
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,InstructionLength,The following statement contains a magic number: byte valueB = (byte)((instruction & 0x3E0) >> 5);
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,InstructionLength,The following statement contains a magic number: byte valueA = (byte)((instruction & 0xFC00) >> 10);
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: while (Cycles > 0)              {                  if (IsOnFire)                      Memory[Random.Next(0xFFFF)] = (ushort)Random.Next(0xFFFF);                  // Pending immediate interrupts always take precedence over queued interrupts and preempt dequeueing.                  if (InterruptEvent.Pending)                      ExecutePendingInterrupt ();                  else if (!InterruptQueueEnabled && InterruptQueue.Count > 0)                  {                      // Since FireInterrupt only marks the interrupt as pending execution' the interrupt must be                      // executed afterwards.                      FireInterrupt(InterruptQueue.Dequeue());                      if (InterruptEvent.Pending)                          ExecutePendingInterrupt ();                  }                  if (BreakpointHit != null)                  {                      foreach (var breakpoint in Breakpoints)                      {                          if (breakpoint.Address == PC)                          {                              var bea = new BreakpointEventArgs(breakpoint);                              BreakpointHit(this' bea);                              if (!bea.ContinueExecution)                                  return;                              break;                          }                      }                  }                    ushort PCBeforeExecution = PC;                  ushort instruction = Memory[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort result' opA = 0' opB = 0;                  opA = Get(valueA);                  if (opcode != 0)                  {                      ushort pc_old = PC' sp_old = SP;                      opB = Get(valueB);                      PC = pc_old;                      SP = sp_old;                  }                  short opB_s = (short)opB;                  short opA_s = (short)opA;                  Cycles--;                  unchecked                  {                      switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }                  }                  if (!IsRunning && CyclesToExecute != -1)                      return;              }
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,SkipIfChain,The following statement contains a magic number: do              {                  Cycles--;                  ushort instruction = Memory[PC++];                  opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort SP_old = SP;                  Get(valueA);                  Get(valueB);                  SP = SP_old;              } while (opcode >= 0x10 && opcode <= 0x17);
Magic Number,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,SkipIfChain,The following statement contains a magic number: do              {                  Cycles--;                  ushort instruction = Memory[PC++];                  opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                  ushort SP_old = SP;                  Get(valueA);                  Get(valueB);                  SP = SP_old;              } while (opcode >= 0x10 && opcode <= 0x17);
Magic Number,Tomato,FastDisassembler,C:\repos\SirCmpwn_Tomato\Tomato\FastDisassembler.cs,FastDisassemble,The following statement contains a magic number: while (PC != StopAt && PC - 1 != StopAt && PC - 2 != StopAt)              {                  if (KnownLabels.ContainsKey(PC))                  {                      output.Add(new CodeEntry()                      {                          Code = KnownLabels[PC] + ":"'                          IsLabel = true'                          Address = PC                      });                      KnownLabels.Remove(PC);                      continue;                  }                  ushort instruction = Data[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                    CodeEntry entry = new CodeEntry();                  entry.Opcode = opcode;                  entry.ValueA = valueA;                  entry.ValueB = valueB;                  entry.Address = (ushort)(PC - 1);                  if (entry.Opcode != 0)                      entry.Code = GetOp(opcode);                  else                      entry.Code = GetNonbasicOp(valueB);                  entry.OpcodeText = entry.Code;                  if (entry.Code == null)                  {                      CodeEntry datEntry = new CodeEntry();                      datEntry.Code = "DAT 0x" + instruction.ToString("x");                      datEntry.Address = (ushort)(PC - 1);                      output.Add(datEntry);                  }                  else                  {                      if (entry.Opcode != 0)                      {                          string valueAdis = GetValue(valueA' false);                          string valueBdis = GetValue(valueB' true);                          entry.ValueAText = valueAdis;                          entry.ValueBText = valueBdis;                          entry.Code += " " + valueBdis + "' " + valueAdis;                          output.Add(entry);                      }                      else                      {                          string valueAdis = GetValue(valueA' false);                          entry.Code += " " + valueAdis;                          entry.ValueAText = valueAdis;                          output.Add(entry);                      }                  }              }
Magic Number,Tomato,FastDisassembler,C:\repos\SirCmpwn_Tomato\Tomato\FastDisassembler.cs,FastDisassemble,The following statement contains a magic number: while (PC != StopAt && PC - 1 != StopAt && PC - 2 != StopAt)              {                  if (KnownLabels.ContainsKey(PC))                  {                      output.Add(new CodeEntry()                      {                          Code = KnownLabels[PC] + ":"'                          IsLabel = true'                          Address = PC                      });                      KnownLabels.Remove(PC);                      continue;                  }                  ushort instruction = Data[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                    CodeEntry entry = new CodeEntry();                  entry.Opcode = opcode;                  entry.ValueA = valueA;                  entry.ValueB = valueB;                  entry.Address = (ushort)(PC - 1);                  if (entry.Opcode != 0)                      entry.Code = GetOp(opcode);                  else                      entry.Code = GetNonbasicOp(valueB);                  entry.OpcodeText = entry.Code;                  if (entry.Code == null)                  {                      CodeEntry datEntry = new CodeEntry();                      datEntry.Code = "DAT 0x" + instruction.ToString("x");                      datEntry.Address = (ushort)(PC - 1);                      output.Add(datEntry);                  }                  else                  {                      if (entry.Opcode != 0)                      {                          string valueAdis = GetValue(valueA' false);                          string valueBdis = GetValue(valueB' true);                          entry.ValueAText = valueAdis;                          entry.ValueBText = valueBdis;                          entry.Code += " " + valueBdis + "' " + valueAdis;                          output.Add(entry);                      }                      else                      {                          string valueAdis = GetValue(valueA' false);                          entry.Code += " " + valueAdis;                          entry.ValueAText = valueAdis;                          output.Add(entry);                      }                  }              }
Magic Number,Tomato,FastDisassembler,C:\repos\SirCmpwn_Tomato\Tomato\FastDisassembler.cs,FastDisassemble,The following statement contains a magic number: while (PC != StopAt && PC - 1 != StopAt && PC - 2 != StopAt)              {                  if (KnownLabels.ContainsKey(PC))                  {                      output.Add(new CodeEntry()                      {                          Code = KnownLabels[PC] + ":"'                          IsLabel = true'                          Address = PC                      });                      KnownLabels.Remove(PC);                      continue;                  }                  ushort instruction = Data[PC++];                  byte opcode = (byte)(instruction & 0x1F);                  byte valueB = (byte)((instruction & 0x3E0) >> 5);                  byte valueA = (byte)((instruction & 0xFC00) >> 10);                    CodeEntry entry = new CodeEntry();                  entry.Opcode = opcode;                  entry.ValueA = valueA;                  entry.ValueB = valueB;                  entry.Address = (ushort)(PC - 1);                  if (entry.Opcode != 0)                      entry.Code = GetOp(opcode);                  else                      entry.Code = GetNonbasicOp(valueB);                  entry.OpcodeText = entry.Code;                  if (entry.Code == null)                  {                      CodeEntry datEntry = new CodeEntry();                      datEntry.Code = "DAT 0x" + instruction.ToString("x");                      datEntry.Address = (ushort)(PC - 1);                      output.Add(datEntry);                  }                  else                  {                      if (entry.Opcode != 0)                      {                          string valueAdis = GetValue(valueA' false);                          string valueBdis = GetValue(valueB' true);                          entry.ValueAText = valueAdis;                          entry.ValueBText = valueBdis;                          entry.Code += " " + valueBdis + "' " + valueAdis;                          output.Add(entry);                      }                      else                      {                          string valueAdis = GetValue(valueA' false);                          entry.Code += " " + valueAdis;                          entry.ValueAText = valueAdis;                          output.Add(entry);                      }                  }              }
Magic Number,Tomato,HexTypeEditor,C:\repos\SirCmpwn_Tomato\Tomato\HexTypeEditor.cs,ConvertFrom,The following statement contains a magic number: if (context.PropertyDescriptor.PropertyType == typeof(uint))              {                  if (text.StartsWith("0x"))                      return uint.Parse(text.Substring(2)' NumberStyles.HexNumber);                  else                      return uint.Parse(text);              }              else              {                  if (text.StartsWith("0x"))                      return ushort.Parse(text.Substring(2)' NumberStyles.HexNumber);                  else                      return ushort.Parse(text);              }
Magic Number,Tomato,HexTypeEditor,C:\repos\SirCmpwn_Tomato\Tomato\HexTypeEditor.cs,ConvertFrom,The following statement contains a magic number: if (context.PropertyDescriptor.PropertyType == typeof(uint))              {                  if (text.StartsWith("0x"))                      return uint.Parse(text.Substring(2)' NumberStyles.HexNumber);                  else                      return uint.Parse(text);              }              else              {                  if (text.StartsWith("0x"))                      return ushort.Parse(text.Substring(2)' NumberStyles.HexNumber);                  else                      return ushort.Parse(text);              }
Magic Number,Tomato,HexTypeEditor,C:\repos\SirCmpwn_Tomato\Tomato\HexTypeEditor.cs,ConvertTo,The following statement contains a magic number: if (value is uint)                  return "0x" + GetHexString((uint)value' 8);              else                  return "0x" + GetHexString((ushort)value' 4);
Magic Number,Tomato,HexTypeEditor,C:\repos\SirCmpwn_Tomato\Tomato\HexTypeEditor.cs,ConvertTo,The following statement contains a magic number: if (value is uint)                  return "0x" + GetHexString((uint)value' 8);              else                  return "0x" + GetHexString((ushort)value' 4);
Missing Default,Tomato,DCPU,C:\repos\SirCmpwn_Tomato\Tomato\DCPU.cs,Set,The following switch statement is missing a default case: switch (destination)              {                  case 0x00:                      A = value;                      break;                  case 0x01:                      B = value;                      break;                  case 0x02:                      C = value;                      break;                  case 0x03:                      X = value;                      break;                  case 0x04:                      Y = value;                      break;                  case 0x05:                      Z = value;                      break;                  case 0x06:                      I = value;                      break;                  case 0x07:                      J = value;                      break;                  case 0x08:                      Memory[A] = value;                      break;                  case 0x09:                      Memory[B] = value;                      break;                  case 0x0A:                      Memory[C] = value;                      break;                  case 0x0B:                      Memory[X] = value;                      break;                  case 0x0C:                      Memory[Y] = value;                      break;                  case 0x0D:                      Memory[Z] = value;                      break;                  case 0x0E:                      Memory[I] = value;                      break;                  case 0x0F:                      Memory[J] = value;                      break;                  case 0x10:                      Cycles--;                      Memory[(ushort)(A + Memory[PC++])] = value;                      break;                  case 0x11:                      Cycles--;                      Memory[(ushort)(B + Memory[PC++])] = value;                      break;                  case 0x12:                      Cycles--;                      Memory[(ushort)(C + Memory[PC++])] = value;                      break;                  case 0x13:                      Cycles--;                      Memory[(ushort)(X + Memory[PC++])] = value;                      break;                  case 0x14:                      Cycles--;                      Memory[(ushort)(Y + Memory[PC++])] = value;                      break;                  case 0x15:                      Cycles--;                      Memory[(ushort)(Z + Memory[PC++])] = value;                      break;                  case 0x16:                      Cycles--;                      Memory[(ushort)(I + Memory[PC++])] = value;                      break;                  case 0x17:                      Cycles--;                      Memory[(ushort)(J + Memory[PC++])] = value;                      break;                  case 0x18:                      Memory[--SP] = value;                      break;                  case 0x19:                      Memory[SP] = value;                      break;                  case 0x1A:                      Cycles--;                      Memory[(ushort)(SP + Memory[PC++])] = value;                      break;                  case 0x1B:                      SP = value;                      break;                  case 0x1C:                      PC = value;                      break;                  case 0x1D:                      EX = value;                      break;                  case 0x1E:                      Cycles--;                      Memory[Memory[PC++]] = value;                      break;                  case 0x1F:                      Cycles--;                      PC++;                      break;              }
