Implementation smell,Namespace,Class,File,Method,Description
Long Method,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The method has 305 lines of code.
Long Method,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Set,The method has 112 lines of code.
Complex Method,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,Cyclomatic complexity of the method is 15
Complex Method,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Set,Cyclomatic complexity of the method is 32
Complex Method,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Get,Cyclomatic complexity of the method is 19
Complex Method,Tomato,FastDisassembler,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\FastDisassembler.cs,GetNonbasicOp,Cyclomatic complexity of the method is 10
Complex Method,Tomato,FastDisassembler,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\FastDisassembler.cs,GetOp,Cyclomatic complexity of the method is 28
Complex Method,Tomato,FastDisassembler,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\FastDisassembler.cs,GetValue,Cyclomatic complexity of the method is 11
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,InstructionLength,The following statement contains a magic number: byte valueB = (byte)((instruction & 0x3E0) >> 5);
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,InstructionLength,The following statement contains a magic number: byte valueA = (byte)((instruction & 0xFC00) >> 10);
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: byte valueB = (byte)((instruction & 0x3E0) >> 5);
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: byte valueA = (byte)((instruction & 0xFC00) >> 10);
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Execute,The following statement contains a magic number: switch (opcode)                      {                          case 0x00: // (nonbasic)                              switch (valueB)                              {                                  case 0x01: // JSR a                                      Cycles -= 2;                                      Memory[--SP] = PC;                                      PC = opA;                                      break;                                  case 0x08: // INT a                                      Cycles -= 3;                                      FireInterrupt(opA);                                      break;                                  case 0x09: // IAG a                                      Set(valueA' IA);                                      break;                                  case 0x0A: // IAS a                                      IA = opA;                                      break;                                  case 0x0B: // RFI a                                      A = Memory[SP++];                                      PC = Memory[SP++];                                      InterruptQueueEnabled = false;                                      break;                                  case 0x0C: // IAQ a                                      Cycles--;                                      InterruptQueueEnabled = opA != 0;                                      break;                                  case 0x10: // HWN a                                      Cycles--;                                      Set(valueA' (ushort)Devices.Count);                                      break;                                  case 0x11: // HWQ a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                      {                                          Device d = Devices[opA];                                          A = (ushort)(d.DeviceID & 0xFFFF);                                          B = (ushort)((d.DeviceID & 0xFFFF0000) >> 16);                                          C = d.Version;                                          X = (ushort)(d.ManufacturerID & 0xFFFF);                                          Y = (ushort)((d.ManufacturerID & 0xFFFF0000) >> 16);                                      }                                      break;                                  case 0x12: // HWI a                                      Cycles -= 3;                                      if (opA < Devices.Count)                                          Cycles -= Devices[opA].DoInterrupt();                                      break;                                  default:                                      if (InvalidInstruction != null)                                      {                                          var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                          PC = PCBeforeExecution;                                          InvalidInstruction(this' eventArgs);                                          if (!eventArgs.ContinueExecution)                                              return;                                      }                                      break;                              }                              break;                          case 0x01: // SET b' a                              Set(valueB' opA);                              break;                          case 0x02: // ADD b' a                              Cycles--;                              if (opB + opA > 0xFFFF)                                  EX = 0x0001;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB + opA));                              break;                          case 0x03: // SUB b' a                              Cycles--;                              if (opB - opA < 0)                                  EX = 0xFFFF;                              else                                  EX = 0;                              Set(valueB' (ushort)(opB - opA));                              break;                          case 0x04: // MUL b' a                              Cycles--;                              EX = (ushort)(((opB * opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB * opA));                              break;                          case 0x05: // MLI b' a                              Cycles--;                              EX = (ushort)(((opB_s * opA_s) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB_s * opA_s));                              break;                          case 0x06: // DIV b' a                              Cycles -= 2;                              if (opA == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB << 16) / opA) & 0xffff);                                  Set(valueB' (ushort)(opB / opA));                              }                              break;                          case 0x07: // DVI b' a                              Cycles -= 2;                              if (opA_s == 0)                              {                                  EX = 0;                                  Set(valueB' 0);                              }                              else                              {                                  EX = (ushort)(((opB_s << 16) / opA_s) & 0xffff);                                  Set(valueB' (ushort)(opB_s / opA_s));                              }                              break;                          case 0x08: // MOD b' a                              Cycles -= 2;                              if (opA == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB % opA));                              break;                          case 0x09: // MDI b' a                              Cycles -= 2;                              if (opA_s == 0)                                  Set(valueB' 0);                              else                                  Set(valueB' (ushort)(opB_s % opA_s));                              break;                          case 0x0A: // AND b' a                              Set(valueB' (ushort)(opB & opA));                              break;                          case 0x0B: // BOR b' a                              Set(valueB' (ushort)(opB | opA));                              break;                          case 0x0C: // XOR b' a                              Set(valueB' (ushort)(opB ^ opA));                              break;                          case 0x0D: // SHR b' a                              EX = (ushort)(((opB << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB >> opA));                              break;                          case 0x0E: // ASR b' a                              EX = (ushort)(((opB_s << 16) >> opA) & 0xffff);                              Set(valueB' (ushort)(opB_s >> opA));                              break;                          case 0x0F: // SHL b' a                              EX = (ushort)(((opB << opA) >> 16) & 0xffff);                              Set(valueB' (ushort)(opB << opA));                              break;                          case 0x10: // IFB b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) != 0))                                  SkipIfChain();                              break;                          case 0x11: // IFC b' a                              Cycles -= 2;                              Get(valueB);                              if (!((ushort)(opB & opA) == 0))                                  SkipIfChain();                              break;                          case 0x12: // IFE b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB == opA))                                  SkipIfChain();                              break;                          case 0x13: // IFN b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB != opA))                                  SkipIfChain();                              break;                          case 0x14: // IFG b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB > opA))                                  SkipIfChain();                              break;                          case 0x15: // IFA b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s > opA_s))                                  SkipIfChain();                              break;                          case 0x16: // IFL b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB < opA))                                  SkipIfChain();                              break;                          case 0x17: // IFU b' a                              Cycles -= 2;                              Get(valueB);                              if (!(opB_s < opA_s))                                  SkipIfChain();                              break;                          case 0x1A: // ADX b' a                              Cycles -= 2;                              uint resADX = (uint)(opB + opA + (short)EX);                              EX = (ushort)((resADX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resADX);                              break;                          case 0x1B: // SBX b' a                              Cycles -= 2;                              uint resSBX = (uint)(opB - opA + (short)EX);                              EX = (ushort)((resSBX >> 16) & 0xFFFF);                              Set(valueB' (ushort)resSBX);                              break;                          case 0x1E: // STI b' a                              Cycles--;                              Set(valueB' opA);                              I++;                              J++;                              break;                          case 0x1F: // STD b' a                              Cycles--;                              Set(valueB' opA);                              I--;                              J--;                              break;                          default:                              // According to spec' should take zero cycles                              // For sanity' all NOPs take one cycle                              if (InvalidInstruction != null)                              {                                  var eventArgs = new InvalidInstructionEventArgs(instruction' PCBeforeExecution);                                  PC = PCBeforeExecution;                                  InvalidInstruction(this' eventArgs);                                  if (!eventArgs.ContinueExecution)                                      return;                              }                              break;                      }
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,SkipIfChain,The following statement contains a magic number: byte valueB = (byte)((instruction & 0x3E0) >> 5);
Magic Number,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,SkipIfChain,The following statement contains a magic number: byte valueA = (byte)((instruction & 0xFC00) >> 10);
Magic Number,Tomato,FastDisassembler,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\FastDisassembler.cs,FastDisassemble,The following statement contains a magic number: byte valueB = (byte)((instruction & 0x3E0) >> 5);
Magic Number,Tomato,FastDisassembler,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\FastDisassembler.cs,FastDisassemble,The following statement contains a magic number: byte valueA = (byte)((instruction & 0xFC00) >> 10);
Magic Number,Tomato,FastDisassembler,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\FastDisassembler.cs,FastDisassemble,The following statement contains a magic number: PC != StopAt && PC - 1 != StopAt && PC - 2 != StopAt
Magic Number,Tomato,HexTypeEditor,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\HexTypeEditor.cs,ConvertFrom,The following statement contains a magic number: return uint.Parse(text.Substring(2)' NumberStyles.HexNumber);
Magic Number,Tomato,HexTypeEditor,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\HexTypeEditor.cs,ConvertTo,The following statement contains a magic number: return "0x" + GetHexString((uint)value' 8);
Missing Default,Tomato,DCPU,D:\research\architectureSmells\repos1\SirCmpwn_Tomato\Tomato\DCPU.cs,Set,The following switch statement is missing a default case: switch (destination)              {                  case 0x00:                      A = value;                      break;                  case 0x01:                      B = value;                      break;                  case 0x02:                      C = value;                      break;                  case 0x03:                      X = value;                      break;                  case 0x04:                      Y = value;                      break;                  case 0x05:                      Z = value;                      break;                  case 0x06:                      I = value;                      break;                  case 0x07:                      J = value;                      break;                  case 0x08:                      Memory[A] = value;                      break;                  case 0x09:                      Memory[B] = value;                      break;                  case 0x0A:                      Memory[C] = value;                      break;                  case 0x0B:                      Memory[X] = value;                      break;                  case 0x0C:                      Memory[Y] = value;                      break;                  case 0x0D:                      Memory[Z] = value;                      break;                  case 0x0E:                      Memory[I] = value;                      break;                  case 0x0F:                      Memory[J] = value;                      break;                  case 0x10:                      Cycles--;                      Memory[(ushort)(A + Memory[PC++])] = value;                      break;                  case 0x11:                      Cycles--;                      Memory[(ushort)(B + Memory[PC++])] = value;                      break;                  case 0x12:                      Cycles--;                      Memory[(ushort)(C + Memory[PC++])] = value;                      break;                  case 0x13:                      Cycles--;                      Memory[(ushort)(X + Memory[PC++])] = value;                      break;                  case 0x14:                      Cycles--;                      Memory[(ushort)(Y + Memory[PC++])] = value;                      break;                  case 0x15:                      Cycles--;                      Memory[(ushort)(Z + Memory[PC++])] = value;                      break;                  case 0x16:                      Cycles--;                      Memory[(ushort)(I + Memory[PC++])] = value;                      break;                  case 0x17:                      Cycles--;                      Memory[(ushort)(J + Memory[PC++])] = value;                      break;                  case 0x18:                      Memory[--SP] = value;                      break;                  case 0x19:                      Memory[SP] = value;                      break;                  case 0x1A:                      Cycles--;                      Memory[(ushort)(SP + Memory[PC++])] = value;                      break;                  case 0x1B:                      SP = value;                      break;                  case 0x1C:                      PC = value;                      break;                  case 0x1D:                      EX = value;                      break;                  case 0x1E:                      Cycles--;                      Memory[Memory[PC++]] = value;                      break;                  case 0x1F:                      Cycles--;                      PC++;                      break;              }
